//----------------------------------------------------------------//
// ===== UserSimLpn.cpp =====
// sample program to reconstruct L p n event
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// reconstruction mathod is based on "EventAnalysis_Lpn_sada.cpp"
//----------------------------------------------------------------//
//  exe-file: simLpn [./simread $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: root-file (= only histograms)
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//
//  updated by F.S, 2016 12/06
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"
#include "TrackTools.h"

#include "Tools.h"
#include "ELossTools.h"

#include <TDatabasePDG.h>
#include "KinFitter/TKinFitter.h"
#include "KinFitter/TFitParticlePxPyPz.h"
#include "KinFitter/TFitConstraintM.h"
#include "KinFitter/TFitConstraintEp.h"

#define KFDEBUG 0 // verbose level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices

TTree *vtxRTree;

Float_t tlogprob1;
Float_t tlogprob2;

Float_t twoimprob1;
Float_t twoimprob2;

TLorentzVector tL_L;
TLorentzVector tL_p;
TLorentzVector tL_n;
TLorentzVector tL_K;

const double MOM_RES = 2.0; // MeV/c
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)

using namespace std;

static const double CDC_MAX_CHI=30;

int main( int argc, char** argv )
{
  if( argc!=5 ){
    cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<endl;
    return 0;
  }

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");

  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//
  double covVal[6][16] = {
    // ### obtained from (p_meas[j]-p_gene[j])*(p_meas[k]-p_gene[k])
    // ###  using G4-data with TH1F(Form("cov_%d_%d_%d", i, j, k), 100, -cov_MAX, cov_MAX);
    // {beam kaon}, {lambda}, {neutron},
    // {proton}, {proton from lambda}, {pi- from lambda}
    { 5.89783e-05, 3.466e-05, 7.87064e-05, 7.0336e-05,
      3.466e-05, 5.65764e-05, 7.58042e-05, 6.77393e-05,
      7.87064e-05, 7.58042e-05, 5.28858e-05, 4.73357e-05,
      7.0336e-05, 6.77393e-05, 4.73357e-05, 4.23708e-05 },
    { 0.000207257, 0.000179973, 0.000148674, 0.000199125,
      0.000179973, 0.000213038, 0.000155228, 0.000208214,
      0.000148674, 0.000155228, 0.000188014, 0.000144255,
      0.000199125, 0.000208214, 0.000144255, 0.000195619 },
    { 0.000310575, 0.000310411, 0.000313857, 0.000302319,
      0.000310411, 0.000309396, 0.000326896, 0.000312685,
      0.000313857, 0.000326896, 0.000302884, 0.000307791,
      0.000302319, 0.000312685, 0.000307791, 0.000326694 },
    { 0.000249203, 0.000218144, 0.000188326, 0.000237145,
      0.000218144, 0.000258923, 0.000189825, 0.000245481,
      0.000188326, 0.000189825, 0.000213973, 0.000186421,
      0.000237145, 0.000245481, 0.000186421, 0.000232521 },
    { 0.000211854, 0.000185869, 0.000139497, 0.000190273,
      0.000185869, 0.000205783, 0.000155463, 0.000208168,
      0.000139497, 0.000155463, 0.000167076, 0.000140599,
      0.000190273, 0.000208168, 0.000140599, 0.000192585 },
    { 2.38346e-05, 2.27798e-05, 1.05223e-05, 1.19754e-05,
      2.27798e-05, 1.52574e-05, 1.0513e-05, 1.84231e-05,
      1.05223e-05, 1.0513e-05, 1.79304e-05, 8.66373e-06,
      1.19754e-05, 1.84231e-05, 8.66373e-06, 1.05972e-05 }
  };
  TMatrixD *covZero = new TMatrixD(4, 4);
  covZero->Zero();
  covZero->ResizeTo(3, 3); // resize from 4x4 to 3x3
  TMatrixD *covParticle[6];
  for( int i=0; i<6; i++ ){
    covParticle[i] = new TMatrixD(4, 4);
    int n = 0;
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( j==k ) (*covParticle[i])[j][k] = covVal[i][n]; // only diagonal elements
	else       (*covParticle[i])[j][k] = 0;
	n++;
      }
    }
    covParticle[i]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticle[i]->Print(); // Print all
  }
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//


  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);
  if( tree2->GetEntries()==1 ) cout<<"  !!! tree2 entries==1 !!!"<<endl;
  else tree2->GetEntry(0);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = 0;
  DetectorData *detData = 0;
  ReactionData *reacData = 0;
  MCData       *mcData = 0;
  tree-> SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree-> SetBranchAddress("DetectorData", &detData);
  tree-> SetBranchAddress("ReactionData", &reacData);
  tree-> SetBranchAddress("MCData", &mcData);

  TFile *cdcfile = new TFile(argv[4]);
  CDSHitMan *cdsMan = new CDSHitMan();
  BeamLineHitMan *blMan = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan = new BeamLineTrackMan();
  CDSTrackingMan *cdstrackMan = new CDSTrackingMan();

  TTree *evTree = (TTree*)cdcfile->Get("EventTree");
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    return 0;
  }

  TFile *outfile = new TFile(argv[2], "recreate");
  outfile->cd();


  //=== definitino of histograms ===//
  Tools::newTH2F(Form("PID_all"), 100, -0.5, 2.0, 100, -1.5, 1.5);
  Tools::newTH1F(Form("MM_pppim"), 70, 0.4, 1.8);

  Tools::newTH1F(Form("BLC2BPC_matching_x"), 40, -2., 2.);
  Tools::newTH1F(Form("BLC2BPC_matching_y"), 40, -2., 2.);
  Tools::newTH1F(Form("BLC2BPC_matching_dx"), 40, -0.05, 0.05);
  Tools::newTH1F(Form("BLC2BPC_matching_dy"), 40, -0.05, 0.05);

  Tools::newTH1F(Form("logprobim_Lpn"), 20, 0., 10.);
  Tools::newTH1F(Form("logprobim_sum_Lpn"), 20, 0., 10.);

  Tools::newTH2F(Form("ndalitzIM_Lpn"), 50, 4., 9., 50, 4., 9.);

  Tools::newTH2F(Form("nIM_Mm_Lp"), 1000, 2, 3, 1400, 0.4, 1.8);
  Tools::newTH1F(Form("ncosL_Lp"), 800, -1, 1);
  Tools::newTH1F(Form("ncosp_Lp"), 800, -1, 1);
  
  Tools::newTH1F(Form("ncoslabL_Lp"), 800, -1, 1);
  Tools::newTH1F(Form("ncoslabp_Lp"), 800, -1, 1);
  
  Tools::newTH1F(Form("ncosLkpp"), 800, -1, 1);
  Tools::newTH1F(Form("ncospkpp"), 800, -1, 1);

  Tools::newTH1F(Form("nmomL_Lp"), 700, 0, 1.4);
  Tools::newTH1F(Form("nmomp_Lp"), 700, 0, 1.4);
  Tools::newTH1F(Form("ncosOA_Lp"), 800, -1, 1);
  
  Tools::newTH1F(Form("nIM_Lp_Lpn"), 1000, 2, 3);		  
  Tools::newTH1F(Form("nIM_Ln_Lpn"), 1000, 2, 3);		  
  Tools::newTH1F(Form("nOAlp_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("nOAln_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("nOApn_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("ncosL_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("ncosp_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("ncosn_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("ncoslabL_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("ncoslabp_Lpn"), 800, -1, 1);
  Tools::newTH1F(Form("ncoslabn_Lpn"), 800, -1, 1);
  
  Tools::newTH1F(Form("nmomL_Lpn"), 700, 0, 1.4);
  Tools::newTH1F(Form("nmomp_Lpn"), 700, 0, 1.4);
  Tools::newTH1F(Form("nmomn_Lpn"), 700, 0, 1.4);
  
  Tools::newTH2F(Form("nIM_Mm_Lpn"), 1000, 2, 3, 300, 0.8, 1.1);
  Tools::newTH2F(Form("nIM_OAlp_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_OAln_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_OApn_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_cosL_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_cosp_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_cosn_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_coslabL_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_coslabp_Lpn"), 1000, 2, 3, 800, -1, 1);
  Tools::newTH2F(Form("nIM_coslabn_Lpn"), 1000, 2, 3, 800, -1, 1);
  
  Tools::newTH2F(Form("nIM_qtransn_Lpn"), 1000, 2, 3, 800, -0.3, 1.3);
  
  Tools::newTH2F(Form("nIM_momL_Lpn"), 1000, 2, 3, 700, 0, 1.4);
  Tools::newTH2F(Form("nIM_momp_Lpn"), 1000, 2, 3, 700, 0, 1.4);
  Tools::newTH2F(Form("nIM_momn_Lpn"), 1000, 2, 3, 700, 0, 1.4);
  
  
  Tools::newTH1F(Form("nmomL_Lpn_lab"), 700, 0, 1.4);
  Tools::newTH1F(Form("nmomp_Lpn_lab"), 700, 0, 1.4);
  Tools::newTH1F(Form("nmomn_Lpn_lab"), 700, 0, 1.4);
  
  Tools::newTH2F(Form("ndalitz_Lpn"), 480, -0.6, 0.6, 400, 0, 1 );
  Tools::newTH2F(Form("ndalitz2_Lpn"), 480, -0.6, 0.6, 400, 0, 1 );
  Tools::newTH2F(Form("ndalitz_n_Lpn"), 480, -0.6, 0.6, 400, 0, 1 );
  Tools::newTH2F(Form("ndalitz2_n_Lpn"), 480, -0.6, 0.6, 400, 0, 1 );
  Tools::newTH2F(Form("nIM_Tn_Lpn"), 1200, 0, 3, 400, 0, 1);


  //----------------------------//
  //---  for kinematical fit ---//
  //----------------------------//
  // beam_K(K+), L, n, p, p from L, pi- from L
  const double cov_MAX = 1.0e-3;
  for( int i=0; i<6; i++ ){
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	Tools::newTH1F(Form("cov_%d_%d_%d", i, j, k), 100, -cov_MAX, cov_MAX);
      }
    }
  }
  const double diff_p_MAX = 1.0e-1;
  const double diff_per_MAX = 10;
  for( int i=0; i<6; i++ ){
    Tools::newTH1F(Form("p_gene_%d", i), 100, 0, 1.5);
    Tools::newTH1F(Form("p_meas_%d", i), 100, 0, 1.5);
    Tools::newTH1F(Form("p_kfit_%d", i), 100, 0, 1.5);
    Tools::newTH1F(Form("p_meas_gene_%d", i), 100, -diff_p_MAX, diff_p_MAX);
    Tools::newTH1F(Form("p_kfit_gene_%d", i), 100, -diff_p_MAX, diff_p_MAX);
    Tools::newTH1F(Form("p_meas_kfit_%d", i), 100, -diff_p_MAX, diff_p_MAX);
    Tools::newTH1F(Form("p_per_meas_gene_%d", i), 100, -diff_per_MAX, diff_per_MAX);
    Tools::newTH1F(Form("p_per_kfit_gene_%d", i), 100, -diff_per_MAX, diff_per_MAX);
    Tools::newTH1F(Form("p_per_meas_kfit_%d", i), 100, -diff_per_MAX, diff_per_MAX);
  }
  Tools::newTH1F(Form("IM_Lp_gene"), 100, 2, 3);
  Tools::newTH1F(Form("IM_Lp_meas"), 100, 2, 3);
  Tools::newTH1F(Form("IM_Lp_kfit"), 100, 2, 3);
  Tools::newTH1F(Form("IM_Lp_meas_gene"), 100, -0.1, 0.1);
  Tools::newTH1F(Form("IM_Lp_kfit_gene"), 100, -0.1, 0.1);
  Tools::newTH1F(Form("IM_Lp_meas_kfit"), 100, -0.1, 0.1);
  Tools::newTH1F(Form("IM_per_Lp_meas_gene"), 100, -5, 5);
  Tools::newTH1F(Form("IM_per_Lp_kfit_gene"), 100, -5, 5);
  Tools::newTH1F(Form("IM_per_Lp_meas_kfit"), 100, -5, 5);
  
  Tools::newTH1F(Form("Lpn_kfit_chi2"), 100, 0, 40);
  Tools::newTH1F(Form("Lpn_kfit_DOF"), 6, -0.5, 5.5);
  Tools::newTH1F(Form("Lpn_kfit_rchi2"), 100, 0, 20);

  Tools::newTH1F(Form("Lpn_gene_costheta_nK_pL"), 20, -1, 1);
  Tools::newTH1F(Form("Lpn_kfit_costheta_nK_pL"), 20, -1, 1);
  //----------------------------//
  //---  for kinematical fit ---//
  //----------------------------//


  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = stopn < eventn ? stopn : eventn;

  cout<<"===== Lambda p n reconstruction in MC START ============="<<endl;
  cout<<"     # of All  Event in EventTree:     "<<eventn<<endl;
  cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<endl;
  cout<<"     # of Exe  Event in this program:  "<<exen<<endl;
  cout<<"========================================================="<<endl;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;
  int nEvent_Lp    = 0;
  int nEvent_Lpn   = 0;

  int nG4Event_Lp   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_numT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_ftarget = 0;
  int nAbort_pppim = 0;
  int nAbort_chargeveto = 0;
  int nAbort_flagbprob = 0;

  int nTrack_CDHshare = 0;

  //=== event loop ===//
  for( int ev=0; ev<exen; ev++ ){
    if( /*ev<100 ||*/ ev%100==0 ) std::cout<<"> Event Number "<<ev<<std::endl;
    //if( ev == 1000 ) break;
    
    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(ev);
    evTree->GetEntry(ev);
    simMan->Convert(detData, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);  
    bltrackMan->DoTracking(blMan,confMan,true,true);

    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4LppimDecay = false;
    int kpp_track = -1;
    int L_parent  = 0;
    int p_parent  = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      int track   = mcData->track(j)->trackID();
      if( pdgcode==9999 && parent==0 ){ // Kpp
	kpp_track = track;
	L_parent  = track;
	p_parent  = track;
      }
      if( pdgcode==3212 && parent==0 ){ // initial Sigma0
	L_parent = track;
      }
      if( pdgcode==3212 && parent==kpp_track ){ // Sigma0 from Kpp
	L_parent = track;
      }
    }
    int PDG[6] = {321, 3122, 2112, 2212, 2212, -211};
    // beam_K(K+), L, n, p, p from L, pi- from L
    int parentID[6] = {0, L_parent, 0, p_parent, -1, -1};
    int ID[6]       = {-1, -1, -1, -1, -1, -1};
    int trackID[6]  = {-1, -1, -1, -1, -1, -1};
    int nparticle = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      int track   = mcData->track(j)->trackID();
      for( int k=0; k<6; k++ ){
	if( pdgcode==PDG[k] && parent==parentID[k] ){
	  ID[k] = j;
	  trackID[k] = track;
	  nparticle++;
	  if( k==1 ){
	    parentID[4] = track;
	    parentID[5] = track;
	  }
	}
      }
    }
    if( nparticle==6 ) flagG4LppimDecay = true;

    int nCDHhit[6] = {0, 0, 0, 0, 0, 0};
    if( flagG4LppimDecay ){ // Lambda -> p pi- decay
      for( int j=0; j<detData->detectorHitSize(); j++ ){
	int cid   = detData->detectorHit(j)->detectorID();
	int track = detData->detectorHit(j)->trackID();
	for( int k=3; k<6; k++ ){
	  if( cid==CID_CDH && track==trackID[k] ) nCDHhit[k]++;
	}
      }
    }
    if( nCDHhit[3] && nCDHhit[4] && nCDHhit[5] ) nG4Event_Lp++;
#if 0
    else{
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      continue;
    }
#endif

    // beam_K(K+), L, n, p, p from L, pi- from L
    TLorentzVector TL_gene[6]; // generated
    if( flagG4LppimDecay ){ // Lambda -> p pi- decay
      for( int i=0; i<6; i++ ){
	if( i ) TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*0.001,  pdg->GetParticle(PDG[i])->Mass()); // GeV
	else    TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*-0.001, pdg->GetParticle(PDG[i])->Mass()); // GeV
      }
      TVector3 boost = TL_gene[1].BoostVector(); // CM @ L
      TLorentzVector TL_gene_CM[6]; // generated at CM
      for( int i=0; i<6; i++ ){
	TL_gene_CM[i] = TL_gene[i];
	TL_gene_CM[i].Boost(-1*boost);
      }
      TVector3 n_cross_K = TL_gene_CM[2].Vect().Cross(TL_gene_CM[0].Vect()); // n x K-
      double costheta_nK_pL = cos(n_cross_K.Angle(TL_gene_CM[4].Vect())); // angle btw (n x K-) and (p from Lambda)
      Tools::Fill1D("Lpn_gene_costheta_nK_pL", costheta_nK_pL);
    }
    //##########################//
    //### get G4 information ###//
    //##########################//



    //=======================================//
    //=== from EventAnalysis_Lpn_sada.cpp ===//
    //=======================================//
    int nGoodTrack = cdstrackMan->nGoodTrack();
    int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;

    if( nGoodTrack!=3 ){ // dedicated for p p pi- event
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_nGoodTrack++;
      continue;
    }


    //### T0
    int numT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      HodoscopeLikeHit *hit = blMan->T0(i);
      if( hit->CheckRange() ) numT0++;
    }

    //### select T0=1hit  
    if( numT0!=1 ){ 
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_numT0++;
      continue;
    }

    //### Beam PID
    TVector3 vtxT0;
    double ctmT0=0;
    for( int i=0; i<blMan->nT0(); i++ ){
      if( blMan->T0(i)->CheckRange() ){
	ctmT0 = blMan->T0(i)->ctmean();
	confMan->GetGeomMapManager()->GetGPos(CID_T0, blMan->T0(i)->seg(), vtxT0);
      }
    }
    int pid_beam = 0; //0:K 1:pi 3:else

    //### BPC selection
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ){
      if( bltrackMan->trackBPC(i)->CheckRange(-30,100) ){
	nbpc++;
	bpcid = i;
      }
    }

    if( nbpc!=1 ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_nbpc++;
      continue;
    }
    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);    

    if( !(bpctrack->CheckRange(-10,10)) || bpctrack->chi2all()>10 ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_bpctrack++;
      continue;
    }

    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ){
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }


    //### vector for PIDcon
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    std::vector <int> d_ID;
    
    std::vector <int> spip_ID;
    std::vector <int> spim_ID;
    std::vector <int> skm_ID;
    std::vector <int> sp_ID;

    std::vector <int> vCDHseg;

    TVector3 tar_cen;
    tar_cen.SetXYZ(-0.475, 0, 1.4);
    bool flagbmom = false;
    bool flagtar  = false;
    TLorentzVector L3_beambf, L3_beam, L3_target, L3_targetP;
    TLorentzVector L3_beambfCM, L3_beamCM, L3_targetCM, L3_targetPCM;
    TLorentzVector Lpipdef, Lpimdef;
    TVector3 vtx_react;

    //### BLC2
    int nblc2 = 0;
    int blc2id = -1;

    //### Beamline chamber timing selection
    for( int i=0; i<bltrackMan->ntrackBLC2(); i++ ){
      LocalTrack *blc2 = bltrackMan->trackBLC2(i);
      if( blc2->CheckRange(-30,100) ){
	nblc2++;
	if( blc2->CheckRange(-5,5) && bltrackMan->trackBLC2(i)->chi2all()<10 ) blc2id = i;
      }
    }

    if( nblc2!=1 && blc2id==-1 ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_nblc2++;
      continue;
    }

    //### BLC2-BPC position matching
    bool fblc2bpc = false;
    for( int ii=0; ii<bltrackMan->ntrackBLC2(); ii++ ){
      if( ii!=blc2id ) continue;
      LocalTrack *blc2 = bltrackMan->trackBLC2(ii);
      double xblc2bpc[2], yblc2bpc[2];
      double xmom[2], ymom[2];
      bpctrack->XYPosatZ(-19.7, xmom[0], ymom[0]);
      bpctrack->XYPosatZ(-74.85, xblc2bpc[0], yblc2bpc[0]);
      blc2->XYPosatZ(-74.85, xblc2bpc[1], yblc2bpc[1]);
      blc2->XYPosatZ(-130, xmom[1], ymom[1]);
      double dxdz[2], dydz[2];
      dxdz[0]=(xmom[0]-xblc2bpc[0])/(-19.7+74.85);
      dxdz[1]=(xblc2bpc[1]-xmom[1])/(130-74.85);
      dydz[0]=(ymom[0]-yblc2bpc[0])/(-19.7+74.85);
      dydz[1]=(yblc2bpc[1]-ymom[1])/(130-74.85);
      
      if( (xblc2bpc[1]-xblc2bpc[0])<-0.795 || (xblc2bpc[1]-xblc2bpc[0])>0.822 ) fblc2bpc = false;
      else if( (yblc2bpc[1]-yblc2bpc[0])<-0.865|| (yblc2bpc[1]-yblc2bpc[0])>0.871 ) fblc2bpc = false;
      else if( (dxdz[1]-dxdz[0])<-0.0240 || (dxdz[1]-dxdz[0])>0.0250 ) fblc2bpc = false;//check after!!
      else if( (dydz[1]-dydz[0])<-0.02481 ||(dydz[1]-dydz[0])>0.02489 ) fblc2bpc = false;//check after!!
      else fblc2bpc = true;
      Tools::Fill1D("BLC2BPC_matching_x", xblc2bpc[1]-xblc2bpc[0]);
      Tools::Fill1D("BLC2BPC_matching_y", yblc2bpc[1]-yblc2bpc[0]);
      Tools::Fill1D("BLC2BPC_matching_dx", dxdz[1]-dxdz[0]);
      Tools::Fill1D("BLC2BPC_matching_dy", dydz[1]-dydz[0]);
    }

    if( !fblc2bpc ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      //cerr<<"event # "<<ev<<" abort:  fblc2bpc = "<<fblc2bpc<<endl;
      nAbort_fblc2bpc++;
      continue;
    }


    //### Calc beam momentum
    double beammom = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      if( pdgcode==321 && parent==0 ){
	beammom = (mcData->track(j)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
	break;
      }
    }

    double x1, y1, x2, y2;
    double z1 = 0, z2 = 20;
    bpctrack->XYPosatZ(z1, x1, y1);
    bpctrack->XYPosatZ(z2, x2, y2);
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls; 
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    L3_beambf.SetVectM(Pp_beam , kpMass);
    L3_target.SetVectM(Pp_target, ThreeHeMass);
    L3_targetP.SetVectM(Pp_target, pMass);
    L3_beam = L3_beambf;
    TVector3 boost = (L3_target+L3_beam).BoostVector();
    L3_beambfCM = L3_beam;
    L3_targetCM = L3_target;
    L3_targetPCM = L3_targetP;
    L3_beambfCM.Boost(-1*boost);
    L3_targetCM.Boost(-1*boost);
    L3_targetPCM.Boost(-1*boost);
    flagbmom = true;

    if( !flagbmom ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_flagbmom++;
      continue;
    }

    //### Vertex study
    for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){
      CDSTrack *track = cdstrackMan->Track( cdstrackMan->GoodTrackID(it) );
      double param[5];
      track->GetParameters(param);
      TVector3 vtxb1, vtxb2, vtxb;
      track->GetVertex(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtxb1, vtxb2);
      vtxb=(vtxb1+vtxb2)*0.5;
    }

    //### Fiducial cut at z=0
    bool ftarget = false;
    double z = 0;
    double x, y;
    bpctrack->XYPosatZ(z, x, y);
    TVector3 vtx_tar;
    vtx_tar.SetXYZ(x, y, z);
    if( GeomTools::GetID(vtx_tar)==CID_Fiducial ) ftarget = true;

    if( !ftarget ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_ftarget++;
      continue;
    }


    //### PID of CDS
    for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){
      CDSTrack *track = cdstrackMan->Track(cdstrackMan->GoodTrackID(it));
      if( !track->CDHFlag() ) continue;

      double param[5];
      track->GetParameters(param);
      double mom = track->Momentum();
      TVector3 vtxb1, vtxb2, vtxb;
      
      track->GetVertex(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtxb1, vtxb2);
      track->SetPID(-1);
      vtxb = (vtxb1+vtxb2)*0.5;
      if( GeomTools::GetID(vtxb)==CID_Fiducial ){
	flagtar = true; 
	vtx_react = vtxb;
      }

      double tof = 999.;
      double mass2 = -999.;
      int CDHseg = -1;
      for( int icdh=0; icdh<track->nCDHHit(); icdh++ ){
	HodoscopeLikeHit *cdhhit=track->CDHHit(cdsMan,icdh);
	double tmptof = cdhhit->ctmean() - ctmT0;      
	//cerr<<icdh<<": "<<cdhhit->ctmean()<<" - "<<ctmT0<<" = "<<tmptof<<endl;
	if( tmptof<tof || tof==999. ){ //*** apply minimum TOF hit ***//
	  tof = tmptof;
	  CDHseg = cdhhit->seg();
	}
      }
      //*************************************
      // In a CDH hit-shared event, only some one track is adopted and the others are discarded
      // Is it correct treatment?
      //*************************************
      bool CDHflag = true;
      for( int m=0; m<(int)vCDHseg.size(); m++ ){
	if( CDHseg==vCDHseg[m] ) CDHflag = false;
      }
      if( !CDHflag ){
	nTrack_CDHshare++;
	continue;
      }
      vCDHseg.push_back(CDHseg);

      double tmptof, beta_calc;
      TrackTools::CalcBetaMass2(vtxb, bpctrack, track, confMan, pid_beam,
				(double)L3_beam.Vect().Mag(), tof, beta_calc, mass2);

      //### Retiming of CDC track by CDH info.
      track->Retiming(cdsMan, confMan, beta_calc, true);
      for( int m=0; m<5; m++ ) track->HelixFitting(cdsMan);
      track->Calc(confMan);

      //### finalize PID
      if( !TrackTools::FindMass2C(track, bpctrack, tof, L3_beam.Vect().Mag(),
				  pid_beam, beta_calc, mass2, tmptof) ) continue;

      int pid = TrackTools::PIDcorr(mom,mass2);      
      track->SetPID(pid);

      //### Calc energy loss
      double tmpl;
      TVector3 vtx_beam, vtx_cds;
      if( !track->CalcVertexTimeLength(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), track->Mass(),
				       vtx_beam, vtx_cds, tmptof, tmpl, true) )
	std::cout<<"Eloss false!"<<std::endl;

      if( pid==CDS_PiMinus ){
	pim_ID.push_back(cdstrackMan->GoodTrackID(it));
      }
      else if( pid==CDS_PiPlus ){
	pip_ID.push_back(cdstrackMan->GoodTrackID(it));
      }
      else if( pid==CDS_Proton ){
	p_ID.push_back(cdstrackMan->GoodTrackID(it));
      }
      else if( pid==CDS_Deuteron ){
	d_ID.push_back(cdstrackMan->GoodTrackID(it));
      }
      else if( pid==CDS_Kaon ){
	km_ID.push_back(cdstrackMan->GoodTrackID(it));
      }
      
      if( pid<7 ) nTrack_PID++;
      Tools::Fill2D("PID_all", mass2, mom);

      //cerr<<"    pid = "<<pid<<", tof = "<<tmptof<<", beta = "<<beta_calc
      //<<", mom = "<<mom<<", mass = "<<sqrt(fabs(mass2))<<endl;

    }// for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){

    if( !(p_ID.size()==2 && pim_ID.size()==1) ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_pppim++;
      continue;
    }

    //### nCDC
    //int nCDCin = 0, nCDC = 0;
    //for( int layer=1; layer<=15; layer++ ){
    //  if( layer<=3 ) nCDCin+=cdsMan->nCDC(layer);
    //  nCDC += cdsMan->nCDC(layer);
    //}

    //### short PID
    // for( int it1=0; it1<trackMan->nShortTrack(); it1++ ){
    //   CDSTrack *track1 = trackMan->ShortTrack(it1);
    //   //    track1->Calc(confMan);
    //   if(!track1->IHFlag()) continue;
    //   HodoscopeLikeHit *ih=0;
    //   for(int l=0;l<track1->nIHHit();l++) ih=track1->IHHit(cdsMan,l);
    //   if(!(ih->seg()>=1 && ih->seg()<=24) ) continue;
    //   TVector3 pos;
    //   //    double len,wid,th,lv;
    //   //    confMan->GetGeomMapManager()->GetParam(CID_IH, ih->seg(),pos,dir,len,wid,th,lv);
    //   confMan->GetGeomMapManager()->GetGPos(CID_IH, ih->seg(),pos);
    //
    //   double phi=pos.Phi();
    //   TVector3 momih;
    //   track1->GetMomentum(track1->IHVertex(),momih);
    //   double mom=track1->Momentum();		    
    //   double deih=ih->eu();
    //   double cospt=cos(phi-momih.Phi());
    //   double deih2=deih*sin(momih.Theta())*cospt;
    //   Tools::Fill2D("IHPID",deih,mom);
    //   Tools::Fill2D("IHPID2",deih2,mom);
    //   //mom=0.7*sqrt(1/de)*exp(-0.5*de)
    //   double thr=0.7*sqrt(1/deih)*exp(-0.5*deih);
    //   double mass;
    //   if(fabs(mom)<thr ) 
    //     {
    // 	mass=piMass;
    // 	if(mom<0)
    // 	  {spim_ID.push_back(it1);
    // 	    track1->SetPID(1);}
    // 	else 
    // 	  {  
    // 	    spip_ID.push_back(it1);
    // 	    track1->SetPID(2);}
    //     }
    //   else  if(fabs(mom)>=thr ) 	 
    //     {
    // 	    mass=pMass;
    // 	    if(mom<0)
    // 	      { 
    // 		track1->SetPID(6);
    // 	      }
    // 	    else
    // 	      {
    // 		sp_ID.push_back(it1);
    // 		track1->SetPID(5);}
    //     }
    // }
    //##end short PID


    //### charge veto by forward counters (CVC/BVC)
    bool chargedhit = false;
    for( int i=0; i<blMan->nTOF(); i++ ){
      HodoscopeLikeHit *hit = blMan->TOF(i);
      if( hit->CheckRange() ) chargedhit = true;
    }
    for( int i=0; i<blMan->nBVC(); i++ ){
      HodoscopeLikeHit *hit = blMan->BVC(i);
      if( hit->CheckRange() ) chargedhit = true;
    }

    if( chargedhit ){
      cdsMan->Clear();
      blMan->Clear();
      bltrackMan->Clear();
      nAbort_chargeveto++;
      continue;
    }


    //### Lp n_miss event study         
    if( flagbmom && p_ID.size()==2 && pim_ID.size()==1 && cdstrackMan->nGoodTrack()==3 && !chargedhit ){
      int npL = -1;
      double dca_ppi[2]  = {999,999};
      double dca_p[2]    = {999,999};
      double dca_Lp[2]   = {999,999};
      double dca_L[2]    = {999,999};
      double dca_reac[2] = {999,999};
      double dis_Lct[2]  = {0,0};
      double dca_sum[2]  = {999,999};
      bool LinFid[2]     = {false};      
      bool PinFid[2]     = {false};
      bool RinFid[2]     = {false};
      TVector3 vtx_piL[2], vtx_pL[2], vtx_L[2], vtx_p[2];
      TVector3 vtxreac[2];
      TLorentzVector L_pL, L_piL, L_p, L_n, L_L;
      double pt_pL[2], pt_piL[2], pt_p[2];

      double im_ppi[2], mm_ppipi[2];
  
      //### calc dca_ppi & vertex
      for( int ip=0; ip<(int)p_ID.size(); ip++ ){
	for( int npi=0; npi<(int)pim_ID.size(); npi++ ){
	  CDSTrack *track_p = cdstrackMan->Track(p_ID[ip]);
	  CDSTrack *track_pim = cdstrackMan->Track(pim_ID[npi]);
	  int p2 = -1;
	  if( ip==0 ) p2 = 1;
	  else if( ip==1 ) p2 = 0;
	  CDSTrack *track_p2 = cdstrackMan->Track(p_ID[p2]);

	  double dis_vtx_ppi = 0;
	  TrackVertex vertex;
	  TVector3 vtx_pi, vtx_pd, vtx;
	  if( !TrackTools::Calc2HelixVertex(track_p,track_pim,vtx_pd,vtx_pi) ){
	    std::cout<<"cvtx!! "<<p_ID[ip]<<" "<<pim_ID[npi]<<std::endl;
	    continue;
	  }

	  vtx = (vtx_pd+vtx_pi)*0.5;
	  dis_vtx_ppi = (vtx_pd-vtx_pi).Mag();
	  dca_ppi[ip] = dis_vtx_ppi;
	  vtx_piL[ip] = vtx_pi;
	  vtx_pL[ip]  = vtx_pd;

	  pt_pL[ip]  = track_p->Pt();
	  pt_piL[ip] = track_pim->Pt();
	  pt_p[ip]   = track_p2->Pt();

	  TVector3 Pp_p, Pp_pim, Pp_ppi, Pp_p2;
	  if( !track_p->GetMomentum(vtx_pL[ip],Pp_p,true,true) ){
	    std::cout<<"cP p!!"<<std::endl;
	    continue;
	  }
	  if( !track_pim->GetMomentum(vtx_piL[ip],Pp_pim,true,true) ){
	    std::cout<<"cP pim lpn!!"<<std::endl;
	    continue;
	  }
	  if( !track_p2->GetMomentum(vtx_p[ip],Pp_p2,true,true) ){
	    std::cout<<"cP p lpn!!"<<std::endl;
	    continue;
	  }

	  TLorentzVector tL_p1, tL_p2, tL_pi;
	  tL_p1.SetVectM(Pp_p, pMass);
	  tL_pi.SetVectM(Pp_pim, piMass);
	  tL_p2.SetVectM(Pp_p2, pMass);
	  
	  Pp_ppi = Pp_p+Pp_pim;
	  im_ppi[ip] = (tL_p1+tL_pi).M();

	  double x1, y1, x2, y2;
	  double z1 = 0, z2 = 20;
	  bpctrack->XYPosatZ(z1, x1, y1);		  
	  bpctrack->XYPosatZ(z2, x2, y2);
	  TVector3 lp;
	  lp.SetXYZ(x1, y1, z1);
	  TVector3 ls;
	  ls.SetXYZ(x2-x1, y2-y1, z2-z1);
	  ls = ls.Unit();
	      
	  double dist_L, dltmp = 0;
	  TVector3 vtx_Lt, nest;
	  MathTools::LineToLine(vtx, Pp_ppi.Unit(), lp, ls, dltmp, dist_L, vtx_Lt, nest);

	  dca_L[ip] = dist_L;
	  vtx_L[ip] = vtx_Lt;
	  dis_Lct[ip] = (vtx_Lt-vtx).Mag();
	      
	  if( GeomTools::GetID(vtx_Lt)==CID_Fiducial ){
	    LinFid[ip] = true;
	  }
	     
	  TVector3 vtxb1, vtxb2;
	  track_p2->GetVertex(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtxb1, vtx_p[ip]);
	  dca_p[ip] = (vtx_p[ip]-vtxb1).Mag();
	  dca_Lp[ip] = (vtx_p[ip]-vtx_L[ip]).Mag();


	  vtxreac[ip] = 0.5*((vtxb1)+(nest));
	  dca_reac[ip] = ((vtxb1)-(nest)).Mag();

	  if( GeomTools::GetID(vtx_p[ip])==CID_Fiducial ){
	    PinFid[ip] = true;
	  }

	  if( GeomTools::GetID(vtxreac[ip])==CID_Fiducial ){
	    RinFid[ip] = true;
	  }


	  //### Eloss of Beam mom
	  double beamtof, momout;
	  double z_pos = -120;
	  ELossTools::CalcElossBeamTGeo(bpctrack->GetPosatZ(z_pos), vtxreac[ip],
					L3_beambf.Vect().Mag(), kpMass, momout, beamtof);
	  
	  L3_beam.SetVectM(momout*L3_beambf.Vect().Unit(), kpMass);
	      
	  TVector3 boost = (L3_target+L3_beam).BoostVector();
	  L3_beamCM = L3_beam;
	  L3_targetCM = L3_target;
	  L3_targetPCM = L3_targetP;
	  L3_beamCM.Boost(-1*boost);
	  L3_targetCM.Boost(-1*boost);
	  L3_targetPCM.Boost(-1*boost);

	  mm_ppipi[ip] = (L3_target+L3_beam-tL_p1-tL_pi-tL_p2).M();
	} // for( int npi=0; npi<(int)pim_ID.size(); npi++ ){
      } // for( int ip=0; ip<(int)p_ID.size(); ip++ ){


      //### Vertex check
      TF1 *f_dca = new TF1("f_dca", "[0]*exp([1]*x)+[2]*exp([3]*(x-[4])**[5])");
      TF1 *f_imL = new TF1("f_imL", "gaus(0)");
      f_imL->SetParameters(1,1.1158, 0.0019);
      double dcaparam_L[5][6] = {
	//### hx mcdca_ppi_Lpn
	{0.0111829,  -0.386551,  1.86103,  -1.65383,  -0.488821,  1.50069},  
	//### hx mcdca_L_Lpn
	{1.38649,  -6.8509,  -31683.6,  -25.5,  -3.52,  21.9},  
	//### hx mcdca_p_Lpn
	{1.43316,  -8.27214,  -31500.1,  -25.5,  -5.1463,  21.9},  
	//### hx mcdca_Lp_Lpn
	{2.79166,  -2.44547,  -7.82249,  -6.82579,  -0.225766,  1.29841},  
	//### hx mcdca_sum_Lpn
	{5.82406,  -1.5735,  -8.50142,  -0.542443,  -0.89754,  2.91009},  
      };

      double probsum_sin[2] = {99, 99};
      double probsum_imsin[2] = {99, 99};
      double prob_L[2][5] = {};
      double prob_ML[2] = {};

      //### Vertex check
      for( int ip=0; ip<2; ip++ ){ //for cut
	dca_sum[ip] = dca_ppi[ip]+dca_L[ip]+dca_p[ip]+dca_Lp[ip];
	prob_ML[ip] = f_imL->Eval(im_ppi[ip]);
	for( int id=0; id<5; id++ ){
	  f_dca->SetParameters(dcaparam_L[id][0], dcaparam_L[id][1], dcaparam_L[id][2],
			       dcaparam_L[id][3], dcaparam_L[id][4], dcaparam_L[id][5]);
	  double dcatmp = 0;
	  if( id==0 )      dcatmp = dca_ppi[ip];
	  else if( id==1 ) dcatmp = dca_L[ip];
	  else if( id==2 ) dcatmp = dca_p[ip];
	  else if( id==3 ) dcatmp = dca_Lp[ip];
	  else if( id==4 ) dcatmp = dca_sum[ip];

	  prob_L[ip][id] = f_dca->Eval(dcatmp);
	}

	probsum_sin[ip] = 1;
	for( int id=0; id<4; id++ ) probsum_sin[ip] *= prob_L[ip][id];

	probsum_imsin[ip] = 1;
	for( int id=0; id<4; id++ ) probsum_imsin[ip] *= prob_L[ip][id];

	probsum_imsin[ip] *= prob_ML[ip];

	if( isnan(probsum_sin[ip]) )   probsum_sin[ip] = 0;
	if( isnan(probsum_imsin[ip]) ) probsum_imsin[ip] = 0;
      }

      double logprob[2];
      if( probsum_imsin[0]<1e-50 ) logprob[0] = 50-1;
      else   logprob[0] = -1*log10(probsum_imsin[0]);

      if( probsum_imsin[1]<1e-50 ) logprob[1] = 50-1;
      else   logprob[1] = -1*log10(probsum_imsin[1]);

      double woimlogprob[2];
      if( probsum_sin[0]<1e-50 ) woimlogprob[0] = 50-1;
      else   woimlogprob[0] = -1*log10(probsum_sin[0]);

      if( probsum_sin[1]<1e-50 ) woimlogprob[1] = 50-1;
      else   woimlogprob[1] = -1*log10(probsum_sin[1]);
      
      if( probsum_imsin[0]>probsum_imsin[1] ) npL = 0;
      else npL = 1;

      // does not work...
      //if( logprob[npL]<2.5 ){	  
      //vtxRTree->Fill(); 
      //}

      Tools::Fill1D("MM_pppim", mm_ppipi[npL]);

      //if( !RinFid[npL] ) npL = -1; <--- bug

      if( RinFid[npL] ){
	tlogprob1 = logprob[npL];
	tlogprob2 = logprob[1-npL];
	twoimprob1 = woimlogprob[npL];
	twoimprob2 = woimlogprob[1-npL];
      }


      bool flagbprob = true;
      if( logprob[0]>2.5 && logprob[1]>2.5 ){
	flagbprob = false;
      }

      if( !RinFid[npL] ) flagbprob = false;

      // does not work...
      //if( (logprob[0]<5 || logprob[1]<5) && npL!=-1 ){
      //evTree->Fill();
      //}

      //### after defining  pi-p pair of  Lambda.
      for( int n=0; n<2; n++ ){
	if( n!=npL ){ continue; }
	
	CDSTrack *track_pL  = cdstrackMan->Track(p_ID[npL]);
	CDSTrack *track_p   = cdstrackMan->Track(p_ID[1-npL]);
	CDSTrack *track_piL = cdstrackMan->Track(pim_ID[0]);
	
	TVector3 P_pL, P_piL, P_p;
	if( !track_pL->GetMomentum(vtx_pL[npL], P_pL ,true, true) ){
	  std::cout<<"cP pL lpn!!"<<std::endl;
	  continue;
	}
	if( !track_piL->GetMomentum(vtx_piL[npL], P_piL, true, true) ){
	  std::cout<<"cP piL lpn!!"<<std::endl;
	  continue;
	}
	if( !track_p->GetMomentum(vtx_p[npL], P_p, true, true) ){
	  std::cout<<"cP p lpn!!"<<std::endl;
	  continue;
	}
	
	vtx_react = (vtx_p[npL]+vtx_L[npL])*0.5;
	L_pL.SetVectM(P_pL, pMass);
	L_piL.SetVectM(P_piL, piMass);
	L_p.SetVectM(P_p, pMass);
	
	//### Eloss of Beam mom
	double beamtof, momout;
	double z_pos = -120;
	ELossTools::CalcElossBeamTGeo(bpctrack->GetPosatZ(z_pos), vtx_react, L3_beambf.Vect().Mag(),
				      kpMass, momout, beamtof);
	
	L3_beam.SetVectM(momout*L3_beambf.Vect().Unit(), kpMass);
	tL_K = L3_beam;
	TVector3 boost = (L3_target+L3_beam).BoostVector();
	L3_beamCM = L3_beam;
	L3_targetCM = L3_target;
	L3_targetPCM = L3_targetP;
	L3_beamCM.Boost(-1*boost);
	L3_targetCM.Boost(-1*boost);
	L3_targetPCM.Boost(-1*boost);
	
	double mm_lp = (L3_target+L3_beam-L_pL-L_piL-L_p).M();
	TVector3 P_missn = (L3_target+L3_beam-L_pL-L_piL-L_p).Vect();
	L_L = (L_pL+L_piL);
	
	TLorentzVector L_Llab, L_plab, L_nlab;
	L_Llab = L_L;
	L_plab = L_p;
	tL_L = L_L;
	tL_p = L_p;
	
	TVector3 boost1 = (L3_target+L3_beam).BoostVector();	    
	L_L.Boost(-1*boost1);
	L_p.Boost(-1*boost1);
	double cosOAlp = L_L.Vect().Dot(L_p.Vect())/L_L.Vect().Mag()/L_p.Vect().Mag();
	double cosL = L_L.Vect().Dot(L3_beamCM.Vect())/L_L.Vect().Mag()/L3_beamCM.Vect().Mag();
	double cosp = L_p.Vect().Dot(L3_beamCM.Vect())/L_p.Vect().Mag()/L3_beamCM.Vect().Mag();
	double coslabL = L_Llab.Vect().Dot(L3_beam.Vect())/L_Llab.Vect().Mag()/L3_beam.Vect().Mag();
	double coslabp = L_plab.Vect().Dot(L3_beam.Vect())/L_plab.Vect().Mag()/L3_beam.Vect().Mag();
	
	L_n.SetVectM(P_missn, nMass);
	L_nlab = L_n;
	tL_n = L_n;
	
	//### Daliz plot
	L_n.Boost(-1*boost1);
	double Tp = L_p.E()-pMass;
	double TL = L_L.E()-lMass;
	double Tn = L_n.E()-nMass;
	double tQ = (L3_beamCM+L3_targetCM).M()-lMass-pMass-nMass;
	
	double cosOAln = L_L.Vect().Dot(L_n.Vect())/L_L.Vect().Mag()/L_n.Vect().Mag();
	double cosOApn = L_p.Vect().Dot(L_n.Vect())/L_p.Vect().Mag()/L_n.Vect().Mag();
	double cosn = L_n.Vect().Dot(L3_beamCM.Vect())/L_n.Vect().Mag()/L3_beamCM.Vect().Mag();
	double coslabn = L_nlab.Vect().Dot(L3_beam.Vect())/L_nlab.Vect().Mag()/L3_beam.Vect().Mag();
	double qtransn = (L_nlab.Vect()- L3_beam.Vect()).Mag();
	
	//### Kpp Flame
	TVector3 boost_kpp = (L_Llab+L_plab).BoostVector();	    
	TLorentzVector L_Lkpp = L_Llab;
	TLorentzVector L_pkpp = L_plab;
	TLorentzVector L_kpp = (L_Llab+L_plab);
	L_Lkpp.Boost(-1*boost_kpp);
	L_pkpp.Boost(-1*boost_kpp);
	
	double cosLkpp = L_Lkpp.Vect().Dot(L_kpp.Vect())/L_Lkpp.Vect().Mag()/L_kpp.Vect().Mag();
	double cospkpp = L_pkpp.Vect().Dot(L_kpp.Vect())/L_pkpp.Vect().Mag()/L_kpp.Vect().Mag();

	if( !flagbprob ){
	  nAbort_flagbprob++;
	}
	
	//### fill histograms
	if( flagbprob ){
	  nEvent_Lp++;
	  
	  Tools::Fill1D("logprobim_Lpn", -log10(prob_ML[n]));
	  Tools::Fill2D("nIM_Mm_Lp", (L_L+L_p).M(), mm_lp);
	  Tools::Fill1D("ncosL_Lp", cosL);
	  Tools::Fill1D("ncosp_Lp", cosp);	      
	  Tools::Fill1D("ncoslabL_Lp", coslabL);
	  Tools::Fill1D("ncoslabp_Lp", coslabp);	      
	  Tools::Fill1D("nmomL_Lp", L_L.Vect().Mag());
	  Tools::Fill1D("nmomp_Lp", L_p.Vect().Mag());
	  Tools::Fill1D("ncosOA_Lp", cosOAlp);
	  
	  //### select missing-n
	  if( mm_lp>0.84 && mm_lp<1.04 ){
	    nEvent_Lpn++;  
	    
	    Tools::Fill1D("logprobim_sum_Lpn", logprob[npL]);
	    Tools::Fill1D("nIM_Lp_Lpn", (L_L+L_p).M());
	    Tools::Fill1D("nIM_Ln_Lpn", (L_L+L_n).M());		  
	    Tools::Fill1D("nOAlp_Lpn", cosOAlp);
	    Tools::Fill1D("nOAln_Lpn", cosOAln);
	    Tools::Fill1D("nOApn_Lpn", cosOApn);
	    Tools::Fill1D("ncosL_Lpn", cosL);
	    Tools::Fill1D("ncosp_Lpn", cosp);
	    Tools::Fill1D("ncosn_Lpn", cosn);
	    
	    Tools::Fill1D("ncoslabL_Lpn", coslabL);
	    Tools::Fill1D("ncoslabp_Lpn", coslabp);
	    Tools::Fill1D("ncoslabn_Lpn", coslabn);
	    
	    Tools::Fill1D("ncosLkpp", cosLkpp);		  
	    Tools::Fill1D("ncospkpp", cospkpp);		  
	    
	    Tools::Fill1D("nmomL_Lpn", L_L.Vect().Mag());
	    Tools::Fill1D("nmomp_Lpn", L_p.Vect().Mag());
	    Tools::Fill1D("nmomn_Lpn", L_n.Vect().Mag());		  
	    
	    Tools::Fill2D("nIM_Mm_Lpn", (L_L+L_p).M(), mm_lp);
	    Tools::Fill2D("nIM_OAlp_Lpn", (L_L+L_p).M(), cosOAlp);
	    Tools::Fill2D("nIM_OAln_Lpn", (L_L+L_p).M(), cosOAln);
	    Tools::Fill2D("nIM_OApn_Lpn", (L_L+L_p).M(), cosOApn);
	    Tools::Fill2D("nIM_cosL_Lpn", (L_L+L_p).M(), cosL);
	    Tools::Fill2D("nIM_cosp_Lpn", (L_L+L_p).M(), cosp);
	    Tools::Fill2D("nIM_cosn_Lpn", (L_L+L_p).M(), cosn);
	    Tools::Fill2D("nIM_coslabL_Lpn", (L_L+L_p).M(), coslabL);
	    Tools::Fill2D("nIM_coslabp_Lpn", (L_L+L_p).M(), coslabp);
	    Tools::Fill2D("nIM_coslabn_Lpn", (L_L+L_p).M(), coslabn);
	    
	    Tools::Fill2D("nIM_qtransn_Lpn", (L_L+L_p).M(), qtransn);
	    
	    Tools::Fill2D("nIM_momL_Lpn", (L_L+L_p).M(), L_L.Vect().Mag());
	    Tools::Fill2D("nIM_momp_Lpn", (L_L+L_p).M(), L_p.Vect().Mag());
	    Tools::Fill2D("nIM_momn_Lpn", (L_L+L_p).M(), L_n.Vect().Mag());
	    
	    Tools::Fill1D("nmomL_Lpn_lab", L_Llab.Vect().Mag());
	    Tools::Fill1D("nmomp_Lpn_lab", L_plab.Vect().Mag());
	    Tools::Fill1D("nmomn_Lpn_lab", L_nlab.Vect().Mag());		  
	    
	    Tools::Fill2D("ndalitz_Lpn", (Tp-Tn)/sqrt(3)/tQ,TL/tQ );
	    Tools::Fill2D("ndalitz2_Lpn", (Tp-TL)/sqrt(3)/tQ,Tn/tQ );
	    Tools::Fill2D("ndalitzIM_Lpn", pow((L_L+L_p).M(),2), pow((L_L+L_n).M(),2));
	    Tools::Fill2D("nIM_Tn_Lpn", (L_L+L_p).M(), Tn);


	    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	    // %%% Kinematical Fit using KinFitter %%% //
	    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	    //--- set TLorentzVector ---//
	    // beam_K(K+), L, n, p, p from L, pi- from L
	    //  = TLorentzVector L3_beam, L_Llab, L_nlab, L_plab, L_pL, L_piL
	    TLorentzVector TL_meas[6]; // measured
	    TLorentzVector TL_kfit[6]; // kinematical fitted
	    TL_meas[0] = L3_beam;
	    TL_meas[1] = L_pL+L_piL; //L_Llab;
	    TL_meas[2] = (L3_target+L3_beam)-(L_plab+L_pL+L_piL); //L_nlab;
	    TL_meas[3] = L_plab;
	    TL_meas[4] = L_pL;
	    TL_meas[5] = L_piL;
	    // L3_target is defined as (0, 0, 0, M_3He)
	    TVector3 TV_target = L3_target.Vect();
	    TVector3 TV_meas[6];
	    for( int i=0; i<6; i++ ){
	      TV_meas[i] = TL_meas[i].Vect();
	    }

	    //--- for the covariance matrix evaluation ---//
	    for( int i=0; i<6; i++ ){
	      for( int j=0; j<4; j++ ){
		for( int k=0; k<4; k++ ){
		  double val = (TL_meas[i][j] - TL_gene[i][j]) * (TL_meas[i][k] - TL_gene[i][k]);
		  if( j==k && (TL_meas[i][j] - TL_gene[i][j])<0 ) val *= -1;
		  Tools::Fill1D(Form("cov_%d_%d_%d", i, j, k), val);
		}
	      }
	    } // for( int i=0; i<6; i++ ){

	    //--- KinFitter :: initialization ---//
	    //*** definition of fit particles in cartesian coordinates ***//
	    TString str_particle[6] = {"L3_beam", "L_Llab", "L_nlab", "L_plab", "L_pL", "L_piL"};
	    TFitParticlePxPyPz ParticleTgt = TFitParticlePxPyPz("target", "target", &TV_target,
								pdg->GetParticle("He3")->Mass(), covZero);
	    TFitParticlePxPyPz Particle[6];
	    for( int i=0; i<6; i++ ){
	      Particle[i] = TFitParticlePxPyPz(str_particle[i], str_particle[i], &TV_meas[i],
					       pdg->GetParticle(PDG[i])->Mass(), covParticle[i]);
	    }
	    //*** definition of constraints ***//
	    // constraint :: mass of Lambda
	    TFitConstraintM ConstML = TFitConstraintM("M_L", "M_L", 0, 0, pdg->GetParticle(PDG[1])->Mass());
	    ConstML.addParticles1(&Particle[4], &Particle[5]);
	    // constraint :: 4-momentum conservation
            TFitConstraintEp ConstEp[4];
	    TString str_constEp[4]  = {"Px", "Py", "Pz", "E"};
            for( int i=0; i<4; i++ ){
              ConstEp[i] = TFitConstraintEp(str_constEp[i], str_constEp[i], 0, TFitConstraintEp::component(i), 0);
              ConstEp[i].addParticles1(&ParticleTgt, &Particle[0]);
              ConstEp[i].addParticles2(&Particle[2], &Particle[3], &Particle[4], &Particle[5]);
            }

	    //--- KinFitter :: execution ---//
	    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	    // Naively,
	    //  measured values are momenta (3-vectors) of K-, p, p, pi- -> 3*4=12 
	    //  constraints for kinematical fit are masses of lambda and missing-neutron -> 1*2=2
	    //    where energy and momentum of missing-neutron is obtained from 4-momentum conservation of K- 3He -> L p n
	    //   => number of parameters is 12-2=10
	    //   => DOF is 12-10=2
	    //
	    // In the kinematical fit routine, KinFitter,
	    //  fitting values are momenta (3-vectors) of K-, p, p, pi-, n -> 3*5=15
	    //    where mass of neutron is fixed to the PDG value
	    //  constraints for kinematical fit are mass of lambda and 4-momentum conservation -> 1+4=5
	    //   => number of parameters is 15-5=10
	    //  measured values are momenta (3-vectors) of K-, p, p, pi- -> 3*4=12 
	    //   => DOF is 12-10=2
	    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	    //*** definition of the fitter ***//
	    TKinFitter kinfitter;
	    // add measured particles
	    kinfitter.addMeasParticles(&Particle[0], &Particle[3], &Particle[4], &Particle[5]); // K, p, p, pi-
	    kinfitter.addUnmeasParticles(&Particle[2]); // n
	    // add constraints
	    kinfitter.addConstraint(&ConstML); // mass of Lambda
	    for( int i=0; i<4; i++ ){
              kinfitter.addConstraint(&ConstEp[i]); // 4-momentum conservation
            }
	    //*** perform the fit ***//
	    kinfitter.setMaxNbIter(50);       // max number of iterations
	    kinfitter.setMaxDeltaS(5e-5);     // max delta chi2
	    kinfitter.setMaxF(1e-4);          // max sum of constraints
	    kinfitter.setVerbosity(KFDEBUG);  // verbosity level
	    kinfitter.fit();
	    //*** copy fit results ***//
	    for( int i=0; i<6; i++ ){
	      TL_kfit[i] = (*Particle[i].getCurr4Vec());
	    }
	    TL_kfit[1] = TL_kfit[4]+TL_kfit[5];
	    
	    //--- fill the results ---//
	    for( int i=0; i<6; i++ ){
	      double p_gene = TL_gene[i].P();
	      double p_meas = TL_meas[i].P();
	      double p_kfit = TL_kfit[i].P();
	      Tools::Fill1D(Form("p_gene_%d", i), p_gene);
	      Tools::Fill1D(Form("p_meas_%d", i), p_meas);
	      Tools::Fill1D(Form("p_kfit_%d", i), p_kfit);
	      Tools::Fill1D(Form("p_meas_gene_%d", i), p_meas-p_gene);
	      Tools::Fill1D(Form("p_kfit_gene_%d", i), p_kfit-p_gene);
	      Tools::Fill1D(Form("p_meas_kfit_%d", i), p_meas-p_kfit);
	      Tools::Fill1D(Form("p_per_meas_gene_%d", i), (p_meas-p_gene)/p_gene*100);
	      Tools::Fill1D(Form("p_per_kfit_gene_%d", i), (p_kfit-p_gene)/p_gene*100);
	      Tools::Fill1D(Form("p_per_meas_kfit_%d", i), (p_meas-p_kfit)/p_gene*100);
	    }
	    double m_gene = (TL_gene[1]+TL_gene[3]).Mag();
 	    double m_meas = (TL_meas[1]+TL_meas[3]).Mag();
	    double m_kfit = (TL_kfit[1]+TL_kfit[3]).Mag();
	    Tools::Fill1D("IM_Lp_gene", m_gene);
	    Tools::Fill1D("IM_Lp_meas", m_meas);
	    Tools::Fill1D("IM_Lp_kfit", m_kfit);
	    Tools::Fill1D("IM_Lp_meas_gene", m_meas-m_gene);
	    Tools::Fill1D("IM_Lp_kfit_gene", m_kfit-m_gene);
	    Tools::Fill1D("IM_Lp_meas_kfit", m_meas-m_kfit);
	    Tools::Fill1D("IM_per_Lp_meas_gene", (m_meas-m_gene)/m_gene*100);
	    Tools::Fill1D("IM_per_Lp_kfit_gene", (m_kfit-m_gene)/m_gene*100);
	    Tools::Fill1D("IM_per_Lp_meas_kfit", (m_meas-m_kfit)/m_gene*100);
	    Tools::Fill1D("Lpn_kfit_chi2", kinfitter.getS());
	    Tools::Fill1D("Lpn_kfit_DOF", kinfitter.getNDF());
	    Tools::Fill1D("Lpn_kfit_rchi2", kinfitter.getS()/kinfitter.getNDF());
	    
	    TVector3 kfit_boost = TL_kfit[1].BoostVector(); // CM @ L
	    TLorentzVector TL_kfit_CM[6]; // kinematical fitted at CM
	    for( int i=0; i<6; i++ ){
	      TL_kfit_CM[i] = TL_kfit[i];
	      TL_kfit_CM[i].Boost(-1*kfit_boost);
	    }
	    TVector3 n_cross_K_kfit = TL_kfit_CM[2].Vect().Cross(TL_kfit_CM[0].Vect()); // n x K-
	    double costheta_nK_pL_kfit = cos(n_cross_K_kfit.Angle(TL_kfit_CM[4].Vect())); // angle btw (n x K-) and (p from Lambda)
	    Tools::Fill1D("Lpn_kfit_costheta_nK_pL", costheta_nK_pL_kfit);
	    
	    //--- debug ---//
#if KFDEBUG
	    cerr<<"fitting status = "<<kinfitter.getStatus()<<endl;
	    cerr<<"# of iteration = "<<kinfitter.getNbIter()<<endl;
	    cerr<<"chi2/NDF       = "<<kinfitter.getS()<<"/"<<kinfitter.getNDF()<<" = "<<kinfitter.getS()/kinfitter.getNDF()<<endl;
	    cerr<<endl;
	    cerr<<"=== generated ==="<<endl;
	    for( int i=0; i<6; i++ ){
	      TL_gene[i].Print();
	      cerr<<TL_gene[i].Mag()<<endl;;
	    }
	    cerr<<"=== measured ==="<<endl;
	    for( int i=0; i<6; i++ ){
	      TL_meas[i].Print();
	      cerr<<TL_meas[i].Mag()<<endl;;
	    }
	    cerr<<"=== fitted ==="<<endl;
	    for( int i=0; i<6; i++ ){
	      TL_kfit[i].Print();
	      cerr<<TL_kfit[i].Mag()<<endl;;
	    }
	    cerr<<"*** Lp mass ***"<<endl;
	    cerr<<m_gene<<" "<<m_meas<<" "<<m_kfit<<endl;
	    cerr<<(m_meas-m_gene)/m_gene*100<<" "<<(m_kfit-m_gene)/m_gene*100<<" "<<(m_meas-m_kfit)/m_gene*100<<" %"<<endl;
	    getchar();
#endif    
	    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	    // %%% Kinematical Fit Study    %%% //
	    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //


	  } //missing neutron  
	} // if( flagbprob ){
      } // for( int n=0; n<2; n++ ){
    } // if( flagbmom && p_ID.size()==2 && pim_ID.size()==1 && cdstrackMan->nGoodTrack()==3 && !chargedhit ){

  } // for( int ev=0; ev<exen; ev++ ){
  
  cout<<"===== Lambda p n reconstruction in MC END ====="<<endl;
  cout<<" nEvent       = "<<exen<<endl;
  cout<<" nEvent_Lp    = "<<nEvent_Lp<<endl;
  cout<<" nEvent_Lpn   = "<<nEvent_Lpn<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nG4Event_Lp  = "<<nG4Event_Lp<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" AllGoodTrack = "<<AllGoodTrack<<endl;
  cout<<" nTrack       = "<<nTrack<<endl;
  cout<<" nTrack_PID   = "<<nTrack_PID<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nAbort_nGoodTrack = "<<nAbort_nGoodTrack<<endl;
  cout<<" nAbort_numT0      = "<<nAbort_numT0<<endl;
  cout<<" nAbort_nbpc       = "<<nAbort_nbpc<<endl;
  cout<<" nAbort_bpctrack   = "<<nAbort_bpctrack<<endl;
  cout<<" nAbort_nblc2      = "<<nAbort_nblc2<<endl;
  cout<<" nAbort_fblc2bpc   = "<<nAbort_fblc2bpc<<endl;
  cout<<" nAbort_flagbmom   = "<<nAbort_flagbmom<<endl;
  cout<<" nAbort_ftarget    = "<<nAbort_ftarget<<endl;
  cout<<" nAbort_pppim      = "<<nAbort_pppim<<endl;
  cout<<" nAbort_chargeveto = "<<nAbort_chargeveto<<endl;
  cout<<" nAbort_flagbprob  = "<<nAbort_flagbprob<<endl;
  cout<<" nAbort total      = "<<nAbort_nGoodTrack+nAbort_numT0+nAbort_nbpc+nAbort_bpctrack+nAbort_nblc2+nAbort_fblc2bpc+nAbort_flagbmom+nAbort_ftarget+nAbort_pppim+nAbort_chargeveto+nAbort_flagbprob<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<endl;
  cout<<"==============================================="<<endl;

  outfile->Write();
  outfile->Close();

  simfile->Close();
  cdcfile->Close();

  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}
