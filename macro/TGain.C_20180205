//asano memo
//macro for TDC calibration
//input : root files generated by evanatko, interval of calibrator, 
//output : parameter files for TDC gain
//1. tmpbl.param 
//2. tmpcds.param

#include <TString.h>
#include <TSystem.h>
#include <TROOT.h>
#include <TFile.h>
#include <TH1.h>
#include <TF1.h>
#include <TCanvas.h>
#include <TGraph.h>
#include <TGraphErrors.h>
#include <TLine.h>

#include <cstdlib>


TString pdfname="tgain.pdf";
const double interval=10.;//nsec
const int nominalentry=10000;
class ConfMan;
class CounterMapMan;


void TGain(){
  /*** load library ***/
  gSystem->Load("lib/libAll.so");
  gROOT->SetBatch(kTRUE);
  /*
  if(0){
    int confnum[]={60,65,71,76,81,86,91,100,106,110,115,120,125,130,135,139,145,151,155};
    int nconf=sizeof(confnum)/sizeof(int);
    for(int i=3;i<nconf;i++){
      TGainRun49cprechamber(Form("conf/Run49c/20130618/analyzer%d.conf",confnum[i]),"pass1","pass2");
    }
  }*/
  TGainRun78();
  //TGainRun78chamber();
  
}

//void Calc 
//
//inputs:
//filename generated from evanaraw, ConfMan,crate number,slot number, interval of calibrator, initial channel
//outputs:
//TDC gain, a*T+b 
//results are stored by GainMapManager, which is handled by ConfMan
void Calc(TFile *f,ConfMan *conf,int cr,int sl, double interval=10.,int init=0, bool POL2=false)
{
  TH1F *h1;
  TGraphErrors *gra;
  TGraphErrors *gra2;
  TLine line; line.SetLineColor(2);
  int npeak;
  double peakpos[100]; // position of peaks (rough, before fit)
  double fitmean[100]; // position of peaks (by fit)
  double fitsigma[100]; // sigma of peaks (by fit)
  double tdiff[100];
  double linearity[100];
  double linsigma[100];
  for( int i=0; i<100; i++ ) tdiff[i] = interval*i; // time calibrator was set to period=10nsec.

  TCanvas *c1 = new TCanvas( "c1", "TKO entry", 1000, 1000 );
  c1->Divide(4,4);
  TCanvas *c2 = new TCanvas( "c2", "gaus fit results", 1000, 1000 );
  c2->Divide(4,4);
  TCanvas *c3 = new TCanvas( "c3", "diff", 1000, 1000 );
  c3->Divide(4,4);

  for( int tmpch=0; tmpch<16; tmpch++ ){
    npeak = 0;
    int ch=tmpch+init;
    c1->cd( tmpch+1 );
    h1 = 0;
    h1 = (TH1F*)f->Get( Form( "TKOc%dn%da%d", cr,sl,ch) );  
    h1->SetXTitle("TDC ch.");
    if(h1==0){ std::cout << " can not find histogram !!!  " << cr <<" "<<sl<<" "<<ch<<std::endl; continue; } // just check
    if(h1->Integral(h1->FindBin(10),h1->FindBin(4000))<200) { std::cout << "L. " << __LINE__ << "  number of entry is too small !!!" << cr <<" "<<sl<<" "<<ch<<std::endl; continue; } 
    h1->Draw();
    int nbinx = h1->GetNbinsX();
    for( int i=h1->FindBin(300); i<h1->FindBin(4000); i++ ){ // search peak positions roughly (both edge of histogram are avoided)
      int content = h1->GetBinContent(i);
      if( 200<content ){ // at peak, content should be large enough.
	peakpos[npeak] = h1->GetBinCenter(i);
	line.DrawLine( peakpos[npeak], 0, peakpos[npeak], h1->GetMaximum() );
	npeak++;
	i += 20; // peak width is maybe smaller than 20 bins, and distance between peaks are maybe larger than 20bins.
      }
    }
    if(npeak<5) { std::cout << "# of peak is less than 5 !!! " << cr <<" "<<sl<<" "<<ch<<std::endl; continue; }
    for( int i=0; i<npeak; i++ ){ // fit each peak
      h1->Fit( "gaus","L0q","", peakpos[i]-10., peakpos[i]+10. );
      fitmean[i] = h1->GetFunction( "gaus" )->GetParameter(1);
      //fitsigma[i]= h1->GetFunction( "gaus" )->GetParameter(2);
      fitsigma[i]= h1->GetFunction( "gaus" )->GetParError(1);
    }
    
    c2->cd( tmpch+1 );
    gra = new TGraphErrors( npeak-1 , fitmean, tdiff, fitsigma, 0 );
    gra->SetTitle(Form( "TKOc%dn%da%d", cr,sl,ch ));
    TString func="pol1";
    gra->Fit( "pol1" ,"q"); // linear fit
    if(POL2){
      func="pol2";      
      TF1 f2(func,func,0,4000);
      double par[3];
      gra->GetFunction("pol1")->GetParameters(par);
      par[2]=0.;
      f2.SetParameters(par);
      gra->Fit( &f2 ,"q"); // linear fit
    }
    gra->SetLineStyle(2);
    gra->SetMarkerStyle(20);
    gra->GetXaxis()->SetTitle("fit mean [nsec]");
    gra->GetYaxis()->SetTitle("actual time [nsec]");
    gra->Draw("alpw");

    c3->cd( tmpch+1 );    
    TF1* f1=gra->GetFunction(func);
    f1->SetLineColor(2);
    f1->Draw("same");

    for( int i=0; i<npeak; i++ ){ // fit each peak
      linearity[i]=f1->Eval(fitmean[i])-tdiff[i];
      linsigma[i]=f1->Eval(fitmean[i]+fitsigma[i])-f1->Eval(fitmean[i]);
    }
    gra2 = new TGraphErrors( npeak-1 , fitmean, linearity, 0, linsigma );
    gra2->SetTitle(Form( "TKOc%dn%da%d", cr,sl,ch ));
    gra2->SetLineStyle(2);
    gra2->SetMarkerStyle(20);
    gra2->GetXaxis()->SetTitle("fit mean [nsec]");
    gra2->GetYaxis()->SetTitle("diff. (fit mean - actual time) [nsec]");
    gra2->Draw("alpw");

    double p1 = f1->GetParameter(1);
    double p2 = f1->GetParameter(2);
    double offs,temp1;
    conf->GetGainMapManager()->GetParam( cr,sl,ch, temp1, offs );
    conf->GetGainMapManager()->SetParam( cr,sl,ch, offs, p1, p2 ); // set a new parameter into map
    std::cout<<"cr,sl,ch,gain before->after\t"<<cr<<"\t"<<sl<<"\t"<<ch<<"\t"<<p1<<" <- "<<temp1<<std::endl;
  }  
  std::string picname = Form("TDCCalib/tcalrun78_peakfit_cr%dsl%d.png",cr,sl);
  c1->SaveAs(picname.c_str(),"PNG");
  std::string picname = Form("TDCCalib/tcalrun78_pol1fit_cr%dsl%d.png",cr,sl);
  c2->SaveAs(picname.c_str(),"PNG");
  std::string picname = Form("TDCCalib/tcalrun78_diff_cr%dsl%d.png",cr,sl);
  c3->SaveAs(picname.c_str(),"PNG");
  //c1->Print(pdfname);
  //c2->Print(pdfname);
  //c3->Print(pdfname);
}


void CalcChamber(TFile *f,ConfMan *conf,int cr,int sl, double interval=80,bool POL2=false)
{
  TH1F *h1;
  TGraphErrors *gra;
  TLine line; line.SetLineColor(2);
  int npeak=0;
  double peakpos[100]; // position of peaks (rough, before fit)
  double fitmean[100]; // position of peaks (by fit)
  double fitsigma[100]; // sigma of peaks (by fit)
  double tdiff[100];
  double linearity[100];
  double linsigma[100];
  for( int i=0; i<100; i++ ) tdiff[i] = interval*i; // time calibrator was set to period=10nsec.

  TCanvas *c1 = new TCanvas( "c1", "TKO entry", 1000, 1000 );
  c1->Divide(4,4);
  TCanvas *c2 = new TCanvas( "c2", "gaus fit results", 1000, 1000 );
  c2->Divide(4,4);
  TCanvas *c3 = new TCanvas( "c3", "diff", 1000, 1000 );
  c3->Divide(4,4);
  int ipad=0;
  for( int ch=0; ch<=31; ch++ ){
    npeak = 0;
    ipad++;
    c1->cd( ipad );
    h1 = 0;
    h1 = (TH1F*)f->Get( Form( "TKOc%dn%da%d", cr,sl,ch ) );  
    if(h1==0){ std::cout << "can not find histogram !!! " << cr <<" "<<sl<<" "<<ch<<std::endl; continue; } // just check
    if(h1->GetEntries()<100) continue; 
    h1->SetXTitle("TDC ch.");
    h1->Draw();
    int nbinx = h1->GetNbinsX();
    for( int i=h1->FindBin(300); i<h1->FindBin(4000); i++ ){ // search peak positions roughly (both edge of histogram are avoided)
      int content = h1->GetBinContent(i);
      if( 100<content ){ // at peak, content should be large enough.
	peakpos[npeak] = h1->GetBinCenter(i);
	line.DrawLine( peakpos[npeak], 0, peakpos[npeak], h1->GetMaximum() );
	npeak++;
	i += 20; // peak width is maybe smaller than 20 bins, and distance between peaks are maybe larger than 20bins.
      }
    }
    if(npeak<5){ std::cout << " # of peak is less than 5 !!! " << cr <<" "<<sl<<" "<<ch<<std::endl; continue; }
    for( int i=0; i<npeak; i++ ){ // fit each peak
      h1->Fit( "gaus","L0q","", peakpos[i]-10., peakpos[i]+10. );
      fitmean[i] = h1->GetFunction( "gaus" )->GetParameter(1);
      //fitsigma[i]= h1->GetFunction( "gaus" )->GetParameter(2);
      fitsigma[i]= h1->GetFunction( "gaus" )->GetParError(1);
    }
    h1->GetXaxis()->SetRangeUser(peakpos[0]-100,peakpos[npeak-1]+100);
    
    c2->cd( ipad );
    gra = new TGraphErrors( npeak-1, fitmean, tdiff, fitsigma, 0 );
    gra->SetTitle(Form( "TKOc%dn%da%d", cr,sl,ch ));
    gra->GetXaxis()->SetTitle("fit mean [nsec]");
    gra->GetYaxis()->SetTitle("actual time [nsec]");
    TString func="pol1";
    gra->Fit( "pol1" ,"q"); // linear fit
    if(POL2){
      func="pol2";
      TF1 f2(func,func,0,4000);
      double par[3];
      gra->GetFunction("pol1")->GetParameters(par);
      par[2]=0.;
      f2.SetParameters(par);
      gra->Fit( &f2 ,"q"); // linear fit
    }
    gra->Draw("alpw");
    double offs,temp1;
    //    double gain = -1./func->GetParameter(1);

    c3->cd( ipad );    
    TF1* f1=gra->GetFunction(func);
    f1->SetLineColor(2);
    f1->Draw("same");

    for( int i=0; i<npeak; i++ ){ // fit each peak
      linearity[i]=f1->Eval(fitmean[i])-tdiff[i];
      linsigma[i]=f1->Eval(fitmean[i]+fitsigma[i])-f1->Eval(fitmean[i]);
    }

    gra2 = new TGraphErrors( npeak-1 , fitmean, linearity, 0, linsigma );
    gra2->SetTitle(Form( "TKOc%dn%da%d", cr,sl,ch ));
    gra2->SetLineStyle(2);
    gra2->SetMarkerStyle(20);
    gra2->GetXaxis()->SetTitle("fit mean [nsec]");
    gra2->GetYaxis()->SetTitle("diff. (fit mean - actual time) [nsec]");
    gra2->Draw("alpw");


    double p1 =-f1->GetParameter(1);
    double p2 =-f1->GetParameter(2);
    if(cr==0||(cr==1&&sl>8&&sl<17)){
      p1*=-1;
      p2*=-1;
    }
    double offs,temp1;
    conf->GetGainMapManager()->GetParam( cr,sl,ch, temp1, offs );
    conf->GetGainMapManager()->SetParam( cr,sl,ch, offs, p1, p2 ); // set a new parameter into map
    std::cout<<"cr,sl,ch,gain before -> after"<<cr<<"\t"<<sl<<"\t"<<ch<<"\t"<<temp1<<" -> "<<p1<<std::endl;
    if(ch==15||ch==31){
      ipad=0;
      std::string picname = Form("TDCCalib/tcalrun78_chm_peakfit_cr%dsl%dch%d_%d.png",cr,sl,ch-15,ch);
      //c1->Print(pdfname);
      c1->SaveAs(picname.c_str(),"PNG");
      std::string picname = Form("TDCCalib/tcalrun78_chm_pol1fit_cr%dsl%dch%d_%d.png",cr,sl,ch-15,ch);
      //c1->Print(pdfname);
      c2->SaveAs(picname.c_str(),"PNG");
      std::string picname = Form("TDCCalib/tcalrun78_chm_diff_cr%dsl%dch%d_%d.png",cr,sl,ch-15,ch);
      //c3->Print(pdfname);
      c3->SaveAs(picname.c_str(),"PNG");
    }
  }  
}

//Gain Calibration for counters' TDC and FDC's TDC
void TGainRun78(){
  ConfMan *conf = new ConfMan("conf/Run78/analyzer.conf",0);
  conf->Initialize();
  
  /*
  //counter's TDC
  {
    //runs taken in Jan. 15, 2018 
    int run[]={1, 2, 3, 4, 5, 6, 7, 8, 9,10,
              11,12,13,14,15,16,17,18,   
                ,32,33,34,35,36,38,39};//19, 37 junk

    const int nrun= (int) sizeof(run)/sizeof(int);
    std::cout << "# of runs for counter's TDCs: " <<  nrun << std::endl;
    const int ncr=2;//number of crates which simultaneously take data
    //crate number
    int cr[25][2]={
           {7,7},  {7,7},   {7,7},    {7,7},   {7,7},//run 1-5 
		       {8,8},  {8,8},   {8,8},    {8,8},   {8,8}, //6-10
		       {2,2},  {2,2},   {2,2},    {2,2},   {2,2}, //11-15
		       {2,6},  {6,6},   {6,6},                   //16-18 , 19 junk
		               {6,6},   {6,6},    {6,6},   {6,6}, //32-35
		       {6,6},           {10,10},  {10,10}           //36,38,39
    };
    //slot number
    int sl[25][2]={
           1,2,     4,5,     7,8,      9,11,     13,14, //run 1-5   
		       1,2,     4,5,     7,8,     10,11,     12,13,  //6-10
		       1,9,     2,3,     4,4,     11,12,	   13,14,  //11-15
		       7,5,     6,11,    8,9,                         //16-18, 19 junk
                   17,17,  18,18,     19,19,     20,20,    //32-35
           21,21,            2,4,       6,8              //36, 38,39
    };

    //period (nsec)
    int interval[25]={
      10,10,10,10,10, //run 1-5
			10,10,10,10,10, //6-10
			20,10,10,10,10, //11-15
			10,10,10,       //16-18, 19 junk
			  ,10,10,10,10, //32-35
			10,   10,10     //36, 38,39
    };
    
    //initial channel of inputs
    int init[25][2]={
       0,0, 0,0,  0,0, 0,0, 0,0, //run 1-5
			 0,0, 0,0,  0,0, 0,0, 0,0,  //6-10
			 0,0, 0,0,  0,0, 0,0, 0,0,  //11-15
			 0,0, 0,0,  0,0,            //16-18, 19 junk
			      0,16, 0,16, 0,16, 0,16,   //32-35
			 0,16,      0,16, 0,16         //36, 38,39
    };

    //pdfname=Form("tgain_counter_run78.pdf");
    //TCanvas *c1 = new TCanvas("gain","gain",600,600);
    //c1->Print(pdfname+"[");
    for(int irun=0;irun<nrun;irun++){
      //TFile *f=new TFile(Form("~/k18ana/root/run49cpre/tko%d.root",run[irun]));
      char fname[256];
      std::cout << fname  << std::endl;
      sprintf(fname, "/home/had/hiasano/ana/k18ana/tkoout/out%02d.root",run[irun]);
      TFile *f=new TFile(fname);
      if(f->IsOpen()==kFALSE){
        std::cout << "can not open file " << std::endl;
      }

      for(int icr=0;icr<ncr;icr++){
        Calc(f,conf,cr[irun][icr],sl[irun][icr],interval[irun],init[irun][icr],true);
      }
    }
    //c1=new TCanvas();
    //c1->Print(pdfname+"]");
  }//counter's TDC end
  
  
  // FDC's TDC
  {
    //pdfname=Form("tgain_run78_fdc1_pol1.pdf");
    int crfdc=9;
    int run[]={20,21,22,23,24,25,26,27,28,29,30,31};
    const int nrun=12;
    int slfdc[12]={9,12,13,14,
		  16,17,18,19,20,21,22,23};
    //TCanvas *c1=new TCanvas();
    //c1->Print(pdfname+"[");
    for(int irun=0;irun<nrun;irun++){
      char fname[256];
      std::cout << fname  << std::endl;
      sprintf(fname, "/home/had/hiasano/ana/k18ana/tkoout/out%02d.root",run[irun]);
      //TFile *f=new TFile(Form(""/home/had/hiasano/ana/k18ana/tkoout/out%02d.root",run[irun]));
      TFile *f=new TFile(fname);
      if(f->IsOpen()==kFALSE){
        std::cout << "can not open file " << std::endl;
      }
      //period : 40 nsec for FDC
      CalcChamber(f,conf,crfdc,slfdc[irun],40.,false);
    }
    //c1=new TCanvas();
    //c1->Print(pdfname+"]");
  }//FDC's TDC end
  */
  //other  chambers' TDC (BLC1,2 BPC, CDC)
  {
    int runchm=40;
    char fname[256];
    sprintf(fname, "/home/had/hiasano/ana/k18ana/tkoout/out%02d.root",runchm);
    std::cout << fname << std::endl;
    TFile *f=new TFile(fname);
    if(f->IsOpen()==kFALSE){
      std::cout << "can not open file " << std::endl;
    }
    //period : 40 nsec for BLC1,2, BPC and CDC
    int cr[7]   ={ 1, 0, 0, 1, 3, 4, 5};
    int slini[7]={18, 1, 7, 1, 1, 1, 1};
    int slend[7]={22, 4,22,16,20,20,20};
    for(int icr=0;icr<7;icr++){
      for(int isl=slini[icr];isl<slend[icr];isl++){
        if(cr[icr]==1 && isl==21) continue;
        CalcChamber(f,conf,cr[icr],isl,40.);
      }
    }
  }
  ofstream ofs("tmpbl.param");
  conf->GetGainMapManager()->PrintMapBL(ofs); // print map for BeamLine
  ofstream ofs2("tmpcds.param");
  conf->GetGainMapManager()->PrintMapCDS(ofs2); // print map for CDS
  ofs.close();
  ofs2.close();
}

