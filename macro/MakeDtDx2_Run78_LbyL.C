//H.Asano
//This is a macro to make X-T curve of drift chambers layer by layer from Run78 data, except for CDC 
//a function to make confirmation plots are added from the original macro.
//This macro requires libAll.so from k18ana.

//input : root files generated by EventAnalysisXT.cpp
//output : 1. a text files to give X-T curves of Drift chamebers, except for CDC. 
//         (optional) 2.a root file which contains drift time, drift length and differential of drift lengthdistribution. 
#include "TCanvas.h"
#include "TStyle.h"
#include "TH1.h"
#include "TGaxis.h"


//drift time 
TH1F *hdt[6][8][64];//detector, layer,wire
//drift length 
TH1F *hdx[6][8][64];//detector, layer,wire
//differential of drift length
TH1F *hxdiff[6][8][64];//detector, layer,wire

void MakeDtDx2_Run78_LbyL(int run_begin,
                          int run_end=0,
                          const bool IsDriftTimeCut=true)
{
  std::cout << "run range:  " << run_begin <<  " - " << run_end << std::endl;
  gSystem->Load("lib/libAll.so");
  ConfMan *conf = new ConfMan("conf/Run78/analyzer.conf",run_begin);
  conf->Initialize();
  
  gROOT->SetBatch();
  gStyle->SetPadGridX(1);
  gStyle->SetPadGridY(1);
  gStyle->SetPadTickX(0);
  gStyle->SetPadTickY(0);
  std::cout<<"start run: "<<run_begin<<std::endl;
  //percentage of integral of drift time distribution. 
  const double thre[]={0,0.3,2,5,10,17,25,32,
		 40,50,60,68,75,83,90,95,
		 98,99.7,100};
  
  int nthre=sizeof(thre)/sizeof(thre[0]);
  DetectorList *dlist=DetectorList::GetInstance();
  dlist->Initialize("param/Run78/Detectors.list");

  TFile *f[100];
  int nfile=run_end-run_begin+1;
  if(run_end==0) nfile=1;
  //open data
  int run_end_tmp = run_end;
  if(run_end==0) run_end_tmp = run_begin;
  for(int irun=run_begin;irun<=run_end_tmp;irun++){
    f[irun-run_begin]=new TFile(Form("/gpfs/group/had/knucl/e15/asano/Run78/evanaxt_%04d.root",irun),"READ");
    if(!f[irun-run_begin]->IsOpen()) return;
  }

  const Int_t cid[6]={CID_BLC1a,CID_BLC1b,CID_BLC2a,CID_BLC2b,CID_BPC,CID_FDC1};
  TTimeStamp *tm=new TTimeStamp();
  TString outdir=Form("XTMap_%d",tm->GetDate());
  gSystem->MakeDirectory(outdir.Data());
  gSystem->cd(outdir.Data());
  TString outname=Form("xt_%d_run%d_%d_LbyL.param",tm->GetDate(),run_begin,run_end);
  if( (run_begin==run_end) || (run_end==0)){
    outname=Form("xt_run%d.param",run_begin);
  }
  ofstream ofs(outname.Data());
  
  //need initialization here.
  //empty histogram from empty ch. can make crash.
  memset(hdt,0,sizeof(hdt));
  memset(hdx,0,sizeof(hdx));
  memset(hxdiff,0,sizeof(hxdiff));
  
  
  //maximum drift length BLC1,2, newBPC, FDC
  const double dlmax[6]={4.,4.,2.5,2.5,3.0,3.0};
  
  //hard cut determined after (roughly) tuning wire by wire offset 
  
  //v1 Apr.13,2018. FDC's cut is very conservative.
  const double dtmax[6]={180,180,120,120,180,300};
  
  for(int ic=0;ic<6;ic++){
    TH1F* hsum=NULL;
    char *name=dlist->GetName(cid[ic]).data();
    int nlayers=dlist->GetNlayers(cid[ic]);
    int nwires=dlist->GetNwires(cid[ic]);
    std::cout<<name<<"  "<<nlayers<<"  "<<nwires<<std::endl;
    ofs<<"XTParam: "<<cid[ic]<<"  "<<dlmax[ic]<<"  "<<nthre<<std::endl;
    ofs<<"Threshold: ";
    for(int i=0;i<nthre;i++){
      ofs<<thre[i]<<"  ";
    }
    ofs<<std::endl;
    for(int lay=1;lay<=nlayers;lay++){
        
      //drift time distribution with multiplicity cuts
      TString hname=Form("d%s_%d_all1hit",name,lay);
      if(cid[ic] == CID_FDC1){
        hname=Form("d%s_%d_BVC1_all1hit",name,lay);
      }
      //sum up histogram from each runs
      int nfound=0;
      for(int ifile=0;ifile<nfile;ifile++){
        TH1F* htemp = (TH1F*)f[ifile]->Get(hname.Data());
        if(htemp==0){
          cout << "can not find " <<  hname.Data() << endl;
          continue;
        }

        if(nfound==0 && htemp!=0 ){
          hsum = (TH1F*) htemp->Clone();
          nfound++;
        }else{
          hsum->Add(htemp);
          nfound++;
        }
      }
      if(!hsum){
        std::cout<<" !!! "<<hname<<std::endl;
        continue;
      }
      hsum->Rebin(2);
      //copy histogram to make a confirmation plot
      hdt[ic][lay-1] = (TH1F*)hsum->Clone(hname.Data());
      hdx[ic][lay-1] = (TH1F*)hsum->Clone(hname.Data());
      hdx[ic][lay-1]->Reset();
      TString hnamedx = Form("hdx_%s_%d",name,lay);
      hdx[ic][lay-1][wire-1]->SetName(hnamedx.Data());
      hxdiff[ic][lay-1] = (TH1F*)hsum->Clone(hname.Data());
      TString hnamexdiff = Form("hxdiff_%s_%d",name,lay);
      
      hxdiff[ic][lay-1]->Reset();
      hxdiff[ic][lay-1]->SetName(hnamexdiff.Data());
      hxdiff[ic][lay-1]->SetYTitle("Differential dist./4 nsec.");
      hxdiff[ic][lay-1]->GetYaxis()->CenterTitle();
      double integral=0;
      double integralbefore=0;
      double ntotal=hsum->Integral();
      if(IsDriftTimeCut) ntotal=hsum->Integral(1,hsum->FindBin(dtmax[ic]));
      if(ntotal<1) continue;

      unsigned int iregion=0;
      double x[30]={0};
      double y[30]={0};
      x[iregion]=hsum->GetBinCenter(0);
      iregion++;
      double thre_fraction=thre[iregion]/100.;
      int binmax = hsum->GetNbinsX();
      for(int ib=0;ib<binmax;ib++){
        integralbefore=integral;
        integral += hsum->GetBinContent(ib);
        float fractionbefore=(float)integralbefore/(float)ntotal;
        float fraction=(float)integral/(float)ntotal;
        hdx[ic][lay-1]->SetBinContent(ib,fraction*dlmax[ic]);
        hxdiff[ic][lay-1]->SetBinContent(ib, (hsum->GetBinContent(ib) - hsum->GetBinContent(ib-1)) );
        //if the fraction exceed the threshold of each region
        if( iregion<nthre && thre_fraction<fraction){
          //cout << "fraction " << fraction << " :thre " << thre_fraction << endl;
          //when the integral is not increased.
          if(integralbefore==integral){
            x[iregion]=hsum->GetBinCenter(ib-1); 
            cout << "not increased " << endl;
          }else{//else it should be increased.
            x[iregion]=(hsum->GetBinCenter(ib-1))+(hsum->GetBinWidth(ib))*(thre_fraction*ntotal-integralbefore)/(integral-integralbefore);
          } 
          y[iregion]=thre_fraction*dlmax[ic];//drift length
          iregion++;
          if(iregion<nthre)   thre_fraction=thre[iregion]/100.;
        }//if
      }
      x[iregion]=hsum->GetBinCenter(hsum->GetNbinsX()+2);
      y[iregion]=dlmax[ic];
      int maxbin = hxdiff[ic][lay-1]->GetMaximumBin();
      //offset in time
      double offset = (maxbin)*hxdiff[ic][lay-1]->GetBinWidth(1)+hxdiff[ic][lay-1]->GetBinCenter(1) ;
      //cout << offset << endl;
      //apply same parameter to all wires in a layer
      for(int wire=1;wire<nwires;wire++){
        ofs<<std::setw(5)<<cid[ic]<<std::setw(5)<<lay<<std::setw(5)<<wire;
        ofs.setf(std::ios_base::fixed,std::ios_base::floatfield);
      }
      for(int j=0;j<nthre;j++){
        ofs<<std::setw(8)<<std::setprecision(2)<<x[j];
      }
      ofs<<std::endl;
    }//for ilayer
  }//for ic
  ofs.close();
  //Drawing  confirmation plots
  TCanvas *c[6][8];
  gStyle->SetOptStat(0);
  for(int idc=0;idc<6;idc++){
    char *name=dlist->GetName(cid[idc]).data();
    int nlayers=dlist->GetNlayers(cid[idc]);
    int nwires=dlist->GetNwires(cid[idc]);
    //c[idc] = new TCanvas(Form("c%s",name),Form("c%s",name),1400,800);
    //c[idc]->Divide(4,2);
    for(int ilr=0;ilr<nlayers;ilr++){
      c[idc][ilr] = new TCanvas(Form("c%s_%d",name,ilr+1),Form("c%s_%d",name,ilr+1),1000,800);
      c[idc][ilr]->Divide(1,2);
      //c[idc]->cd(ilr+1);
      c[idc][ilr]->cd(1);
      hdt[idc][ilr]->SetXTitle("Drift Time [nsec.]");
      hdt[idc][ilr]->SetYTitle("Counts/1 nsec.");
      hdt[idc][ilr]->GetYaxis()->CenterTitle();
      hdt[idc][ilr]->Draw();
      float rightmax = 1.1*hdx[idc][ilr]->GetMaximum();
      float scale    = hdt[idc][ilr]->GetMaximum()/rightmax;
      hdx[idc][ilr]->SetLineColor(kRed);
      hdx[idc][ilr]->Scale(scale);
      hdx[idc][ilr]->Draw("same");
      //draw an axis on the right side
      const int xbinmax = hdx[idc][ilr]->GetXaxis()->GetBinCenter(hdx[idc][ilr]->GetNbinsX());
      TGaxis *axis = new TGaxis(xbinmax,0,xbinmax,hdt[idc][ilr]->GetMaximum(),0,rightmax,510,"+L");
      axis->SetLineColor(kRed);
      axis->SetTextColor(kRed);
      axis->SetTitle("drift length [mm.]");
      axis->SetLabelColor(kRed);
      axis->Draw();
      c[idc][ilr]->cd(2);
      float max1=hdx[idc][ilr]->GetMaximum();
      float max2=hxdiff[idc][ilr]->GetMaximum();
      hxdiff[idc][ilr]->Scale(max1/max2);
      hxdiff[idc][ilr]->SetLineColor(3);
      hxdiff[idc][ilr]->Rebin(2);
      hxdiff[idc][ilr]->Draw("same");
      c[idc][ilr]->SaveAs(Form("fig/%s_%d.png",name,ilr+1));
    }
    //c[idc]->SaveAs(Form("%s.png",name));
  }

  //for(int irun=run_begin;irun<=run_end;irun++){
  //  f[irun-run_begin]->Close();
  //}
  //cout << "File closed" << endl;
}
