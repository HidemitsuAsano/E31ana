//Apr., 2018
//H.Asano
//This is a macro to make X-T curve of drift chambers used in Run78, except for CDC
//a function to make confirmation plots are added from the original macro.
//This macro requires libAll.so from k18ana.

//input : root files generated by EventAnalysisXT.cpp
//output : text files to give X-T curves of Drift chamebers, except for CDC. 
//       : (optional)  Gain map for beam line chamber whose offsets are adjusted wire by wire

#include <TCanvas.h>
#include <TStyle.h>
#include <TH1.h>
#include <TGaxis.h>

class ConfMan;
class CounterMapMan;
class DetectorList;

//drift time 
TH1F *hdt[6][8][32];//detector, layer,wire
//drift length 
TH1F *hdx[6][8][32];//detector, layer,wire
//differential of drift length
TH1F *hxdiff[6][8][32];//detector, layer,wire


void MakeDtDx2_Run78(const int run_begin,
                     const int run_end=0,
                     const bool IsAdjustOffset=true,
                     const bool IsDriftTimeCut=true)
{
  std::cout << "run range:  " << run_begin <<  " - " << run_end << std::endl;
  gSystem->Load("lib/libAll.so");
  ConfMan *conf = new ConfMan("conf/Run78/analyzer.conf",run_begin);
  conf->Initialize();
  
  gROOT->SetBatch();
  gStyle->SetPadGridX(1);
  gStyle->SetPadGridY(1);
  gStyle->SetPadTickX(0);
  gStyle->SetPadTickY(0);
  std::cout<<"start run: "<<run_begin<<std::endl;
  //percentage of integral of drift time distribution. 
  const double thre[]={0,0.3,2,5,10,17,25,32,
		 40,50,60,68,75,83,90,95,
		 98,99.7,100};
  
  int nthre=sizeof(thre)/sizeof(thre[0]);
  DetectorList *dlist=DetectorList::GetInstance();
  dlist->Initialize("param/Run78/Detectors.list");

  TFile *f[100];
  int nfile=run_end-run_begin+1;
  //open data
  int run_end_tmp = run_end;
  if(run_end==0) run_end_tmp = run_begin;
  for(int irun=run_begin;irun<=run_end_tmp;irun++){
    f[irun-run_begin]=new TFile(Form("/gpfs/group/had/knucl/e15/asano/Run78/evanaxt_%04d.root",irun),"READ");
    if(!f[irun-run_begin]->IsOpen()) return;
  }

  const Int_t cid[6]={CID_BLC1a,CID_BLC1b,CID_BLC2a,CID_BLC2b,CID_BPC,CID_FDC1};
  TTimeStamp *tm=new TTimeStamp();
  TString outname=Form("xt_%d_run%d_%d.param",tm->GetDate(),run_begin,run_end);
  if( (run_begin==run_end) || (run_end==0)){
    outname=Form("xt_%d_run%d.param",tm->GetDate(),run_begin);
  }
  ofstream ofs(outname.Data());
  
  //need initialization here.
  //empty histogram from empty ch. can make crash.
  memset(hdt,0,sizeof(hdt));
  memset(hdx,0,sizeof(hdx));
  memset(hxdiff,0,sizeof(hxdiff));
  
  //maximum drift length BLC1,2, newBPC, FDC
  const double dlmax[6]={4.,4.,2.5,2.5,3.0,3.0};

  //hard cut determined after (roughly) tuning wire by wire offset 
  //v1 Apr.13,2018. FDC's cut is very conservative.
  const double dtmax[6]={180,180,120,120,180,300};
  
  for(int ic=0;ic<6;ic++){
    char *name=dlist->GetName(cid[ic]).data();
    int nlayers=dlist->GetNlayers(cid[ic]);
    int nwires=dlist->GetNwires(cid[ic]);
    std::cout<<name<<"  "<<nlayers<<"  "<<nwires<<std::endl;
    ofs<<"XTParam: "<<cid[ic]<<"  "<<dlmax[ic]<<"  "<<nthre<<std::endl;
    ofs<<"Threshold: ";
    for(int i=0;i<nthre;i++){
      ofs<<thre[i]<<"  ";
    }
    ofs<<std::endl;
    for(int lay=1;lay<=nlayers;lay++){
      for(int wire=1;wire<=nwires;wire++){
        TH1F* hsum=NULL;
        //drift time distribution with multiplicity cuts
        TString hname=Form("d%s_%d_%d_mul1",name,lay,wire);
        //sum up histogram from each runs
        int nfound=0;
        for(int ifile=0;ifile<nfile;ifile++){
          TH1F* htemp = (TH1F*)f[ifile]->Get(hname.Data());
          if(htemp==0){
            cout << "can not find " <<  hname.Data() << endl;
            continue;
          }

          if(nfound==0 && htemp!=0 ){
            hsum = (TH1F*) htemp->Clone();
            nfound++;
          }else{
            hsum->Add(htemp);
            nfound++;
          }
        }
        if(!hsum){
          std::cout<<" !!! "<<hname<<std::endl;
          continue;
        }
        hsum->Rebin(5);
        //copy histogram to make a confirmation plot
        hdt[ic][lay-1][wire-1] = (TH1F*)hsum->Clone(hname.Data());
        hdx[ic][lay-1][wire-1] = (TH1F*)hsum->Clone(hname.Data());
        hdx[ic][lay-1][wire-1]->Reset();
        TString hnamedx = Form("hdx_%s_%d_%d",name,lay,wire);
        hdx[ic][lay-1][wire-1]->SetName(hnamedx.Data());
        hxdiff[ic][lay-1][wire-1] = (TH1F*)hsum->Clone(hname.Data());
        TString hnamexdiff = Form("hxdiff_%s_%d_%d",name,lay,wire);
        hxdiff[ic][lay-1][wire-1]->Reset();
        hxdiff[ic][lay-1][wire-1]->SetName(hnamexdiff.Data());
        hxdiff[ic][lay-1][wire-1]->SetYTitle("Differential dist./4 nsec.");
        hxdiff[ic][lay-1][wire-1]->GetYaxis()->CenterTitle();

        double integral=0;
        double integralbefore=0;
        double ntotal=hsum->Integral();
        //hard cut when making a x-t curve
        if(IsDriftTimeCut) ntotal=hsum->Integral(1,hsum->FindBin(dtmax[ic]));
        if(ntotal<1) continue;

        int iregion=0;
        double x[30]={0};
        double y[30]={0};
        double x2[1000],y2[1000];
        x[iregion]=hsum->GetBinCenter(0);
        iregion++;
        double thre_fraction=thre[iregion]/100.;
        int binmax = hsum->GetNbinsX();
        if(IsDriftTimeCut) binmax = hsum->FindBin(dtmax[ic]);
        for(int ib=0;ib<binmax;ib++){
          integralbefore=integral;
          integral += hsum->GetBinContent(ib);
          float fractionbefore=(float)integralbefore/(float)ntotal;
          float fraction=(float)integral/(float)ntotal;
          hdx[ic][lay-1][wire-1]->SetBinContent(ib,fraction*dlmax[ic]);
          hxdiff[ic][lay-1][wire-1]->SetBinContent(ib, (hsum->GetBinContent(ib) - hsum->GetBinContent(ib-1)) );
          //if the fraction exceed the threshold of each region
          if( iregion<nthre && fraction>thre_fraction){
            if(integralbefore==integral){
              x[iregion]=hsum->GetBinCenter(ib-1); 
            }else{//else it should be increased.
              x[iregion]=(hsum->GetBinCenter(ib-1))+(hsum->GetBinWidth(ib))*(thre_fraction*ntotal-integralbefore)/(integral-integralbefore);
            } 
            y[iregion]=thre_fraction*dlmax[ic];//drift length
            iregion++;
            if(iregion<nthre)   thre_fraction=thre[iregion]/100.;
          }//if
        }
        x[iregion]=hsum->GetBinCenter(hsum->GetNbinsX()+2);
        y[iregion]=dlmax[ic];
        int maxbin = hxdiff[ic][lay-1][wire-1]->GetMaximumBin();
      //offset in time
        double offset = (maxbin)*hxdiff[ic][lay-1][wire-1]->GetBinWidth(1)+hxdiff[ic][lay-1][wire-1]->GetBinCenter(1) ;
        //cout << offset << endl;
        //apply same parameter to all wires in a layer
        ofs<<std::setw(5)<<cid[ic]<<std::setw(5)<<lay<<std::setw(5)<<wire;
        ofs.setf(std::ios_base::fixed,std::ios_base::floatfield);
        for(int j=0;j<nthre;j++){
          ofs<<std::setw(8)<<std::setprecision(2)<<x[j];
        }
        ofs<<std::endl;
      }//for wire
    }//for lay
  }//for ic
  ofs.close();


  TString outname=Form("xt_run%d_%d.root",run_begin,run_end);
  TFile *fout = new TFile(outname.Data(),"RECREATE");
  fout->cd();
  //Drawing  confirmation plots
  TCanvas *c[6][8];
  for(int idc=0;idc<6;idc++){
    char *name=dlist->GetName(cid[idc]).data();
    int nlayers=dlist->GetNlayers(cid[idc]);
    int nwires=dlist->GetNwires(cid[idc]);
    for(int ilr=0;ilr<nlayers;ilr++){
      c[idc][ilr] = new TCanvas(Form("c%d_%d",idc,ilr),Form("c%d_%d",idc,ilr),800,800);
      if(idc!=5)c[idc][ilr]->Divide(4,8);
      else (idc==5)c[idc][ilr]->Divide(8,8);
      for(int iwire=0;iwire<nwires;iwire++){
        if(hdt[idc][ilr][iwire]==0) continue;
        c[idc][ilr]->cd(iwire+1);
        
        hdt[idc][ilr][iwire]->Draw();
        hdt[idc][ilr][iwire]->Write();
        float rightmax = 1.1*hdx[idc][ilr][iwire]->GetMaximum();
        float scale = hdt[idc][ilr][iwire]->GetMaximum()/rightmax;
        hdx[idc][ilr][iwire]->SetLineColor(kRed);
        hdx[idc][ilr][iwire]->Scale(scale);
        hdx[idc][ilr][iwire]->Draw("same");
        hdx[idc][ilr][iwire]->Write();
        hxdiff[idc][ilr][iwire]->Write();
         //draw an axis on the right side
        TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),
            gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,"+L");
        axis->SetLineColor(kRed);
        axis->SetLabelColor(kRed);
        axis->Draw();
      }
      c[idc][ilr]->SaveAs(Form("fig/wbyw%s_%d.png",name=dlist->GetName(cid[idc]).data(),ilr+1));
    }
  }
  
  if(IsAdjustOffset){
    AdjustTDCOffset(conf,dlist,run_begin,run_end);
    cout <<  conf->GetGainMapManager()->GetFileNameBL() << endl;
  }



  fout->Close();
}


void AdjustTDCOffset(ConfMan* conf,DetectorList *dlist,const int run_begin,const int run_end){

  const int TDC=1; 

  const Int_t cid[6]={CID_BLC1a,CID_BLC1b,CID_BLC2a,CID_BLC2b,CID_BPC,CID_FDC1};
  for(int idc=0;idc<6;idc++){
    char *name=dlist->GetName(cid[idc]).data();
    int nlayers=dlist->GetNlayers(cid[idc]);
    int nwires=dlist->GetNwires(cid[idc]);
    for(int ilr=0;ilr<nlayers;ilr++){
      for(int iwire=0;iwire<nwires;iwire++){
        if(hxdiff[idc][ilr][iwire]==0) continue;
        int cr,sl,ch;
        conf->GetCounterMapManager()
          ->GetCNA(cid[idc],ilr+1,iwire+1,TDC,0,cr,sl,ch);
        int maxbin = hxdiff[idc][ilr][iwire]->GetMaximumBin();
        TF1 *
        //offset in time [nsec.]
        double offset = (maxbin)*hxdiff[idc][ilr][iwire]->GetBinWidth(1)
                       +(hxdiff[idc][ilr][iwire]->GetBinCenter(1)) ;
        //Time = p1*TDC+p2*TDC*TDC - offset [nsec]
        double gain_p1=-9999;
        //double gain_p2=-9999;
        double currentped=-9999;
        conf->GetGainMapManager()->GetParam(cr,sl,ch, gain_p1,currentped);
        double pednew=currentped+offset;
        conf->GetGainMapManager()->SetParam(cr,sl,ch, gain_p1,pednew);
        cout << "cr:sl:ch " << cr << ":" << sl << ":" << ch << " offset b->a " <<  currentped << " -> "  << pednew << endl;
      }//for iwire
    }//for ilr
  }//for idc
  
  TString outname=Form("GainMapBL_%04d_%04d_xt.param",run_begin,run_end);
  ofstream ofsbl(outname.Data());
  conf->GetGainMapManager()->PrintMapBL(ofsbl);
  return;
}


TGraphErrors* Differential(TH1F &h1,double range[2],double &maximum,int reb=1){
  double y[4000];
  double yerr[4000];
  double x[4000];
  int ndata=0;

  if(h1.GetEntries()==0) return 0;

  h1.Rebin(reb);

  int nbin=h1.GetNbinsX();
  int xmin=h1.GetXaxis()->GetXmin();
  int xmax=h1.GetXaxis()->GetXmax();
  for(int i=xmin; i<nbin-1; i++){
    if(h1.GetBinContent(i)>0){
      xmin=i;
      break;
    }
  }
  for(int i=xmax; i>xmin; i--){
    if(h1.GetBinContent(i)>0){
      xmax=i;
      break;
    }
  }
  range[0]=h1.GetBinCenter(xmin); range[1]=h1.GetBinCenter(xmax);
  double tmpmaximum = 0.0;
  for(int i=xmin;i<xmax;i++){
    double diff=h1.GetBinContent(i+1)-h1.GetBinContent(i);
    double differr = TMath::Sqrt(h1.GetBinContent(i+1)+h1.GetBinContent(i));
    y[ndata] = diff;
    yerr[ndata] = differr;
    x[ndata] = (h1.GetBinCenter(i+1) + h1.GetBinCenter(i))/2.0;
    if(x[ndata]<-15||15<x[ndata]){ continue; }
    if(tmpmaximum<diff){
      tmpmaximum=diff;
      maximum = x[ndata];
    }
    ndata++;
  }

  TGraphErrors* gra = new TGraphErrors(ndata,x,y,0,yerr);
  gra -> SetTitle(h1.GetTitle());
  gra -> GetXaxis() -> SetTitle(h1.GetXaxis()->GetTitle());
  gra -> GetYaxis() -> SetTitle(Form("Differential"));
  //gra->GetXaxis()->SetTitleFont(22);
  //gra->GetYaxis()->SetTitleFont(22);
  //gra->GetXaxis()->SetTitleSize(0.05);
  //gra->GetYaxis()->SetTitleSize(0.05);
  //gra->GetXaxis()->SetLabelFont(22);
  //gra->GetYaxis()->SetLabelFont(22);
  //gra->GetXaxis()->SetLabelSize(0.04);
  //gra->GetYaxis()->SetLabelSize(0.04);
  //gra->GetXaxis()->SetDecimals(kTRUE);
  //gra->GetYaxis()->SetDecimals(kTRUE);
  //gra->GetXaxis()->SetTitleOffset(_title_offset_x-0.3);
  //gra->GetYaxis()->SetTitleOffset(_title_offset_y);
  gra->GetXaxis()->CenterTitle();
  gra->GetYaxis()->CenterTitle();

  return gra;
}
