//----------------------------------------------------------------//
// ===== UserSimpipippp.cpp =====
// sample program to reconstruct pi S p n event
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// reconstruction mathod is based on "EventAnalysis_pipippp_sakuma.cpp"
//----------------------------------------------------------------//
//  exe-file: simpipippp [./simpipippp $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: when $(OutFile) is "tmp.root", the following 2 files are generated.
//     "tmp.root":      histogram file
//     "tmp_pipippp.root": basic information of pipippp event is listed up in TTree 
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//
//  updated by F.S, 2016 12/28
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"
#include "TrackTools.h"
#include "EventHeader.h"
#include "Tools.h"
#include "ELossTools.h"

#include <TDatabasePDG.h>
#include <KinFitter/TKinFitter.h>
#include <KinFitter/TFitParticlePxPyPz.h>
#include <KinFitter/TFitConstraintM.h>
#include <KinFitter/TFitConstraintEp.h>
#include <Math/ProbFuncMathCore.h>

#define KFDEBUG 0 // verbose level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices

//-- set run# --//
//const std::string GRUN = "49c";
const std::string GRUN = "65";

TLorentzVector tL_L;
TLorentzVector tL_p;
TLorentzVector tL_n;
TLorentzVector tL_K;

const double MOM_RES = 2.0; // MeV/c
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)

//** cut parameters **//
//@@ only different cut parameters btw Sada & Yamaga are listed @@//
double PARA_blc2bpc_dx_MIN;
double PARA_blc2bpc_dx_MAX;
double PARA_blc2bpc_dy_MIN;
double PARA_blc2bpc_dy_MAX;
double PARA_blc2bpc_dxdz_MIN;
double PARA_blc2bpc_dxdz_MAX;
double PARA_blc2bpc_dydz_MIN;
double PARA_blc2bpc_dydz_MAX;
double PARA_lnL_MAX;
double PARA_MM_LP_MIN;
double PARA_MM_LP_MAX;

const double TDC_CDH_MAX = 20; // ns
const double ADC_CDH_MIN = 1;  // MeV

//= = = = pipippp final-sample tree = = = =//
TLorentzVector mom_beam;   // 4-momentum(beam)
TLorentzVector mom_target; // 4-momentum(target)
TLorentzVector mom_pimL;   // 4-momentum(pi-) pi- from L
TLorentzVector mom_pim;   // 4-momentum(pi-)
TLorentzVector mom_pL;     // 4-momentum(proton) p from L
TLorentzVector mom_p;     // 4-momentum(proton)
TVector3 vtx_reaction; // vertex(reaction)
int run_num;   // run number
int event_num; // event number
int block_num; // block number
TLorentzVector mcmom_beam;   // generated 4-momentum(beam)
TLorentzVector mcmom_pimL;   // generated 4-momentum(pi-) pi- from L
TLorentzVector mcmom_pim;   // generated 4-momentum(pi-)
TLorentzVector mcmom_pL;     // generated 4-momentum(proton) p from L
TLorentzVector mcmom_p;     // generated 4-momentum(proton)
TLorentzVector kfmom_beam;   // 4-momentum(beam) after kinematical refit for pi- Lambda
TLorentzVector kfmom_pimL;   // 4-momentum(pi-) after kinematical refit for pi- Lambda
TLorentzVector kfmom_pim;   // 4-momentum(pi-) after kinematical refit for pi- Lambda
TLorentzVector kfmom_pL;     // 4-momentum(proton) after kinematical refit for pi- Lambda
TLorentzVector kfmom_p;     // 4-momentum(proton) after kinematical refit for pi- Lambda
double kf_chi2;   // chi2 of kinematical refit
double kf_NDF;    // NDF of kinematical refit
double kf_status; // status of kinematical refit -> details can be found in this code
double kf_pvalue; // p-value of kinematical refit
int kf_flag; // flag of correct pair reconstruction, etc
//= = = = pipippp final-sample tree = = = =//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// "Status" obtaind with kinfitter.getStatus() is as follows:
//  (see /w/e15/common/KinFitter/KinFitter/TKinFitter.cxx)
//  case -1:  statusstring = "NO FIT PERFORMED";
//  case 10:  statusstring = "RUNNING";
//  case 0:   statusstring = "CONVERGED";
//  case 1:   statusstring = "NOT CONVERGED";
//  case -10: statusstring = "ABORTED";
//  default:  statusstring = "NOT DEFINED";
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

const double proton_MIN = 0.85;
const double proton_MAX = 1.03;
const double ppi_MIN = 1.1075;
const double ppi_MAX = 1.1225;

using namespace std;

int main( int argc, char** argv )
{
  if( argc!=5 ){
    cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<endl;
    return 0;
  }

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");

  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//
  // ### obtained from (p_meas[j]-p_gene[j])
  // ###  using G4-data with TH1F(Form("cov_%d_%d_%d", i, j, j), 100, -cov_MAX, cov_MAX);
  // ###  and evaluated using "Air" Dora MC
  // = TLorentzVector L3_beam, L_pim, (L_pL+L_pimL), L_p, L_pmiss, L_pL, L_pimL = for pi- Lambda
  const double covVal[7][16] = {
    { 1.8836e-05, 0, 0, 0,
      0, 2.03265e-05, 0, 0,
      0, 0, 3.89656e-06, 0,
      0, 0, 0, 3.14701e-06 },
    { 1.25642e-05, 0, 0, 0,
      0, 1.35526e-05, 0, 0,
      0, 0, 2.17561e-05, 0,
      0, 0, 0, 1.61508e-05 },
    { 0.000109168, 0, 0, 0,
      0, 0.000107748, 0, 0,
      0, 0, 0.000104789, 0,
      0, 0, 0, 5.4732e-05 },
    { 0.00011678, 0, 0, 0,
      0, 0.000117602, 0, 0,
      0, 0, 0.000107535, 0,
      0, 0, 0, 7.27953e-05 },
    { 0.000360925, 0, 0, 0,
      0, 0.000375745, 0, 0,
      0, 0, 0.000291721, 0,
      0, 0, 0, 0.000267072 },
    { 0.000104229, 0, 0, 0,
      0, 9.87073e-05, 0, 0,
      0, 0, 8.52701e-05, 0,
      0, 0, 0, 4.64116e-05 },
    { 7.42018e-06, 0, 0, 0,
      0, 7.44134e-06, 0, 0,
      0, 0, 1.1375e-05, 0,
      0, 0, 0, 2.6377e-06 }
  };

  TMatrixD *covZero = new TMatrixD(4, 4);
  covZero->Zero();
  covZero->ResizeTo(3, 3); // resize from 4x4 to 3x3
  TMatrixD *covParticle[7];
  for( int i=0; i<7; i++ ){
    covParticle[i] = new TMatrixD(4, 4);
    int n = 0;
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( j==k ){
	  (*covParticle[i])[j][k] = covVal[i][n]; // only diagonal elements
	} else{
	  (*covParticle[i])[j][k] = 0;
	}
	n++;
      }
    }
    covParticle[i]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticle[i]->Print(); // Print all
  }
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//


  //** Conf file open **// 
  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  //** Simulation file open **// 
  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);
  if( tree2->GetEntries()==1 ) cout<<"  !!! tree2 entries==1 !!!"<<endl;
  else tree2->GetEntry(0);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  //** Getting CDSTracking info. from CDCfile **//
  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
  EventHeader      *header = new EventHeader();
  evTree->SetBranchAddress("EventHeader", &header );
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan  = new BeamLineTrackMan();
  CDSTrackingMan   *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  //** output file 1 : histograms **//
  TFile *outfile = new TFile(argv[2], "recreate");
  outfile->cd();

  //** output file 2 : pipippp final-sample tree **// 
  std::string outfile2_name = string(argv[2]);
  outfile2_name.insert( outfile2_name.size()-5, "_pipippp" );
  std::cout<<"pipippp file "<<outfile2_name<<std::endl;
  TFile *outfile2 = new TFile( outfile2_name.c_str(), "recreate" );
  outfile2->cd();
  TTree *pipipppTree = new TTree( "EventTree", "EventTree" );
  pipipppTree->Branch( "mom_beam",   &mom_beam );
  pipipppTree->Branch( "mom_target", &mom_target );
  pipipppTree->Branch( "mom_pimL", &mom_pimL );
  pipipppTree->Branch( "mom_pim", &mom_pim );
  pipipppTree->Branch( "mom_pL", &mom_pL );
  pipipppTree->Branch( "mom_p", &mom_p );
  pipipppTree->Branch( "vtx_reaction", &vtx_reaction );
  pipipppTree->Branch( "run_num", &run_num );
  pipipppTree->Branch( "event_num", &event_num );
  pipipppTree->Branch( "block_num", &block_num );
  pipipppTree->Branch( "mcmom_beam",   &mcmom_beam );
  pipipppTree->Branch( "mcmom_pimL", &mcmom_pimL );
  pipipppTree->Branch( "mcmom_pim", &mcmom_pim );
  pipipppTree->Branch( "mcmom_pL", &mcmom_pL );
  pipipppTree->Branch( "mcmom_p", &mcmom_p );
  pipipppTree->Branch( "kfmom_beam",   &kfmom_beam );
  pipipppTree->Branch( "kfmom_pimL", &kfmom_pimL );
  pipipppTree->Branch( "kfmom_pim", &kfmom_pim );
  pipipppTree->Branch( "kfmom_pL", &kfmom_pL );
  pipipppTree->Branch( "kfmom_p", &kfmom_p );
  pipipppTree->Branch( "kf_chi2", &kf_chi2 );
  pipipppTree->Branch( "kf_NDF", &kf_NDF );
  pipipppTree->Branch( "kf_status", &kf_status );
  pipipppTree->Branch( "kf_pvalue", &kf_pvalue );
  pipipppTree->Branch( "kf_flag", &kf_flag );
  outfile->cd();


  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    //return 0;
  }


  //=== definitino of histograms ===//
  //** gneneral informantion **//
  Tools::newTH1F( Form("Time"), 3000, -0.5, 2999.5 );
  Tools::newTH1F( Form("EventCheck"), 20, 0, 20 );
  Tools::newTH1F( Form("Scaler"), 41, -0.5, 40.5 );

  //** CDC and CDH information from CDC-trackig file **//
  Tools::newTH1F( Form("nGoodTrack"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_CDH"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_CDHc"), 11, -0.5, 10.5 );

  //** beam line **//
  Tools::newTH1F( Form("mul_BHD"), 12, -0.5, 11.5 );
  Tools::newTH1F( Form("mul_T0"),   6, -0.5, 5.5 );
  Tools::newTH1F( Form("tof_T0BHD"), 2000, 20, 40 );
  Tools::newTH1F( Form("tracktime_BPC"),  1200, -200, 400 );
  Tools::newTH1F( Form("trackchi2_BPC"),  200, 0, 20 );
  Tools::newTH1F( Form("ntrack_BPC"),  6, -0.5, 5.5 );
  Tools::newTH1F( Form("tracktime_BLC1"), 1200, -200, 400 );
  Tools::newTH1F( Form("tracktime_BLC2"), 1200, -200, 400 );
  Tools::newTH1F( Form("trackchi2_BLC1"), 200, 0, 20 );
  Tools::newTH1F( Form("trackchi2_BLC2"), 200, 0, 20 );
  Tools::newTH1F( Form("ntrack_BLC1"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_BLC2"), 6, -0.5, 5.5 );
  Tools::newTH2F( Form("dydx_BLC2BPC"),     130, -1.3, 1.3, 130, -1.3, 1.3 );
  Tools::newTH2F( Form("dydzdxdz_BLC2BPC"), 175, -0.035, 0.035, 175, -0.035, 0.035 );
  Tools::newTH1F( Form("trackchi2_beam"), 400, 0, 40 );
  Tools::newTH1F( Form("momentum_beam"), 180, 0.92, 1.10 );

  //** CDS **//
  Tools::newTH1F( Form("trackchi2_CDC"), 1000, 0, 50 );
  Tools::newTH2F( Form("PID_CDS_beta"), 1000, 0, 5, 1000, -1.2, 1.2 );
  Tools::newTH2F( Form("PID_CDS"), 1000, -0.6, 5, 1000, -1.2, 1.2 );
  Tools::newTH1F( Form("ntrack_CDS"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_pi_plus"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_proton"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_deuteron"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_pi_minus"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_K_minus"), 6, -0.5, 5.5 );

  //** forward counters **//
  Tools::newTH1F( Form("mul_BVC"), 9, -0.5, 8.5 );
  Tools::newTH1F( Form("mul_CVC"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_PC"), 11, -0.5, 10.5 );

  //** p p pi- pi- X event **//

#if 1
  //*** for kinematical fit ***//
  // beam_K(K+), pi-, Lambda, p, p, p from L, pi- from L
  // !!! only diagonal components !!!
  const int BIN = 100;
  double cov_MAX;
  for( int i=0; i<7; i++ ){
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( i==0 || i==1 || i==6 ) // K-, pi, pi
	  cov_MAX = 0.02;
	else // L, p, p_miss, p
	  cov_MAX = 0.1;
	Tools::newTH1F(Form("cov_%d_%d_%d", i, j, k), BIN, -cov_MAX, cov_MAX);
      }
    }
  }
#endif
  Tools::newTH1F( Form("KFchi2"), 100, 0, 100 );
  Tools::newTH1F( Form("KFpvalue"), 100, 0, 1 );
  Tools::newTH1F( Form("KFstatus"), 21, -10.5, 10.5 );

  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  cout<<"===== Lambda p n reconstruction in MC START ============="<<endl;
  cout<<"     # of All  Event in EventTree:     "<<eventn<<endl;
  cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<endl;
  cout<<"     # of Exe  Event in this program:  "<<exen<<endl;
  cout<<"========================================================="<<endl;

  //** set cut parameters **//
  if( GRUN=="49c" ){
    //** from EventAnalysis_Lpn_sada.cpp **// //!! sada-D p.73 !!//
    PARA_blc2bpc_dx_MIN = -0.795;
    PARA_blc2bpc_dx_MAX = 0.822;
    PARA_blc2bpc_dy_MIN = -0.865;
    PARA_blc2bpc_dy_MAX = 0.871;
    PARA_blc2bpc_dxdz_MIN = -0.0240;
    PARA_blc2bpc_dxdz_MAX = 0.0250;
    PARA_blc2bpc_dydz_MIN = -0.02481;
    PARA_blc2bpc_dydz_MAX = 0.02489;
    PARA_lnL_MAX = 6.0;
  }else if ( GRUN=="65" ){
    //** from Yamaga:MyAnalysisBL.cpp **//
    PARA_blc2bpc_dx_MIN = -0.75;
    PARA_blc2bpc_dx_MAX = 0.75;
    PARA_blc2bpc_dy_MIN = -0.75;
    PARA_blc2bpc_dy_MAX = 0.75;
    PARA_blc2bpc_dxdz_MIN = -0.02;
    PARA_blc2bpc_dxdz_MAX = 0.02;
    PARA_blc2bpc_dydz_MIN = -0.02;
    PARA_blc2bpc_dydz_MAX = 0.02;
    PARA_lnL_MAX = 9.95;
  }else{
    std::cerr<<" !!! pleas set paramter::GRUN in EventAnalysis_Lpn_sakuma.cpp => 49c or 65 !!!"<<std::endl;
    return 0;
  }

  PARA_MM_LP_MIN = 0.85;
  PARA_MM_LP_MAX = 1.03;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;
  int nEvent_Lp    = 0;
  int nEvent_Lpn   = 0;

  int nG4Event_piSpn   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_nCDH = 0;
  int nAbort_nT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_flagKF = 0;
  int nAbort_pppipi = 0;
  int nAbort_end = 0;

  int nFill_pppipi = 0;
  int nFill_pipippp = 0;

  int nTrack_CDHshare = 0;

  int ev_cdc = 0;

  //=== event loop ===//
  for( int ev=0; ev<exen; ev++ ){
#if 1
    if( /*ev<100 ||*/ ev%100==0 ) std::cout<<"> Event Number "<<ev<<std::endl;
#else
    std::cout<<"> Event Number "<<ev<<std::endl;
    if( ev == 1000 ) break;
#endif

    Tools::Fill1D( Form("EventCheck"), 1 );

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(ev); // MC
    evTree->GetEntry(ev_cdc); // CDC-tracking
    
    //### event ID matching
    if( evHeaderMC->eventID()!=header->ev() ){
      continue;
    }
    ev_cdc++;


    //### CDH ADC cut ###//
    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ){
      if( !(detData->detectorHit(i)->detectorID()==CID_CDH && detData->detectorHit(i)->adc()<ADC_CDH_MIN) ){
	detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }


    simMan->Convert(detData2, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);
    bltrackMan->DoTracking(blMan, confMan, true, true);


    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4Decay = false;
    int kpp_track = -1;
    int pi_parent  = 0;
    int Y_parent  = 0;
    int N_parent  = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      int track   = mcData->track(j)->trackID();
      if( pdgcode==9999 && parent==0 ){ // Kpp
	kpp_track = track;
	pi_parent  = track;
	Y_parent  = track;
	N_parent  = track;
      }
    }
    //std::cerr<<"======================"<<std::endl;
    //for( int j=0; j<reacData->ParticleSize(); j++ ){
    //std::cerr<<j<<" "<<reacData->PDG(j)<<" "<<reacData->GetParticle(j).P()<<std::endl;
    //}
    int reactionID = reacData->ReactionID();
    int PDG[7] = {321, -211, 3122, 2212, 2212, 2212, -211}; // pi-Lambda
    // beam_K(K+), pi-, L, p, p_miss, p from L, pi- from L
    int parentID[7] = {0, pi_parent, Y_parent, N_parent, 0, -1, -1};
    int ID[7]       = {-1, -1, -1, -1, -1, -1, -1};
    int trackID[7]  = {-1, -1, -1, -1, -1, -1, -1};
    int nparticle = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      int track   = mcData->track(j)->trackID();
      //cerr<<j<<" | "<<pdgcode<<" "<<parent<<" "<<track<<endl;
      for( int k=0; k<7; k++ ){
	if( pdgcode==PDG[k] && parent==parentID[k] && ID[k]==-1 ){
	  ID[k] = j;
	  trackID[k] = track;
	  nparticle++;
	  //cerr<<j<<","<<k<<" | "<<pdgcode<<" "<<parent<<" "<<track<<endl;
	  if( k==2 ){
	    parentID[5] = track;
	    parentID[6] = track;
	  }
	  //if( k==3 || k==4 || k==5 ) std::cerr<<k<<" | "<<pdgcode<<" "<<parent<<" "<<track<<" "<<mcData->track(j)->momentum().Mag()
	  //<<" ("<<mcData->track(j)->momentum().CosTheta()<<" , "<<mcData->track(j)->momentum().Phi()*360/TwoPi<<")"<<std::endl;
	  break;
	}
      }
    }
    //cerr<<" nparticle = "<<nparticle<<endl;
    if( nparticle==7 ) flagG4Decay = true;

    int CDHhit_mc[7] = {-1, -1, -1, -1, -1, -1, -1};
    if( flagG4Decay ){
      for( int j=0; j<detData2->detectorHitSize(); j++ ){
        int cid   = detData2->detectorHit(j)->detectorID();
        int track = detData2->detectorHit(j)->trackID();
	int channel = detData2->detectorHit(j)->channelID();
        for( int k=0; k<7; k++ ){
          if( cid==CID_CDH && track==trackID[k] ) CDHhit_mc[k] = channel+1;
        }
      }
    }
    
#if 1
    //*** for kinematical fit ***//
    // beam_K(K+), pi-, L, p, p_miss, p from L, pi- from L
    TLorentzVector TL_gene[7]; // generated
    for( int i=0; i<7; i++ ){
      if( i ) TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*0.001,  pdg->GetParticle(PDG[i])->Mass()); // GeV
      else    TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*-0.001, pdg->GetParticle(PDG[i])->Mass()); // GeV
    }
#endif
    //##########################//
    //### get G4 information ###//
    //##########################//


    //=======================================//
    //=== from EventAnalysis_Lpn_sada.cpp ===//
    //=======================================//
    int nGoodTrack = cdstrackMan->nGoodTrack();
    int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;
    Tools::Fill1D( Form("nGoodTrack"), nGoodTrack );
    if( nGoodTrack!=4 ){ // dedicated for p p pi- pi- event
      nAbort_nGoodTrack++;
      continue;
    }

    //** # of CDH-hits cut **// 
    int nCDH = 0;
    for( int i=0; i<cdsMan->nCDH(); i++ ){
      //if( cdsMan->CDH(i)->CheckRange() ){
      if( cdsMan->CDH(i)->CheckRange() && cdsMan->CDH(i)->ctmean()<TDC_CDH_MAX ){
	nCDH++;
      }
    }
    Tools::Fill1D( Form("mul_CDH"), nCDH );
    if( nCDH!=4 ){ //** only 4 hits events **//
      nAbort_nCDH++;
      continue;
    }

    //** T0 = 1hit selection **//
    int nT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      HodoscopeLikeHit *hit = blMan->T0(i);
      if( hit->CheckRange() ) nT0++;
    }
    Tools::Fill1D( Form("mul_T0"),  nT0 );
    if( nT0!=1 ){ 
      nAbort_nT0++;
      continue;
    }

    //** Beam PID **//
    double ctmT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      if( blMan->T0(i)->CheckRange() ){
	ctmT0 = blMan->T0(i)->ctmean();
      }
    }
    int pid_beam = 0; //0:K 1:pi 3:else

    //** BPC track selection **//
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ){
      nbpc++;
      bpcid = i;
    }
    Tools::Fill1D( Form("ntrack_BPC"), nbpc );
    if( nbpc!=1 ){
      nAbort_nbpc++;
      continue;
    }
    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);    
    if( bpctrack->chi2all()>10 ){
      nAbort_bpctrack++;
      continue;
    }

    //** vertex calculation **//
    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ){
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }


    //** vectors for PID container **//
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    std::vector <int> d_ID;
    
    std::vector <int> vCDHseg;

    bool flagbmom = false;
    TVector3 vtx_react;

    //** BLC2 track **//
    int nblc2 = 0;
    int blc2id = -1;
    for( int i=0; i<bltrackMan->ntrackBLC2(); i++ ){
      nblc2++;
      if( bltrackMan->trackBLC2(i)->chi2all()<10 ) blc2id = i;
    }
    Tools::Fill1D( Form("ntrack_BLC2"), nblc2 );
    if( !(nblc2==1 && blc2id!=-1) ){
      nAbort_nblc2++;
      continue;
    }

    //### BLC2-BPC position matching
    bool fblc2bpc = false;
    for( int ii=0; ii<bltrackMan->ntrackBLC2(); ii++ ){
      if( ii!=blc2id ) continue;
      LocalTrack *blc2 = bltrackMan->trackBLC2(ii);
      double xblc2bpc[2], yblc2bpc[2];
      double xmom[2], ymom[2];

      TVector3 Pos_BPC, Pos_BLC2, tmp;
      confMan->GetBLDCWireMapManager()->GetGParam( CID_BPC, Pos_BPC, tmp );
      confMan->GetBLDCWireMapManager()->GetGParam( CID_BLC2a, Pos_BLC2, tmp );
      double zPos_BPC = Pos_BPC.Z();
      double zPos_BLC2 = Pos_BLC2.Z();
      double zPos_BPC_BLC2 = (Pos_BPC.Z()+Pos_BLC2.Z())/2;

      bpctrack->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[0], yblc2bpc[0] );
      bpctrack->XYPosatZ( zPos_BPC, xmom[0], ymom[0] );
      blc2->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[1], yblc2bpc[1]);
      blc2->XYPosatZ( zPos_BLC2, xmom[1], ymom[1]);
      double dxdz[2], dydz[2];
      dxdz[0] = (xmom[0]-xblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
      dxdz[1] = (xmom[1]-xblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);
      dydz[0] = (ymom[0]-yblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
      dydz[1] = (ymom[1]-yblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);

      if(      (xblc2bpc[1]-xblc2bpc[0])<PARA_blc2bpc_dx_MIN ||
	       (xblc2bpc[1]-xblc2bpc[0])>PARA_blc2bpc_dx_MAX ) fblc2bpc = false;
      else if( (yblc2bpc[1]-yblc2bpc[0])<PARA_blc2bpc_dy_MIN ||
	       (yblc2bpc[1]-yblc2bpc[0])>PARA_blc2bpc_dy_MAX ) fblc2bpc = false;
      else if( (dxdz[1]-dxdz[0])<PARA_blc2bpc_dxdz_MIN ||
	       (dxdz[1]-dxdz[0])>PARA_blc2bpc_dxdz_MAX ) fblc2bpc = false;
      else if( (dydz[1]-dydz[0])<PARA_blc2bpc_dydz_MIN ||
	       (dydz[1]-dydz[0])>PARA_blc2bpc_dydz_MAX ) fblc2bpc = false;
      else fblc2bpc = true;

      Tools::Fill2D( Form("dydx_BLC2BPC"), xblc2bpc[1]-xblc2bpc[0], yblc2bpc[1]-yblc2bpc[0] );
      Tools::Fill2D( Form("dydzdxdz_BLC2BPC"), dxdz[1]-dxdz[0], dydz[1]-dydz[0] );
    }

    if( !fblc2bpc ){
      nAbort_fblc2bpc++;
      continue;
    }

    //** beam momentum calculation **//
    TLorentzVector L3_beambf;  // 4-Momentum(beam) in LAB
    TLorentzVector L3_beam;    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector L3_target;  // 4-Momentum(He3-target) in LAB
    TLorentzVector L3_targetP; // 4-Momentum(p-target) in LAB
    TLorentzVector L3_beambfCM;  // 4-Momentum(beam) in CM
    TLorentzVector L3_beamCM;    // 4-Momentum(beam) in CM with dE correcion
    TLorentzVector L3_targetCM;  // 4-Momentum(He3-target) in CM
    TLorentzVector L3_targetPCM; // 4-Momentum(p-target) in CM

    TVector3 Pos_T0;
    confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
    double zPos_T0 = Pos_T0.Z();

    double beammom = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      if( pdgcode==321 && parent==0 ){
	beammom = (mcData->track(j)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
	break;
      }
    }

    double x1, y1, x2, y2;
    double z1 = 0, z2 = 20;
    bpctrack->XYPosatZ(z1, x1, y1);
    bpctrack->XYPosatZ(z2, x2, y2);
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls; 
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    L3_beambf.SetVectM(Pp_beam , kpMass);
    L3_target.SetVectM(Pp_target, ThreeHeMass);
    L3_targetP.SetVectM(Pp_target, pMass);
    L3_beam = L3_beambf;
    TVector3 boost = (L3_target+L3_beam).BoostVector();
    L3_beambfCM = L3_beam;
    L3_targetCM = L3_target;
    L3_targetPCM = L3_targetP;
    L3_beambfCM.Boost(-1*boost);
    L3_targetCM.Boost(-1*boost);
    L3_targetPCM.Boost(-1*boost);
    flagbmom = true;

    if( !flagbmom ){
      nAbort_flagbmom++;
      continue;
    }
    Tools::Fill1D( Form("momentum_beam"), L3_beambf.P() );

    //** + + + + + + + + + + + + **//
    //**  PID in CDS             **//
    //** + + + + + + + + + + + + **//

    int CDHseg;

    //** PID of CDS tracks **//
    for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){
      CDSTrack *track = cdstrackMan->Track(cdstrackMan->GoodTrackID(it));

      Tools::Fill1D( Form("trackchi2_CDC"), track->Chi() );

      if( track->Chi()>30 ) continue; 
      if( !track->CDHFlag() ) continue;

      double mom = track->Momentum();
      TVector3 vtxb1, vtxb2, vtxb;
      track->GetVertex( bpctrack->GetPosatZ(zPos_T0), bpctrack->GetMomDir(), vtxb1, vtxb2 );
      track->SetPID(-1);
      vtxb = (vtxb1+vtxb2)*0.5;

      double tof = 999.;
      double mass2 = -999.;
      for( int icdh=0; icdh<track->nCDHHit(); icdh++ ){
	HodoscopeLikeHit *cdhhit=track->CDHHit(cdsMan,icdh);
	double tmptof = cdhhit->ctmean() - ctmT0;      
	//cerr<<icdh<<": "<<cdhhit->ctmean()<<" - "<<ctmT0<<" = "<<tmptof<<endl;
	if( tmptof<tof || tof==999. ){ //*** apply minimum TOF hit ***//
	  tof = tmptof;
	  CDHseg = cdhhit->seg();
	}
      }
      //*************************************
      // In a CDH hit-shared event, only some one track is adopted and the others are discarded
      //*************************************

      bool CDHflag = true;
      for( int m=0; m<(int)vCDHseg.size(); m++ ){
	if( CDHseg==vCDHseg[m] ) CDHflag = false;
      }
      if( !CDHflag ){
	nTrack_CDHshare++;
	continue;
      }
      vCDHseg.push_back(CDHseg);

      //** calculation of beta and squared-mass **//
      double tmptof, beta_calc;
      if( !TrackTools::FindMass2( track, bpctrack, tof, L3_beam.Vect().Mag(),
				  pid_beam, beta_calc, mass2, tmptof ) ){
	std::cerr<<" !!! failure in PID_CDS [FindMass2()] !!! "<<std::endl;
	continue;
      }
      int pid = TrackTools::PIDcorr(mom,mass2);      
      track->SetPID(pid);
      Tools::Fill2D( "PID_CDS_beta", 1/beta_calc, mom );
      Tools::Fill2D( "PID_CDS", mass2, mom );

      //** energy loss calculation **//
      double tmpl;
      TVector3 vtx_beam, vtx_cds;
      if( !track->CalcVertexTimeLength(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), track->Mass(),
				       vtx_beam, vtx_cds, tmptof, tmpl, true) ){
	std::cerr<<" !!! failure in energy loss calculation [CalcVertexTimeLength()] !!! "<<std::endl;
	continue;
      }

      if( pid==CDS_PiMinus )
	pim_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_PiPlus )
	pip_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_Proton )
	p_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_Deuteron )
	d_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_Kaon )
	km_ID.push_back(cdstrackMan->GoodTrackID(it));
      
      if( pid<7 ) nTrack_PID++;

      //cerr<<"    pid = "<<pid<<", tof = "<<tmptof<<", beta = "<<beta_calc
      //<<", mom = "<<mom<<", mass = "<<sqrt(fabs(mass2))<<endl;

    }// for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){
    //** end of PID **//

    Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+d_ID.size()+pim_ID.size()+km_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_plus"),  pip_ID.size() );
    Tools::Fill1D( Form("ntrack_proton"),   p_ID.size() );
    Tools::Fill1D( Form("ntrack_deuteron"), d_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_minus"), pim_ID.size() );
    Tools::Fill1D( Form("ntrack_K_minus"),  km_ID.size() );


    //** charge request with BVC, CVC (TOF=CVC), & PC **//
    int nBVC = 0;
    int nCVC = 0;
    int nPC  = 0;
    for( int i=0; i<blMan->nBVC(); i++ ){
      if( blMan->BVC(i)->CheckRange() ) nBVC++;
    }
    for( int i=0; i<blMan->nTOF(); i++ ){
      if( blMan->TOF(i)->CheckRange() ) nCVC++;
    }
    for( int i=0; i<blMan->nPC(); i++ ){
      if( blMan->PC(i)->CheckRange() ) nPC++;
    }
    Tools::Fill1D( Form("mul_BVC"), nBVC );
    Tools::Fill1D( Form("mul_CVC"), nCVC );
    Tools::Fill1D( Form("mul_PC"),  nPC );
    bool chargedhit = false;
    if( nBVC && (nCVC || nPC) ) chargedhit = true;


    //** + + + + + + + + + + + **//
    //**  p p pi- pi- X event  **//
    //** + + + + + + + + + + + **//
    std::cerr<<"nGoodTrack = "<<cdstrackMan->nGoodTrack()<<" , flagbmom = "<<flagbmom
	     <<" , p_ID.size() = "<<p_ID.size()<<" , pim_ID.size() = "<<pim_ID.size()<<std::endl;
    if( flagbmom && p_ID.size()==2 && pim_ID.size()==2 &&
	cdstrackMan->nGoodTrack()==4 ){

      std::cerr<<"=== pppipi_event is filled ==="<<std::endl;
      nFill_pppipi++;

      //!!!!! at present stage, DCAs are not considered [20180402] !!!!!//
      TVector3 vtx_pL[2][2];  // Vertex(p1-pi1)_on_p1      
      TVector3 vtx_piL[2][2]; // Vertex(p1-pi1)_on_pi1
      TVector3 vtx_p[2][2];   // Vertex(baem-p2)_on_p2
      TVector3 vtx_pi[2][2];  // Vertex(baem-pi2)_on_pi2
      TVector3 vtx_L[2][2];   // Vertex(beam-(p1+pi1))_on_(p1+pi1)
      TVector3 vtxreac[2][2]; // Vertex(v(beam-p2)_on_beam-v(beam-pi2)_on_beam-v(beam-(p1+pi))_on_beam))_center
      TLorentzVector L_beam[2][2];  // 4-Momentum(beam)
      TLorentzVector L_pL[2][2];    // 4-Momentum(p_from_Lambda)
      TLorentzVector L_piL[2][2];   // 4-Momentum(pi_from_Lambda)
      TLorentzVector L_p[2][2];     // 4-Momentum(p)
      TLorentzVector L_pi[2][2];    // 4-Momentum(pi)
      TLorentzVector L_L[2][2];     // 4-Momentum(Lambda)
      TLorentzVector L_pmiss[2][2]; // 4-Momentum(p_missing)
      TLorentzVector mcL_beam[2][2];  // generated 4-Momentum(beam)
      TLorentzVector mcL_pL[2][2];    // generated 4-Momentum(p_from_Lambda)
      TLorentzVector mcL_piL[2][2];   // generated 4-Momentum(pi_from_Lambda)
      TLorentzVector mcL_p[2][2];     // generated 4-Momentum(p)
      TLorentzVector mcL_pi[2][2];    // generated 4-Momentum(pi)
      bool RinFid[2][2];     // reaction vertex in fiducial volume
      double KFchi2[2][2];   // chi2 of kinematical refit
      double KFNDF[2][2];    // NDF of kinematical refit
      double KFstatus[2][2]; // status of kinematical refit

      TLorentzVector TL_meas[2][2][7]; // measured
      TLorentzVector TL_kfit[2][2][7]; // kinematical fitted
      int genID[2][2][7];

      for( int x=0; x<2; x++ ){
	for( int y=0; y<2; y++ ){
	  RinFid[x][y] = false;
	  KFstatus[x][y] = -1;
	  for( int z=0; z<7; z++ ){ genID[x][y][z] = z; }
	}
      }

      for( int p1=0; p1<(int)p_ID.size(); p1++ ){ // loop for p
	for( int pi1=0; pi1<(int)pim_ID.size(); pi1++ ){ // loop for pim
	  //%%% set paramters %%%//
	  int p2  = (p1==0)? 1 : 0;
	  int pi2 = (pi1==0)? 1 : 0;
	  CDSTrack *track_p1  = cdstrackMan->Track( p_ID[p1] ); // L candidate
	  CDSTrack *track_p2  = cdstrackMan->Track( p_ID[p2] );
	  CDSTrack *track_pi1 = cdstrackMan->Track( pim_ID[pi1] ); // L candidate
	  CDSTrack *track_pi2 = cdstrackMan->Track( pim_ID[pi2] );

	  //%%% calc L -> p1 pi1 %%%//
	  if( !TrackTools::Calc2HelixVertex( track_p1, track_pi1, vtx_pL[p1][pi1], vtx_piL[p1][pi1] ) ){
	    std::cerr<<" !!! failure in vertex calculation [Calc2HelixVertex()] !!! "<<std::endl;
	    continue;
	  }
	  TVector3 P_p1;  // Momentum(p1)
	  TVector3 P_pi1; // Momentum(pi1)
	  TVector3 P_L;   // Momentum(L)
	  if( !track_p1->GetMomentum( vtx_pL[p1][pi1], P_p1, true, true ) ){
	    std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
	    continue;
	  }
	  if( !track_pi1->GetMomentum( vtx_piL[p1][pi1], P_pi1, true, true ) ){
	    std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
	    continue;
	  }
	  P_L = P_p1+P_pi1;
	  L_pL[p1][pi1].SetVectM( P_p1, pMass );
	  L_piL[p1][pi1].SetVectM( P_pi1, piMass );
	  L_L[p1][pi1] = L_pL[p1][pi1]+L_piL[p1][pi1];

	  //%%% calc beam - L %%%//
	  double dist_L, dltmp = 0;
	  TVector3 vtx_Lc = (vtx_pL[p1][pi1]+vtx_piL[p1][pi1])*0.5; // Vertex(p1-pi1)_center
	  TVector3 vtx_Lb; // Vertex(beam-(p1+pi1))_on_beam
	  MathTools::LineToLine( vtx_Lc, P_L.Unit(), bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), dltmp, dist_L, vtx_L[p1][pi1], vtx_Lb );

	  //%%% calc beam - p2 %%%//
	  TVector3 P_p2;  // Momentum(p2)
	  TVector3 vtx_p2b; // Vertex(baem-p2)_on_beam
	  track_p2->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_p2b, vtx_p[p1][pi1] );
	  if( !track_p2->GetMomentum( vtx_p[p1][pi1], P_p2, true, true ) ){
	    std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
	  }
	  L_p[p1][pi1].SetVectM( P_p2, pMass );

	  //%%% calc beam - pi2 %%%//
	  TVector3 P_pi2;  // Momentum(pi2)
	  TVector3 vtx_pi2b; // Vertex(baem-pi2)_on_beam
	  track_pi2->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_pi2b, vtx_pi[p1][pi1] );
	  if( !track_pi2->GetMomentum( vtx_pi[p1][pi1], P_pi2, true, true ) ){
	    std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
	  }
	  L_pi[p1][pi1].SetVectM( P_pi2, piMass );

	  //%%% calc reaction vertex on beam %%%//
	  vtxreac[p1][pi1] = (vtx_Lb+vtx_p2b+vtx_pi2b)*0.333333333;

	  //%%% energy loss correction of beam & reconstructoin of missing proton %%%//
#if 0 // for data analysis
	  double beamtof, momout;
	  double z_pos = -120;
	  ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), vtxreac[p1][pi1],
					 L3_beambf.Vect().Mag(), kpMass, momout, beamtof );
	  L_beam[p1][pi1].SetVectM( momout*L3_beambf.Vect().Unit(), kpMass );
#else // for MC
	  L_beam[p1][pi1] = L3_beam;
#endif
	  L_pmiss[p1][pi1] = L3_target+L_beam[p1][pi1]-L_pL[p1][pi1]-L_piL[p1][pi1]-L_p[p1][pi1]-L_pi[p1][pi1];

	  //%%% selection of vertex in fiducial volume (Yamaga's method)%%%//
	  if( GeomTools::GetID(vtx_Lb)==CID_Fiducial &&
	      GeomTools::GetID(vtx_p2b)==CID_Fiducial &&
	      GeomTools::GetID(vtx_pi2b)==CID_Fiducial ){
	    RinFid[p1][pi1] = true;
	  }
	  
	  if( !RinFid[p1][pi1] ){
	    continue;
	  }

	  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	  // %%% Kinematical Fit using KinFitter %%% //
	  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	  //--- set TLorentzVector for MC study---//
	  // beam_K(K+), pi-, L, p, p_miss, p from L, pi- from L
	  //  = TLorentzVector L_beam, L_pim, (L_pL+L_piL), L_p, L_pmiss, L_pL, L_piL
	  TL_meas[p1][pi1][0] = L_beam[p1][pi1];
	  TL_meas[p1][pi1][1] = L_pi[p1][pi1];    // * which pi?
	  TL_meas[p1][pi1][2] = L_L[p1][pi1];
	  TL_meas[p1][pi1][3] = L_p[p1][pi1];     // * which p?
	  TL_meas[p1][pi1][4] = L_pmiss[p1][pi1]; // * which p?
	  TL_meas[p1][pi1][5] = L_pL[p1][pi1];    // * which p?
	  TL_meas[p1][pi1][6] = L_piL[p1][pi1];   // * which pi?

	  int CDHhit_data[7] = {-1, -1, -1, -1, -1, -1, -1};
	  CDHhit_data[1] = track_pi2->CDHHit(cdsMan,0)->seg();
	  CDHhit_data[3] = track_p2->CDHHit(cdsMan,0)->seg();
	  CDHhit_data[5] = track_p1->CDHHit(cdsMan,0)->seg();
	  CDHhit_data[6] = track_pi1->CDHHit(cdsMan,0)->seg();
	  for( int x=0; x<7; x++ ){
	    for( int y=0; y<7; y++ ){
	      if( CDHhit_data[x]==CDHhit_mc[y] && CDHhit_data[x]!=-1 ){
		genID[p1][pi1][x] = y;
	      }
	    }
	  }
	  if( genID[p1][pi1][3]!=3 && genID[p1][pi1][5]!=3 ) genID[p1][pi1][4] = 3;
	  if( genID[p1][pi1][3]!=5 && genID[p1][pi1][5]!=5 ) genID[p1][pi1][4] = 5;

	  std::cerr<<"CDH_data : "; for( int x=0; x<7; x++ ){ std::cerr<<" "<<CDHhit_data[x];    } std::cerr<<std::endl; 
	  std::cerr<<"CDH_mc   : "; for( int x=0; x<7; x++ ){ std::cerr<<" "<<CDHhit_mc[x];      } std::cerr<<std::endl;
	  std::cerr<<"genID    : "; for( int x=0; x<7; x++ ){ std::cerr<<" "<<genID[p1][pi1][x]; } std::cerr<<std::endl; 

	  mcL_beam[p1][pi1] = TL_gene[0];
	  mcL_pi[p1][pi1]   = TL_gene[genID[p1][pi1][1]];
	  mcL_p[p1][pi1]    = TL_gene[genID[p1][pi1][3]];
	  mcL_pL[p1][pi1]   = TL_gene[genID[p1][pi1][5]];
	  mcL_piL[p1][pi1]  = TL_gene[genID[p1][pi1][6]];

	  // L3_target is defined as (0, 0, 0, M_3He)
	  TVector3 TV_target = L3_target.Vect();
	  TVector3 TV_meas[7];
	  for( int i=0; i<7; i++ ){
	    TV_meas[i] = TL_meas[p1][pi1][i].Vect();
	  }
		
	  //--- KinFitter :: initialization ---//
	  // = TLorentzVector L_beam, L_pi, (L_pL+L_piL), L_p, L_pmiss, L_pL, L_piL
	  //*** definition of fit particles in cartesian coordinates ***//
	  TString str_particle[7] = {"L_beam", "L_pi", "L_L", "L_p", "L_mp", "L_pL", "L_piL"};
	  TFitParticlePxPyPz ParticleTgt = TFitParticlePxPyPz("target", "target", &TV_target,
							      pdg->GetParticle("He3")->Mass(), covZero);
	  TFitParticlePxPyPz Particle[7];
	  for( int i=0; i<7; i++ ){
	    Particle[i] = TFitParticlePxPyPz(str_particle[i], str_particle[i], &TV_meas[i],
					     pdg->GetParticle(PDG[i])->Mass(), covParticle[i]);
	  }
	  //*** definition of constraints ***//
	  // constraint :: mass of Lambda
	  TFitConstraintM ConstMS = TFitConstraintM("M_L", "M_L", 0, 0, pdg->GetParticle(PDG[2])->Mass());
	  ConstMS.addParticles1(&Particle[5], &Particle[6]);
	  // constraint :: 4-momentum conservation
	  TFitConstraintEp ConstEp[4];
	  TString str_constEp[4]  = {"Px", "Py", "Pz", "E"};
	  for( int i=0; i<4; i++ ){
	    ConstEp[i] = TFitConstraintEp(str_constEp[i], str_constEp[i], 0, TFitConstraintEp::component(i), 0);
	    ConstEp[i].addParticles1(&ParticleTgt, &Particle[0]);
	    ConstEp[i].addParticles2(&Particle[1], &Particle[3], &Particle[4], &Particle[5], &Particle[6]);
	  }

	  //--- KinFitter :: execution ---//
	  //*** definition of the fitter ***//
	  TKinFitter kinfitter;
	  // add measured particles
	  kinfitter.addMeasParticles(&Particle[0], &Particle[1], &Particle[3], &Particle[5], &Particle[6]); // K, pi-, p, p, pi-
	  kinfitter.addUnmeasParticles(&Particle[4]); // missing-p
	  // add constraints
	  kinfitter.addConstraint(&ConstMS); // mass of Sigma+
	  for( int i=0; i<4; i++ ){
	    kinfitter.addConstraint(&ConstEp[i]); // 4-momentum conservation
	  }
	  //*** perform the fit ***//
	  kinfitter.setMaxNbIter(50);       // max number of iterations
	  kinfitter.setMaxDeltaS(5e-5);     // max delta chi2
	  kinfitter.setMaxF(1e-4);          // max sum of constraints
	  kinfitter.setVerbosity(KFDEBUG);  // verbosity level
	  kinfitter.fit();
	  //*** copy fit results ***//
	  for( int i=0; i<7; i++ ){
	    TL_kfit[p1][pi1][i] = (*Particle[i].getCurr4Vec());
	  }
	  TL_kfit[p1][pi1][2] = TL_kfit[p1][pi1][5]+TL_kfit[p1][pi1][6];

	  KFchi2[p1][pi1]   = kinfitter.getS();
	  KFNDF[p1][pi1]    = kinfitter.getNDF();
	  KFstatus[p1][pi1] = kinfitter.getStatus();

	  std::cerr<<p1<<" "<<pi1<<" || fit: status = "<<kinfitter.getStatus()
		   <<" chi2 = "<<kinfitter.getS()<<" NDF = "<<kinfitter.getNDF()<<std::endl;
	  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	  // %%% Kinematical Fit using KinFitter %%% //
	  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	}
      } // for( int p1=0; p1<(int)p_ID.size(); p1++ ){ // loop for p

      double chi2_min = 100000000;
      int p_KF  = -1;
      int pi_KF = -1;
      bool flagKF = false;
      for( int p1=0; p1<(int)p_ID.size(); p1++ ){ // loop for p
	for( int pi1=0; pi1<(int)pim_ID.size(); pi1++ ){ // loop for pim
	  if( KFstatus[p1][pi1]==0 && KFchi2[p1][pi1]<chi2_min ){
	    p_KF  = p1;
	    pi_KF = pi1;
	    chi2_min = KFchi2[p1][pi1];
	    flagKF = true;
	  }
	}
      }

      if( !flagKF ){
	nAbort_flagKF++;
	continue;
      }

      std::cerr<<" >>>> minimum chi2 combination is ("<<p_KF<<", "<<pi_KF<<"), chi2/N = "
	       <<KFchi2[p_KF][pi_KF]<<"/"<<KFNDF[p_KF][pi_KF]<<std::endl;

#if 1
      double mm_mass = L_pmiss[p_KF][pi_KF].M();
      double ppi_mass = (L_pL[p_KF][pi_KF]+L_piL[p_KF][pi_KF]).M();
      //--- for the covariance matrix evaluation ---//
      if( flagG4Decay ){
	if( proton_MIN<mm_mass && mm_mass<proton_MAX ){
	  if ( ppi_MIN< ppi_mass && ppi_mass<ppi_MAX ){
	    for( int i=0; i<7; i++ ){
	      for( int j=0; j<4; j++ ){
		double val = (TL_meas[p_KF][pi_KF][i][j] - TL_gene[genID[p_KF][pi_KF][i]][j]);
		Tools::Fill1D(Form("cov_%d_%d_%d", i, j, j), val);
		//if( j==k ) std::cerr<<" cov "<<i<<" , "<<j<<" = "<<TL_meas[p_KF][pi_KF][i][j]<<" - "<<TL_gene[i][j]
		//<<" = "<< (TL_meas[p_KF][pi_KF][i][j] - TL_gene[i][j])<<std::endl;
	      } // for( int i=0; i<7; i++ ){
	    }
	  }
	}
      }
#endif

      //** fill tree **//
      mom_beam   = L_beam[p_KF][pi_KF];
      mom_target = L3_target;
      mom_pimL   = L_piL[p_KF][pi_KF];
      mom_pim    = L_pi[p_KF][pi_KF];
      mom_pL     = L_pL[p_KF][pi_KF];
      mom_p      = L_p[p_KF][pi_KF];
      vtx_reaction = vtxreac[p_KF][pi_KF];
      run_num   = confMan->GetRunNumber(); // run number
      event_num = ev;     // event number
      block_num = 0;      // block number (temp)
      //
      kfmom_beam   = TL_kfit[p_KF][pi_KF][0];
      kfmom_pimL   = TL_kfit[p_KF][pi_KF][6];
      kfmom_pim    = TL_kfit[p_KF][pi_KF][1];
      kfmom_pL     = TL_kfit[p_KF][pi_KF][5];
      kfmom_p      = TL_kfit[p_KF][pi_KF][3];
      kf_chi2      = KFchi2[p_KF][pi_KF];
      kf_NDF       = KFNDF[p_KF][pi_KF];
      kf_status    = KFstatus[p_KF][pi_KF];
      kf_pvalue    = ROOT::Math::chisquared_cdf_c(kf_chi2, kf_NDF);
      kf_flag       = reactionID; //correct_flag;
      //
      mcmom_beam = TL_gene[0];
      mcmom_pimL = TL_gene[genID[p_KF][pi_KF][6]];
      mcmom_pim  = TL_gene[genID[p_KF][pi_KF][1]];
      mcmom_pL   = TL_gene[genID[p_KF][pi_KF][5]];
      mcmom_p    = TL_gene[genID[p_KF][pi_KF][3]];

      std::cout<<"%%% pipippp event: Event_Number, Block_Event_Number, CDC_Event_Number = "
	       <<ev<<" , "<<" ---, "<<ev_cdc<<std::endl;
      outfile2->cd();
      pipipppTree->Fill();
      outfile->cd();
      nFill_pipippp++;
      //** fill tree **//

      Tools::Fill1D( Form("KFstatus"), kf_status );
      Tools::Fill1D( Form("KFchi2"),   kf_chi2/kf_NDF );
      Tools::Fill1D( Form("KFpvalue"), kf_pvalue );
      
    } // if( flagbmom && p_ID.size()==2 && pim_ID.size()==2 &&
    else{
      nAbort_pppipi++;
    }
    
    nAbort_end++;
    delete detData2;
    
  } // for( int ev=0; ev<exen; ev++ ){
  
  cout<<"===== Lambda p n reconstruction in MC END ====="<<endl;
  cout<<" nEvent       = "<<exen<<endl;
  cout<<" nEvent_Lp    = "<<nEvent_Lp<<endl;
  cout<<" nEvent_Lpn   = "<<nEvent_Lpn<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nG4Event_piSpn  = "<<nG4Event_piSpn<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" AllGoodTrack = "<<AllGoodTrack<<endl;
  cout<<" nTrack       = "<<nTrack<<endl;
  cout<<" nTrack_PID   = "<<nTrack_PID<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nAbort_nGoodTrack = "<<nAbort_nGoodTrack<<endl;
  cout<<" nAbort_nCDH       = "<<nAbort_nCDH<<endl;
  cout<<" nAbort_nT0        = "<<nAbort_nT0<<endl;
  cout<<" nAbort_nbpc       = "<<nAbort_nbpc<<endl;
  cout<<" nAbort_bpctrack   = "<<nAbort_bpctrack<<endl;
  cout<<" nAbort_nblc2      = "<<nAbort_nblc2<<endl;
  cout<<" nAbort_fblc2bpc   = "<<nAbort_fblc2bpc<<endl;
  cout<<" nAbort_flagbmom   = "<<nAbort_flagbmom<<endl;
  cout<<" nAbort_flagKF     = "<<nAbort_flagKF<<endl;
  cout<<" nAbort_pppipi     = "<<nAbort_pppipi<<std::endl;
  cout<<" nAbort_end        = "<<nAbort_end<<std::endl;
  cout<<"***********************************************"<<endl;
  cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<endl;
  cout<<"*** # of pi- pi- p p X events = "<<nFill_pipippp<<" ***"<<std::endl;
  cout<<"==============================================="<<endl;

  outfile->Write();
  outfile->Close();

  outfile2->Write();
  outfile2->Close();

  simfile->Close();
  cdcfile->Close();

  delete pdg;

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}
