//----------------------------------------------------------------//
// H.Asano Aug.8th, 2018
// UserSimIMPiSigma.cpp 
// originated from UserSimpipipnn.cpp 
// 
// the purpose is to reconstruct pi S n event in d(K^-,n) reaction
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// reconstruction method is based on "EventAnalysis_pipipnn_sakuma.cpp"
//----------------------------------------------------------------//
//  exe-file: simIMpisigma [./simIMpisigma $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: when $(OutFile) is "tmp.root", the following 2 files are generated.
//     "tmp.root":      histogram file
//     "tmp_pipipnn.root": basic information of pippimn event is listed up in TTree 
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"

#include <TLorentzVector.h>
#include "TrackTools.h"
#include "EventHeader.h"
#include "Tools.h"
#include "ELossTools.h"

#include "IMPiSigmaAnaPar.h"
#include "IMPiSigmaHist.h"
#include "IMPiSigmaUtil.h"

#include <TDatabasePDG.h>
#include <KinFitter/TKinFitter.h>
#include <KinFitter/TFitParticlePxPyPz.h>
#include <KinFitter/TFitConstraintM.h>
#include <KinFitter/TFitConstraintEp.h>
#include <Math/ProbFuncMathCore.h>



#define KFDEBUG 0 // verbose level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices
int Verbosity_ = 0;
const bool DoCDCRetiming = false;
const double MOM_RES = 2.0; // MeV/c
const bool IsVtxDoubleCheck = false;
const bool UseDecayVtx = true;
const bool IsolationCutFlag = 1;
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)

//** cut parameters **//
double PARA_blc2bpc_dx_MIN;
double PARA_blc2bpc_dx_MAX;
double PARA_blc2bpc_dy_MIN;
double PARA_blc2bpc_dy_MAX;
double PARA_blc2bpc_dxdz_MIN;
double PARA_blc2bpc_dxdz_MAX;
double PARA_blc2bpc_dydz_MIN;
double PARA_blc2bpc_dydz_MAX;
double PARA_lnL_MAX;
double PARA_MM_LP_MIN;
double PARA_MM_LP_MAX;

const double ADC_CDH_MIN = 1;  // MeV

//= = = = pippimn final-sample tree = = = =//
TLorentzVector mom_beam;   // 4-momentum(beam)
TLorentzVector mom_beam_Sp;   // 4-momentum(beam)
TLorentzVector mom_beam_Sm;   // 4-momentum(beam)
TLorentzVector mom_target; // 4-momentum(target)
TLorentzVector mom_pip;    // 4-momentum(pi+)
TLorentzVector mom_pim;    // 4-momentum(pi-)
TLorentzVector mom_n;      // 4-momentum(neutron)
TLorentzVector mom_n_Sp;      // 4-momentum(neutron)
TLorentzVector mom_n_Sm;      // 4-momentum(neutron)
double NeutralBetaCDH; // veracity of neutral particle on CDH
double NeutralBetaCDH_vtx[2]; // veracity of neutral particle on CDH
double dE;   // energy deposit on CDH
int neutralseg;   // energy deposit on CDH
TVector3 vtx_reaction; //  vertex(reaction)   
TVector3 vtx_pip_beam; //  
TVector3 vtx_pim_beam; //   
TVector3 vtx_pip_cdc;
TVector3 vtx_pim_cdc;
TVector3 CA_pip;
TVector3 CA_pim;
TVector3 CDH_Pos;
int run_num;   // run number
int event_num; // event number
int block_num; // block number
int mc_nparticle;

//GEANT4 info after decay, interaction with detector, momentum is true
TLorentzVector mcmom_beam;  // generated 4-momentum(beam)
TLorentzVector mcmom_pip;   // generated 4-momentum(pi+)
TLorentzVector mcmom_pim;   // generated 4-momentum(pi-)
TLorentzVector mcmom_ncds;    // generated 4-momentum(neutron)
TLorentzVector mcmom_nmiss;    // generated 4-momentum(neutron)


//GEANT4 info generated particle before interaction
TLorentzVector react_nmiss;
TLorentzVector react_Sigma;//Sigma+ or Simga -
TLorentzVector react_pi;//pi- or pi +


TVector3 mc_vtx;
TLorentzVector kfMomBeamSpmode;   // 4-momentum(beam) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_pip_Spmode;    // 4-momentum(pi+) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_pim_Spmode;    // 4-momentum(pi-) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_n_Spmode;      // 4-momentum(neutron) after kinematical refit for pi- Sigma+
double kf_chi2_Spmode;   // chi2 of kinematical refit
double kf_NDF_Spmode;    // NDF of kinematical refit
double kf_status_Spmode; // status of kinematical refit -> details can be found in this code
double kf_pvalue_Spmode; // p-value of kinematical refit
TLorentzVector kfMomBeamSmmode;   // 4-momentum(beam) after kinematical refit for pi+ Sigma-
TLorentzVector kfMom_pip_Smmode;    // 4-momentum(pi+) after kinematical refit for pi+ Sigma-
TLorentzVector kfMom_pim_Smmode;    // 4-momentum(pi-) after kinematical refit for pi+ Sigma-
TLorentzVector kfMom_n_Smmode;      // 4-momentum(neutron) after kinematical refit for pi+ Sigma-
double kf_chi2_Smmode;   // chi2 of kinematical refit
double kf_NDF_Smmode;    // NDF of kinematical refit
double kf_status_Smmode; // status of kinematical refit -> details can be found in this code
double kf_pvalue_Smmode; // p-value of kinematical refit
int kf_flag; // flag of correct pair reconstruction, etc
//= = = = pippimn final-sample tree = = = =//


void InitializeHistogram();
void InitTreeVal();

int main( int argc, char** argv )
{
  if( argc!=5 ){
    std::cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<std::endl;
    return 0;
  }
  

  std::cout <<"L." << __LINE__ << " MOM_RES beam line: " << MOM_RES << std::endl;
  std::cout <<"L." << __LINE__ << " TDC_CDH_MAX: " << cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset << std::endl;
  std::cout << " Double Check VTX fid cut ? " ;
  if(IsVtxDoubleCheck) std::cout << " Yes" << std::endl;
  else         std::cout << " No"  << std::endl;
  
  std::cout << "Isolation cut range ? " ;
  std::cout << IsolationCutFlag <<  " segments" << std::endl;

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");
  //pdg->Print();
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//
  // ### obtained from (p_meas[j]-p_gene[j])
  // ###  using G4-data with TH1F(Form("cov_%d_%d_%d", i, j, j), 100, -cov_MAX, cov_MAX);
  // ###  and evaluated using "Air" Dora MC
  // 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
  
  std::cout << "L." << __LINE__ << " cov. matrix for S+ mode" << std::endl;
  for(int ip=0;ip<kin::npart;ip++){
    for(int im=0;im<16;im++){
      std::cout << kin::covValSpmode[ip][im] << " ";
      if(im==3 || im==7 || im==11 || im==15){
        std::cout << std::endl;
      }
    }
    std::cout << std::endl;
  }
  std::cout << "L." << __LINE__ << " cov. matrix for S- mode" << std::endl;
  for(int ip=0;ip<kin::npart;ip++){
    for(int im=0;im<16;im++){
      std::cout << kin::covValSmmode[ip][im] << " ";
      if(im==3 || im==7 || im==11 || im==15){
        std::cout << std::endl;
      }
    }
    std::cout << std::endl;
  }

  TMatrixD *covZero = new TMatrixD(4, 4);
  covZero->Zero();
  covZero->ResizeTo(3, 3); // resize from 4x4 to 3x3
  TMatrixD *covParticleSpmode[kin::npart];
  TMatrixD *covParticleSmmode[kin::npart];
  for( int ip=0; ip<kin::npart; ip++ ){
    covParticleSpmode[ip] = new TMatrixD(4, 4);
    covParticleSmmode[ip] = new TMatrixD(4, 4);
    int n = 0;
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( j==k ){
	  (*covParticleSpmode[ip])[j][k] = kin::covValSpmode[ip][n]; // only diagonal elements
	  (*covParticleSmmode[ip])[j][k] = kin::covValSmmode[ip][n]; // only diagonal elements
	} else{
	  (*covParticleSpmode[ip])[j][k] = 0;
	  (*covParticleSmmode[ip])[j][k] = 0;
	}
	n++;
      }
    }
    covParticleSpmode[ip]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticleSmmode[ip]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticleSpmode[ip]->Print(); // Print all
    covParticleSmmode[ip]->Print(); // Print all
  }
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//


  //** Conf file open **// 
  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  //** Simulation file open **// 
  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  //** Getting CDSTracking info. from CDCfile **//
  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
  EventHeader      *header = new EventHeader();
  evTree->SetBranchAddress("EventHeader", &header );
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan  = new BeamLineTrackMan();
  CDSTrackingMan   *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  //** output file 1 : histograms **//
  TFile *outfile = new TFile(argv[2], "recreate");
  //outfile->cd();
  //check seed distribution
  if( tree2->GetEntries()==1 ){
    std::cout<<"  !!! tree2 entries==1 !!!"<<std::endl;
    tree2->GetEntry(0);
    std::cout << runHeader->seed() << std::endl;
    Tools::H1("Seed",runHeader->seed(),10000,0,10000);
  }

  //** output file 2 : pippimn final-sample tree **// 
  std::string outfile2_name = string(argv[2]);
  outfile2_name.insert( outfile2_name.size()-5, "_pippimn" );
  std::cout<<"pippimn file "<<outfile2_name<<std::endl;
  TFile *outfile2 = new TFile( outfile2_name.c_str(), "recreate" );
  outfile2->cd();
  TTree *npippimTree = new TTree( "EventTree", "EventTree" );
  npippimTree->Branch( "mom_beam",   &mom_beam );//
  npippimTree->Branch( "mom_beam_Sp",  &mom_beam_Sp );//
  npippimTree->Branch( "mom_beam_Sm",  &mom_beam_Sm );
  npippimTree->Branch( "mom_target", &mom_target );
  npippimTree->Branch( "mom_pip", &mom_pip );
  npippimTree->Branch( "mom_pim", &mom_pim );
  npippimTree->Branch( "mom_n", &mom_n );
  npippimTree->Branch( "mom_n_Sp", &mom_n_Sp );
  npippimTree->Branch( "mom_n_Sm", &mom_n_Sm );
  npippimTree->Branch( "NeutralBetaCDH", &NeutralBetaCDH );
  npippimTree->Branch( "NeutralBetaCDH_vtx[2]", NeutralBetaCDH_vtx);
  npippimTree->Branch( "dE", &dE );
  npippimTree->Branch( "neutralseg", &neutralseg );
  npippimTree->Branch( "vtx_reaction", &vtx_reaction );
  npippimTree->Branch( "vtx_pip_beam", &vtx_pip_beam );
  npippimTree->Branch( "vtx_pim_beam", &vtx_pim_beam );
  npippimTree->Branch( "vtx_pip_cdc", &vtx_pip_cdc );
  npippimTree->Branch( "vtx_pim_cdc", &vtx_pim_cdc );
  npippimTree->Branch( "CA_pip",&CA_pip);
  npippimTree->Branch( "CA_pim",&CA_pim);
  npippimTree->Branch( "CDH_Pos",&CDH_Pos);
  //npippimTree->Branch( "run_num", &run_num );
  //npippimTree->Branch( "event_num", &event_num );
  //npippimTree->Branch( "block_num", &block_num );
  //npippimTree->Branch( "mc_nparticle",   &mc_nparticle );
  npippimTree->Branch( "mcmom_beam",   &mcmom_beam );
  npippimTree->Branch( "mcmom_pip", &mcmom_pip );
  npippimTree->Branch( "mcmom_pim", &mcmom_pim );
  npippimTree->Branch( "mcmom_ncds", &mcmom_ncds );
  npippimTree->Branch( "mcmom_nmiss", &mcmom_nmiss );
  npippimTree->Branch( "react_nmiss",&react_nmiss);
  npippimTree->Branch( "react_Sigma",&react_Sigma);
  npippimTree->Branch( "react_pi",&react_pi);
  npippimTree->Branch( "mc_vtx", &mc_vtx );
  npippimTree->Branch( "kfSpmode_mom_beam",   &kfMomBeamSpmode );
  npippimTree->Branch( "kfSpmode_mom_pip", &kfMom_pip_Spmode );
  npippimTree->Branch( "kfSpmode_mom_pim", &kfMom_pim_Spmode );
  npippimTree->Branch( "kfSpmode_mom_n", &kfMom_n_Spmode );
  npippimTree->Branch( "kfSpmode_chi2", &kf_chi2_Spmode );
  npippimTree->Branch( "kfSpmode_NDF", &kf_NDF_Spmode );
  npippimTree->Branch( "kfSpmode_status", &kf_status_Spmode );
  npippimTree->Branch( "kfSpmode_pvalue", &kf_pvalue_Spmode );
  npippimTree->Branch( "kfSmmode_mom_beam",   &kfMomBeamSmmode );
  npippimTree->Branch( "kfSmmode_mom_pip", &kfMom_pip_Smmode );
  npippimTree->Branch( "kfSmmode_mom_pim", &kfMom_pim_Smmode );
  npippimTree->Branch( "kfSmmode_mom_n", &kfMom_n_Smmode );
  npippimTree->Branch( "kfSmmode_chi2", &kf_chi2_Smmode );
  npippimTree->Branch( "kfSmmode_NDF", &kf_NDF_Smmode );
  npippimTree->Branch( "kfSmmode_status", &kf_status_Smmode );
  npippimTree->Branch( "kfSmmode_pvalue", &kf_pvalue_Smmode );
  npippimTree->Branch( "kf_flag", &kf_flag );
  outfile->cd();



  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    //return 0;
  }

  InitializeHistogram();


  //*** for kinematical fit ***//
  // beam_K(K+), pi-/+, Sigma+/-, forward n, n from S, pi+/- from S
  // !!! only diagonal components !!!
  const int BIN = 4000;
  double cov_MAX;
  for( int ip=0; ip<kin::npart+1; ip++ ){
    for( int ii=0; ii <4; ii++ ){
      for( int jj=0; jj<4; jj++ ){
        cov_MAX = 0.4;
        Tools::newTH1F(Form("cov_%d_%d_%d", ip, ii, jj), BIN, -cov_MAX, cov_MAX);
        Tools::newTH2F(Form("cov_mom_%d_%d_%d", ip, ii, jj), 500., -cov_MAX, cov_MAX,200,0,2.0);
      }
    }
  }//for ip


  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  std::cout<<"=====Sigma pi reconstruction in MC START ============="<<std::endl;
  std::cout<<"     # of All  Event in EventTree:     "<<eventn<<std::endl;
  std::cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<std::endl;
  std::cout<<"     # of Exe  Event in this program:  "<<exen<<std::endl;
  std::cout<<"========================================================="<<std::endl;

  //** set cut parameters **//
  PARA_blc2bpc_dx_MIN = -0.75;
  PARA_blc2bpc_dx_MAX = 0.75;
  PARA_blc2bpc_dy_MIN = -0.75;
  PARA_blc2bpc_dy_MAX = 0.75;
  PARA_blc2bpc_dxdz_MIN = -0.02;
  PARA_blc2bpc_dxdz_MAX = 0.02;
  PARA_blc2bpc_dydz_MIN = -0.02;
  PARA_blc2bpc_dydz_MAX = 0.02;
  PARA_lnL_MAX = 9.95;

  PARA_MM_LP_MIN = 0.85;
  PARA_MM_LP_MAX = 1.03;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;

  int nG4Event_piSigma   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_CDSPID = 0;
  int nAbort_nCDH = 0;
  int nAbort_nT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_ftarget = 0;
  int nAbort_CDHiso = 0;
  int nAbort_pippim = 0;
  int nAbort_anothern = 0;
  int nAbort_end = 0;
  bool IsncdsfromSigma = true;
  
  int nFill_pippim = 0;
  int nFill_pippimn = 0;

  int nTrack_CDHshare = 0;

  int ev_cdc = 0;

  //=== event loop ===//
  for( int iev=0; iev<exen; iev++ ){
    
    //clean up 
    InitTreeVal();
    bool IsrecoPassed=true;
    if(Verbosity_){
      std::cout<<"> Event Number "<<iev<<std::endl;
    }else if( /*iev<100 ||*/ iev%1000==0 ){
      std::cout<<"> Event Number "<< iev <<std::endl;
    }
    Tools::Fill1D( Form("EventCheck"), 1 );

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(iev); // MC
    evTree->GetEntry(ev_cdc); // CDC-tracking
    
    //### event ID matching
    if( evHeaderMC->eventID()!=header->ev() ){
      std::cout << "event ID mismatch !!"  << std::endl;
      std::cout << "evHeaderMC: " << evHeaderMC->eventID() << std::endl;
      std::cout << "header:     " << header->ev()  << std::endl;
      continue;
    }
    ev_cdc++;

    //### CDH ADC cut ###//
    double discri[36]={
      2.85,
      2.45,
      2.15,
      2.05,
      1.75,
      2.25,
      2.15,
      2.15,
      2.15,
      1.95,
      1.85,
      1.95,
      2.15,
      2.15,
      1.85,
      1.95,
      1.95,
      2.05,
      1.85,
      1.95,
      2.15,
      2.55,
      1.75,
      1.95,
      1.85,
      2.05,
      2.05,
      1.95,
      2.05,
      2.05,
      1.85,
      2.15,
      1.85,
      2.05,
      1.85,
      2.15
    };

    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ){
      if( !((detData->detectorHit(i)->detectorID()==CID_CDH) && (detData->detectorHit(i)->adc()<discri[detData->detectorHit(i)->channelID()])) ){
        detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }

    simMan->Convert(detData2, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);
    bltrackMan->DoTracking(blMan, confMan, true, true);


    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4Decay = false;
    bool piSigma_detect = false;
    //int pi_parent  = 0;
    //int Y_parent  = 0;
    //int N_parent  = 0;
    if(Verbosity_){
      std::cout<<"======================"<<std::endl;
      std::cout<<std::endl;
      std::cout<<"particle size :" <<   reacData->ParticleSize() << std::endl;
      for( int ip=0; ip<reacData->ParticleSize(); ip++ ){
        std::cout<< "L." << __LINE__ << " " 
          << ip<<" pdg code:"<<reacData->PDG(ip)<<" mom:"<<reacData->GetParticle(ip).P()
          <<std::endl;
      }
    }
    //reaction data (=generated particle info.)
    Util::AnaReactionData(reacData);
    
    react_nmiss = reacData->GetParticle(0);
    react_Sigma = reacData->GetParticle(1);
    react_pi = reacData->GetParticle(2);

    const int reactionID = reacData->ReactionID();
    //These partcile IDs are defined in pythia6
    //see http://home.fnal.gov/~mrenna/lutp0613man2/node44.html
    //
    //Here, K+ is used as beam particle because every particle is emitted from the target volume in GEANT simulation
    //                             K+    pi-  S+  nmiss  ncds    pi+  //
    const int PDG_Spmode[kin::npart] = {321, -211, 3222, 2112, 2112,  211}; // pi-Sigma+
    //                             K+    pi+  S-  nmiss  ncds    pi-
    const int PDG_Smmode[kin::npart] = {321,  211, 3112, 2112, 2112, -211}; // pi+Sigma-
    int PDG[kin::npart] = {0, 0, 0, 0, 0, 0};
    for( int i=0; i<kin::npart; i++ ){
      if( reactionID==gen::reactionID_Spmode ){
        PDG[i] = PDG_Spmode[i];
        if(Verbosity_)std::cout << "L." << __LINE__ << " This is Sigma+ mode sim. " << std::endl;
      }
      else if( reactionID==gen::reactionID_Smmode ){
        PDG[i] = PDG_Smmode[i];
        if(Verbosity_)std::cout << "L." << __LINE__ << " This is Sigma- mode sim. " << std::endl;
      }
    }

    //  beam_K(K-), prompt pi, Sigma, nmiss, n from Sigma, pi from Sigma
    //  0: init. val. for prompt particles , -1:init. val. for decay particles            
    int parentID[kin::npart] = {0, 0, 0, 0, -1, -1}; 
    // IDs defined by imctrk which is the serial number in mcData class
    int ID[kin::npart]       = {-1, -1, -1, -1, -1, -1}; 
    // track ID assigned in mcData class
    int trackID[kin::npart]  = {-1, -1, -1, -1, -1, -1}; 
    int nparticle = 0;
    
    if(Verbosity_){
      std::cout<< std::endl;
      std::cout<< "L." << __LINE__ << "loop over track Size:" << mcData->trackSize() 
      << std::endl;
      std::cout<< std::endl;
    }

    for( int imctrk=0; imctrk<mcData->trackSize(); imctrk++ ){
      //pdg ID
      const int pdgcode = mcData->track(imctrk)->pdgID();
      //parent track ID, if it is primary particle, 0
      const int parent  = mcData->track(imctrk)->parentTrackID();
      //track ID
      const int track   = mcData->track(imctrk)->trackID();
      const double mom  = mcData->track(imctrk)->momentum().Mag();
      const TVector3 vec_vertex = mcData->track(imctrk)->vertex();
      //This is flight length which is calcuted only when the track reaches to the CDH 
      double flightlength = mcData->track(imctrk)->FlightLength();
      if(Verbosity_){
        std::cout<<"imctrk:" << imctrk<<" | "<< "pdgcode:" << pdgcode<< std::endl;
        std::cout<<"parent_trkID:"<<  parent << std::endl;
        std::cout<<"trackID:"<<track<< std::endl;
        std::cout<<"mom:" << mom << std::endl;
        std::cout<<"vertex R: " << vec_vertex.Perp() << std::endl;
        std::cout<<"vertex Z: " << vec_vertex.Z() << std::endl;
        std::cout<<"flight length:" << flightlength << std::endl;
      }
      for( int ip=0; ip<kin::npart; ip++ ){ 
        //   pick up necessary particles stored in PDG[] array.
        //   if it is primary particle ,parentID is 0, decay particles are rejected by the parentID selection
        if( pdgcode==PDG[ip] && parent==parentID[ip] && ID[ip]==-1 ){
          ID[ip] = imctrk;
          trackID[ip] = track;
          nparticle++;
          if(Verbosity_){
            std::cout<<"ip:" << ip<<" | "<<pdgcode<<" "<<parent<<" "<<track<<" "<<mcData->track(imctrk)->momentum().Mag()
              <<" ("<<mcData->track(imctrk)->momentum().CosTheta()<<" , "<<mcData->track(imctrk)->momentum().Phi()*360./TwoPi<<")"<<std::endl;
          }
          
          //assign parent IDs for netron and pi+/- from Sigma+/- 
          if( ip==kin::Sp || ip==kin::Sm){ //Sp and Sm are same.
            parentID[kin::ncds] = track;
            parentID[kin::pip_g2] = track;//pip_g2 and pim_g2 are same.
            if(Verbosity_){
              std::cout << "parentID n  from Sigma:" << parentID[kin::ncds] << std::endl;
              std::cout << "parentID pi from Sigma:" << parentID[kin::pip_g2] << std::endl;
            }
          }
          break;
        }//if 
      }//for ip
    }//for imctrk

    if( nparticle==kin::npart ) { 
      flagG4Decay = true;
    
      if(Verbosity_) std::cout << "L." << __LINE__ << " flagG4Decay OK " << std::endl;
    }else{
      if(Verbosity_) std::cout << "L." <<  __LINE__ << " nparticle " << nparticle << std::endl;
    }

    

    //actually not used ?
    //std::cout << "ievt " << iev << std::endl;
    int nCDHhit[kin::npart] = {0, 0, 0, 0, 0, 0};
    if( flagG4Decay ){ // Sigma -> n pi decay
      for( int ihit=0; ihit<detData2->detectorHitSize(); ihit++ ){
        int cid    = detData2->detectorHit(ihit)->detectorID();
        int track  = detData2->detectorHit(ihit)->trackID();
        int parent = mcData->track(ihit)->parentTrackID();
        for( int ip=1; ip<kin::npart; ip++ ){// ip=0: beam (K-) is not included  
          //std::cout << "L." << __LINE__ << " sim IP:" <<  ip << std::endl;
          //std::cout << "L." << __LINE__ << " CID:" << cid << std::endl;
          //std::cout << "L." << __LINE__ << " track:" << track << std::endl;
          //std::cout << "L." << __LINE__ << " trackID[ip]:" << trackID[ip] << std::endl;
          //std::cout << "L." << __LINE__ << " parent:" << parent << std::endl;
          if( cid==CID_CDH && track==trackID[ip] ){
            //std::cout << "match " << std::endl;
            nCDHhit[ip]++;
          }
        }
        //*** neutron hit search ***//
        //scan ncds and pip/pim from Sigma 
        for( int ip=4; ip<kin::npart; ip++ ){
          //std::cout << "L." << __LINE__ << " sim IP:" <<  ip << std::endl;
          //std::cout << "L." << __LINE__ << " parent:" << parent << std::endl;
          //std::cout << "L." << __LINE__ << " trackID[ip]:" << trackID[ip] << std::endl;
          if( cid==CID_CDH && parent==trackID[ip] ){
            //std::cout << "match " << std::endl;
            nCDHhit[ip]++;
          }
        }
        //*** neutron hit search ***//
      }//ihit
    }//flagG4Decay

    //determine whether pi-Sigma is detected in the CDS
    //actually, not used so far (Jan.22,2019 asano)
    //pim_g1 = pip_g1 pip_g2 = pim_g2
    //not working right now.
    if( nCDHhit[kin::pim_g1] && nCDHhit[kin::ncds] && nCDHhit[kin::pip_g2] ){ 
      //std::cout << "allmatch " << std::endl;
      piSigma_detect = true;
      nG4Event_piSigma++;
    }

    
    // beam_K(K+), pi, Y, N, N from Sigma, pi from Sigma
    // beam particle is emitted from the target
    TLorentzVector TL_gene[kin::npart]; // generated
    for( int ip=0; ip<kin::npart; ip++ ){
      if( ip ) TL_gene[ip].SetVectM(mcData->track(ID[ip])->momentum()*0.001,  pdg->GetParticle(PDG[ip])->Mass()); // GeV
      else    TL_gene[ip].SetVectM(mcData->track(ID[ip])->momentum()*-0.001, pdg->GetParticle(PDG[ip])->Mass()); // GeV
    }
    int genID[kin::npart] = {0,1,2,3,4,5};
    mcmom_beam = TL_gene[kin::kmbeam];
    //std::cout << mcmom_beam.P() << std::endl;
    //std::cout << mcmom_beam.M() << std::endl;
    /*
    mcmom_beam = TL_gene[kin::kmbeam];
    mcmom_ncds = TL_gene[genID[kin::ncds]];
    mcmom_nmiss = TL_gene[genID[kin::nmiss]];
    
    if( reactionID==gen::reactionID_Spmode ){
      TLorentzVector mcmom_ncdspi = TL_gene[kin::ncds]+TL_gene[kin::pip_g2];
      TLorentzVector mcmom_nmisspi = TL_gene[kin::nmiss]+TL_gene[kin::pip_g2];
      if( fabs(mcmom_ncdspi.M()-spMass)>fabs(mcmom_nmisspi.M()-spMass)){
        genID[kin::nmiss] = kin::ncds;
        genID[kin::ncds] = kin::nmiss;
      }
      std::cout << __LINE__  << std::endl;
      std::cout << mcmom_ncdspi.M() << std::endl;
      std::cout << mcmom_nmisspi.M() << std::endl;
      mcmom_ncds = TL_gene[genID[kin::ncds]];
      mcmom_nmiss = TL_gene[genID[kin::nmiss]];
      mcmom_pip  = TL_gene[kin::pip_g2];
      mcmom_pim  = TL_gene[kin::pim_g1];
    } else if ( reactionID==gen::reactionID_Smmode ){
      TLorentzVector mcmom_ncdspi = TL_gene[kin::ncds]+TL_gene[kin::pim_g2];
      TLorentzVector mcmom_nmisspi = TL_gene[kin::nmiss]+TL_gene[kin::pim_g2];
      if( fabs(mcmom_ncdspi.M()-smMass)>fabs(mcmom_nmisspi.M()-smMass)){
        genID[kin::nmiss] = kin::ncds;
        genID[kin::ncds] = kin::nmiss;
      }
      mcmom_ncds = TL_gene[genID[kin::ncds]];
      mcmom_nmiss = TL_gene[genID[kin::nmiss]];
      mcmom_pip  = TL_gene[kin::pip_g1];
      mcmom_pim  = TL_gene[kin::pim_g2];
    }
    */


    /*
    if(flagG4Decay){
      double q = (TL_gene[kin::kmbeam].Vect()-TL_gene[kin::nmiss].Vect()).Mag();
      TLorentzVector TL_Sigma_cor;// define to evaluate energy loss effect of Sigma
      TLorentzVector TL_piSigma;// 
      TLorentzVector TL_piSigma_cor;//
      if(reactionID == gen::reactionID_Spmode){
        TL_Sigma_cor = TL_gene[kin::ncds]+TL_gene[kin::pip_g2]; 
        TL_piSigma = TL_gene[kin::Sp]+TL_gene[kin::pim_g1];
        TL_piSigma_cor = TL_Sigma_cor + TL_gene[kin::pim_g1];
        //Tools::H2("q_IMpin_gen",TL_Sigma_cor.M(), q,100,1,2,300,0,1.5);
        //Tools::H1("IMpiSigma_gen",TL_piSigma.M(), 1000,1,2);
        //Tools::H2("q_IMpiSigma_cor_gen",TL_piSigma_cor.M(), q,100,1,2,300,0,1.5);
      }else if(reactionID == gen::reactionID_Smmode){
        TL_Sigma_cor = TL_gene[kin::ncds]+TL_gene[kin::pim_g2];
        TL_piSigma = TL_gene[kin::Sm]+TL_gene[kin::pip_g1];
        TL_piSigma_cor = TL_Sigma_cor + TL_gene[kin::pip_g1];
        //Tools::H2("q_IMpin_gen",TL_Sigma_cor.M(), q,100,1,2,300,0,1.5);
        //Tools::H1("IMpiSigma_gen",TL_piSigma.M(), 1000,1,2);
        //Tools::H2("q_IMpiSigma_cor_gen",TL_piSigma_cor.M(), q,100,1,2,300,0,1.5);
      }else{
        std::cout << "L." << __LINE__ << " input file must be wrong ! " << std::endl;
        std::cout << "reactionID " <<  reactionID << std::endl;
      }
    }*/

    //##########################//
    //### get G4 information ###//
    //##########################//


    const int nGoodTrack = cdstrackMan->nGoodTrack();
    const int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;
    Tools::Fill1D( Form("nGoodTrack"), nGoodTrack );
    Tools::Fill1D( Form("nTrack"),nallTrack);
    if(nGoodTrack==2){
      Tools::Fill1D( Form("nTrack_If2GoodTracks"),nallTrack);
    }
    
    
    if( Util::GetCDHMul(cdsMan,nGoodTrack,true)!=cdscuts::cdhmulti ){
      if(IsrecoPassed)nAbort_nCDH++;
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nCDH" << std::endl;
      //continue;
      IsrecoPassed=false;
    }

    //if( nGoodTrack!=cdscuts::cds_ngoodtrack ){ // dedicated for pi+ pi- event
    if( nGoodTrack!=cdscuts::cds_ngoodtrack && nallTrack!=cdscuts::cds_ngoodtrack ){ // dedicated for pi+ pi- event
      if(IsrecoPassed)nAbort_nGoodTrack++;
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nGoodTrack" << std::endl;
      //continue;
      IsrecoPassed=false;
    }
    
    //beam line analysis and event selection

    //** T0 = 1hit selection **//
    int t0seg=-1;
    const double ctmT0 = Util::AnalyzeT0(blMan,confMan,t0seg);
    if(ctmT0<-9000){
      if(IsrecoPassed) nAbort_nT0++;
      Tools::Fill1D( Form("EventCheck"), 15 );
      //continue;
      IsrecoPassed=false;
    }

    //** BPC track selection **//
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ){
      nbpc++;
      bpcid = i;
    }
    Tools::Fill1D( Form("ntrack_BPC"), nbpc );
    if( nbpc!=1 ){
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nbpc" << std::endl;
      if(IsrecoPassed)nAbort_nbpc++;
      //continue;
      IsrecoPassed=false;
    }
    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);    
    if(IsrecoPassed && bpctrack->chi2all()>10 ){
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_bpctrack" << std::endl;
      nAbort_bpctrack++;
      //continue;
      IsrecoPassed=false;
    }

    // vertex calculation //
    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ){
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }

    //** vectors for PID container **//
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    //std::vector <int> d_ID;
    

    bool flagbmom = false;
    TVector3 vtx_react;

    //** BLC2 track **//
    int nblc2 = 0;
    int blc2id = -1;
    for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ){
      nblc2++;
      if( bltrackMan->trackBLC2(iblc2trk)->chi2all()<blcuts::blc2_chi2_max) blc2id = iblc2trk;
    }
    Tools::Fill1D( Form("ntrack_BLC2"), nblc2 );
    if(IsrecoPassed && !(nblc2==1 && blc2id!=-1) ){
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nblc2" << std::endl;
      nAbort_nblc2++;
      //continue;
      IsrecoPassed=false;
    }

    //### BLC2-BPC position matching
    //TODO : not tuned yet
    bool fblc2bpc = false;
    if(IsrecoPassed){
      for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ){
        if( iblc2trk!=blc2id ) continue;
        LocalTrack *blc2 = bltrackMan->trackBLC2(iblc2trk);
        double xblc2bpc[2], yblc2bpc[2];
        double xmom[2], ymom[2];

        TVector3 Pos_BPC, Pos_BLC2, tmp;
        confMan->GetBLDCWireMapManager()->GetGParam( CID_BPC, Pos_BPC, tmp );
        confMan->GetBLDCWireMapManager()->GetGParam( CID_BLC2a, Pos_BLC2, tmp );
        const double zPos_BPC = Pos_BPC.Z();
        const double zPos_BLC2 = Pos_BLC2.Z();
        const double zPos_BPC_BLC2 = (Pos_BPC.Z()+Pos_BLC2.Z())/2;

        bpctrack->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[0], yblc2bpc[0] );
        bpctrack->XYPosatZ( zPos_BPC, xmom[0], ymom[0] );
        blc2->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[1], yblc2bpc[1]);
        blc2->XYPosatZ( zPos_BLC2, xmom[1], ymom[1]);
        double dxdz[2], dydz[2];
        dxdz[0] = (xmom[0]-xblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
        dxdz[1] = (xmom[1]-xblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);
        dydz[0] = (ymom[0]-yblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
        dydz[1] = (ymom[1]-yblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);

        if( (xblc2bpc[1]-xblc2bpc[0])<PARA_blc2bpc_dx_MIN ||
            (xblc2bpc[1]-xblc2bpc[0])>PARA_blc2bpc_dx_MAX ) fblc2bpc = false;
        else if( (yblc2bpc[1]-yblc2bpc[0])<PARA_blc2bpc_dy_MIN ||
            (yblc2bpc[1]-yblc2bpc[0])>PARA_blc2bpc_dy_MAX ) fblc2bpc = false;
        else if( (dxdz[1]-dxdz[0])<PARA_blc2bpc_dxdz_MIN ||
            (dxdz[1]-dxdz[0])>PARA_blc2bpc_dxdz_MAX ) fblc2bpc = false;
        else if( (dydz[1]-dydz[0])<PARA_blc2bpc_dydz_MIN ||
            (dydz[1]-dydz[0])>PARA_blc2bpc_dydz_MAX ) fblc2bpc = false;
        else fblc2bpc = true;

        Tools::Fill2D( Form("dydx_BLC2BPC"), xblc2bpc[1]-xblc2bpc[0], yblc2bpc[1]-yblc2bpc[0] );
        Tools::Fill2D( Form("dydzdxdz_BLC2BPC"), dxdz[1]-dxdz[0], dydz[1]-dydz[0] );
      }//iblc2trk

      if( !fblc2bpc ){
        if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_fblc2bpc" << std::endl;
        if(IsrecoPassed) nAbort_fblc2bpc++;
        //continue;
        IsrecoPassed=false;
      }
    }

    //** beam momentum calculation **//
    TLorentzVector LVec_beambf;  // 4-Momentum(beam) in LAB
    TLorentzVector LVec_beam;    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector LVec_beam_vtx[2];    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector LVec_target;  // 4-Momentum(He3-target) in LAB
    TLorentzVector LVec_targetP; // 4-Momentum(p-target) in LAB
    TLorentzVector LVec_beambfCM;  // 4-Momentum(beam) in CM
    TLorentzVector LVec_beamCM;    // 4-Momentum(beam) in CM with dE correcion
    TLorentzVector LVec_targetCM;  // 4-Momentum(He3-target) in CM
    TLorentzVector LVec_targetPCM; // 4-Momentum(p-target) in CM


    //std::cout << "test" << std::endl;
    //std::cout << "bpctrack->GetPosatZ(0)" << std::endl;
    //std::cout << bpctrack->GetPosatZ(0).X() << "  " <<  bpctrack->GetPosatZ(0).Y()  << "  " << bpctrack->GetPosatZ(0).Z()  << std::endl;
    //std::cout << zPos_T0 << std::endl;
    //std::cout << bpctrack->GetPosatZ(zPos_T0 ).X() << "  " <<  bpctrack->GetPosatZ(zPos_T0).Y()  << "  " << bpctrack->GetPosatZ(zPos_T0).Z()  << std::endl;
    
    //beam momentum smearing
    double beammom = 0;
    for( int imctrk=0; imctrk<mcData->trackSize(); imctrk++ ){
      const int pdgcode = mcData->track(imctrk)->pdgID();
      const int parent  = mcData->track(imctrk)->parentTrackID();
      //beam K (K+) to -Z direction 
      //beam momentum is fixed in GEANT simulation. It is smeared here by gaussian.
      if( pdgcode==321 && parent==0 ){
        beammom = (mcData->track(imctrk)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
        if(Verbosity_>100){
          std::cout << "L." << __LINE__ << " beam mom:" << beammom << std::endl;
        }
        break;
      }
    }

    double x1, y1, x2, y2;
    const double z1 = 0, z2 = 20;//TODO: what is this 20 ?
    if(IsrecoPassed){
      bpctrack->XYPosatZ(z1, x1, y1);
      bpctrack->XYPosatZ(z2, x2, y2);
    }
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls; 
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    LVec_beambf.SetVectM(Pp_beam , kpMass);
    LVec_target.SetVectM(Pp_target, dMass);
    LVec_target.SetVectM(Pp_target, dMass);
    LVec_targetP.SetVectM(Pp_target, pMass);
    LVec_beam = LVec_beambf;
    LVec_beam_vtx[0] = LVec_beambf;
    LVec_beam_vtx[1] = LVec_beambf;
    //Lorentz boost Vector
    const TVector3 boost = (LVec_target+LVec_beam).BoostVector();
    LVec_beambfCM = LVec_beam;
    LVec_targetCM = LVec_target;
    LVec_targetPCM = LVec_targetP;
    LVec_beambfCM.Boost(-1.*boost);
    LVec_targetCM.Boost(-1.*boost);
    LVec_targetPCM.Boost(-1.*boost);
    flagbmom = true;


    
    //always OK, because this is simulation
    if( !flagbmom ){
      if(IsrecoPassed)nAbort_flagbmom++;
      //continue;
      IsrecoPassed=false;
    }
    Tools::Fill1D( Form("momentum_beam"), LVec_beambf.P() );
    //generated info taking into account momentum bite
    double px = (LVec_beam).Px();
    double py = (LVec_beam).Py();
    double pz = (LVec_beam).Pz();
    double E = (LVec_beam).E();
    TLorentzVector LVec_beam_unit;
    LVec_beam_unit.SetPx(px*1000.0);
    LVec_beam_unit.SetPy(py*1000.0);
    LVec_beam_unit.SetPz(pz*1000.0);
    LVec_beam_unit.SetE(E*1000.0);
    double q = (LVec_beam_unit.Vect()-react_nmiss.Vect()).Mag()/1000.;
    TLorentzVector TL_piSigma = react_Sigma + react_pi;
    double mass = TL_piSigma.M()/1000.;
    Tools::H2("q_IMpiSigma_gen",mass,q,500,1,2,300,0,1.5);

    //** + + + + + + + + + + + + **//
    //**  PID in CDS             **//
    //** + + + + + + + + + + + + **//
    
    std::vector <int> vCDHseg;
    int nIDedTrack=0;
    if(IsrecoPassed){
          nIDedTrack = Util::CDSChargedAna(
          DoCDCRetiming,
          bpctrack, cdsMan, cdstrackMan, confMan, blMan,
          LVec_beam, ctmT0,vCDHseg,pim_ID,pip_ID,km_ID,p_ID,true);
      if(nIDedTrack==-7) Tools::Fill1D( Form("EventCheck"), 7 );
      if(nIDedTrack==-8) Tools::Fill1D( Form("EventCheck"), 8 );
      if(nIDedTrack==-9){
        nTrack_CDHshare++;
        Tools::Fill1D( Form("EventCheck"), 9 );
      }
      if(nIDedTrack==-10) Tools::Fill1D( Form("EventCheck"), 10 );
      if(nIDedTrack==-11) Tools::Fill1D( Form("EventCheck"), 11 );
      if(nIDedTrack==-12) Tools::Fill1D( Form("EventCheck"), 12 );
      if(nIDedTrack<0){
        nAbort_CDSPID++;
        //continue;
        IsrecoPassed=false;
      }
    }

    //Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+d_ID.size()+pim_ID.size()+km_ID.size() );
    if(nIDedTrack>0) nTrack_PID =+ nIDedTrack;
    Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+pim_ID.size()+km_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_plus"),  pip_ID.size() );
    Tools::Fill1D( Form("ntrack_proton"),   p_ID.size() );
    //Tools::Fill1D( Form("ntrack_deuteron"), d_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_minus"), pim_ID.size() );
    Tools::Fill1D( Form("ntrack_K_minus"),  km_ID.size() );

    bool forwardcharge= Util::IsForwardCharge(blMan); 

    // + + + + + + + + + + + //
    //  pi+ pi- X event  //
    // + + + + + + + + + + + //
    if( IsrecoPassed && 
        flagbmom && 
        (pim_ID.size()==1) && 
        (pip_ID.size()==1) && 
        (cdstrackMan->nGoodTrack()==cdscuts::cds_ngoodtrack) &&
        !forwardcharge ){
      
      nFill_pippim++;
      
      //added Jul.28th,2019
      //purpose 
      for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ) {
        CDSTrack *track = cdstrackMan->Track( cdstrackMan->GoodTrackID(it) );

        double mom = track->Momentum();//charge X momentum
        double tof = 999.;//TOF of CDH-T0 (slewing corrected)
        double mass2 = -999.;
        double correctedtof=0;//CDH-T0 (corrected by energy loss)
        double beta_calc=0;
        for( int icdh=0; icdh<track->nCDHHit(); icdh++ ) {
          HodoscopeLikeHit *cdhhit = track->CDHHit( cdsMan, icdh );
          double tmptof = cdhhit->ctmean()-ctmT0;
          if( tmptof<tof || tof==999. ) {
            tof = tmptof;
          }
        }
        if( !TrackTools::FindMass2( track, bpctrack, tof, LVec_beam.Vect().Mag(),
                                Beam_Kaon, beta_calc, mass2, correctedtof ) ) {

        }
        //const int pid = TrackTools::PIDcorr_wide(mom,mass2);
        const int pid = TrackTools::PIDcorr(mom,mass2);
        track->SetPID( pid );
        Tools::Fill2D( "PID_CDS_beta_select", 1./beta_calc, mom );
        Tools::Fill2D( "PID_CDS_select", mass2, mom );
        if(pid == CDS_PiMinus){
          Tools::Fill2D("PID_CDS_PIM_beta_select",1./beta_calc,mom);
          Tools::Fill2D("PID_CDS_PIM_select",mass2,mom);
        }else if(pid == CDS_PiPlus){
          Tools::Fill2D("PID_CDS_PIP_beta_select",1./beta_calc,mom);
          Tools::Fill2D("PID_CDS_PIP_select",mass2,mom);
        }
        else if(pid == CDS_Proton) Tools::Fill2D("PID_CDS_Proton_select",mass2,mom);
        else if(pid == CDS_Kaon) Tools::Fill2D("PID_CDS_Kaon_select",mass2,mom);
      }
      
      //** find CDH hit from neutral particles **//
      std::vector <int> NeutralCDHseg;
      std::vector <int> CDHhit_list;
      
      for( int icdhhit=0; icdhhit<cdsMan->nCDH(); icdhhit++ ){
        if( cdsMan->CDH(icdhhit)->CheckRange() && cdsMan->CDH(icdhhit)->ctmean()<(cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset) )
          CDHhit_list.push_back( cdsMan->CDH(icdhhit)->seg() );
      }
      std::sort(vCDHseg.begin(), vCDHseg.end());
      std::sort(CDHhit_list.begin(), CDHhit_list.end());
      std::set_difference( CDHhit_list.begin(), CDHhit_list.end(),
			   vCDHseg.begin(), vCDHseg.end(),
			   std::back_inserter(NeutralCDHseg) );

      if( NeutralCDHseg.size()!=1 ){
        std::cout<< "L." << __LINE__ << " CDH neutral hit is not 1 :: "<<NeutralCDHseg.size()<<std::endl;
        std::cout << "vCDHseg " << vCDHseg.size() << std::endl;
        std::cout << "CDHhit_list " << CDHhit_list.size() << std::endl;
      }
      
      if(Verbosity_){
        std::cout<<"# of diff = "<<NeutralCDHseg.size()<<std::endl;
        std::cout<<"CDH hits =   ";
        for( int n=0; n<(int)CDHhit_list.size(); n++ ){
          std::cout<<CDHhit_list[n]<<" ";
        } std::cout<<std::endl;
        std::cout<<"track hits = ";
        for( int n=0; n<(int)vCDHseg.size(); n++ ){
          std::cout<<vCDHseg[n]<<" ";
        } std::cout<<std::endl;
        std::cout<<"diff hits =  ";
        for( int n=0; n<(int)NeutralCDHseg.size(); n++ ){
          std::cout<<NeutralCDHseg[n]<<" ";
        } std::cout<<std::endl;
      }


      
      // isolation cut //
      int flag_isolation = 0;
      if(IsolationCutFlag==2){
        flag_isolation = Util::GetCDHNeighboringNHits(NeutralCDHseg,CDHhit_list,vCDHseg,cdsMan);
        flag_isolation+= Util::GetCDHTwoSegAwayNHits(NeutralCDHseg,CDHhit_list);
      }else if(IsolationCutFlag==1){
        flag_isolation = Util::GetCDHNeighboringNHits(NeutralCDHseg,CDHhit_list,vCDHseg,cdsMan);
      }else{
        //check cdh hit position anyway, but don't apply isolation cuts 
        flag_isolation = Util::GetCDHNeighboringNHits(NeutralCDHseg,CDHhit_list,vCDHseg,cdsMan);
        flag_isolation = 0;
      }
      if( flag_isolation ){
        if(Verbosity_>100)std::cout<< "L."<< __LINE__ << " Event Number: " <<iev <<  " CDH hit candidate is NOT isolated !!!"<<std::endl;
        if(IsrecoPassed)nAbort_CDHiso++;
        //continue;
        IsrecoPassed=false;
      }else{
        if(Verbosity_>100) std::cerr<<"CDH isolation cuts : OK " << std::endl;
        Tools::Fill1D( Form("EventCheck"), 14 );
      }
      
      //** copy neutral CDH hit candidate **//
      int icdh = -1;
      for( int icdhhit=0; icdhhit<cdsMan->nCDH(); icdhhit++ ){
        if( cdsMan->CDH(icdhhit)->seg()==NeutralCDHseg[0] ) icdh = icdhhit;
      }
      HodoscopeLikeHit *ncdhhit = cdsMan->CDH(icdh);
      
      //** charge veto using CDC **//
      TVector3 Pos_CDH;
      confMan->GetGeomMapManager()->GetPos( CID_CDH, ncdhhit->seg(), Pos_CDH );
      if(Verbosity_) std::cout<<"CDH candidate seg = "<<ncdhhit->seg()<<" -> "<<Pos_CDH.Phi()/TwoPi*360<<" deg"<<std::endl;
      

      const int nCDCforVeto = Util::GetNHitsCDCOuter(Pos_CDH,cdsMan,cdscuts::chargevetoangle);
      Util::AnaPipPimCDCCDH(Pos_CDH,NeutralCDHseg,pip_ID[0],pim_ID[0],cdsMan,cdstrackMan);
      
      //Pos_CDH.SetZ(-1*ncdhhit->hitpos()); // (-1*) is wrong in SIM [20170925]
      Pos_CDH.SetZ(ncdhhit->hitpos());
      
      if(Verbosity_){
        std::cout << "L." << __LINE__ << " CDH Z " << ncdhhit->hitpos() << std::endl;
        double angle = Pos_CDH.Angle(Pos_CDH); // rad
        std::cout << "L." << __LINE__ << " CDH angle " << angle << std::endl;
        std::cout<<"L."<<__LINE__ << "CDH phi " << Pos_CDH.Phi()/TwoPi*360. <<std::endl;
        std::cout<<"L."<<__LINE__ << "CDH costheta " << Pos_CDH.CosTheta() <<std::endl;
      }
         

      //** neutral particle in CDH **//
      if( !nCDCforVeto && !flag_isolation ){
        if(NeutralCDHseg.size()!=1) {
          std::cout << "L." << __LINE__ << " # of seg for neutral hits " << NeutralCDHseg.size() << std::endl;
        } else {
          Tools::Fill1D(Form("CDHNeutralSeg"),NeutralCDHseg.at(0));
        }

        CDSTrack *track_pip = cdstrackMan->Track( pip_ID[0] ); // only 1 track
        CDSTrack *track_pim = cdstrackMan->Track( pim_ID[0] ); // only 1 track
	       
        TVector3 vtx_react;//reaction vertex
        TVector3 vtx_dis;//displaced vertex
        
        
        TVector3 vtx_beam_wpip;//vertex(beam-pip) on beam
        TVector3 vtx_pip;//vertex(beam-pip) on particle
        TVector3 vtx_beam;
        track_pip->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_beam_wpip, vtx_pip ); 
        TVector3 vtx_beam_wpim;//vertex(beam-pim) on beam
        TVector3 vtx_pim;//vertex(beam-pim) on particle
        track_pim->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_beam_wpim, vtx_pim ); 
      
        double dcapipvtx =  (vtx_pip-vtx_beam_wpip).Mag();
        double dcapimvtx =  (vtx_pim-vtx_beam_wpim).Mag();
        const TVector3 vtx_pip_mean = 0.5*(vtx_pip+vtx_beam_wpip);
        const TVector3 vtx_pim_mean = 0.5*(vtx_pim+vtx_beam_wpim);
        Tools::Fill1D( Form("DCA_pip"), dcapipvtx );
        Tools::Fill1D( Form("DCA_pim"), dcapimvtx );
        
        TVector3 CA_pip_pippim,CA_pim_pippim;
        bool vtx_flag=TrackTools::Calc2HelixVertex(track_pip, track_pim, CA_pip_pippim, CA_pim_pippim);
        double dcapippim=-9999.;
        if(vtx_flag) dcapippim = (CA_pim_pippim-CA_pip_pippim).Mag();
        Tools::Fill1D( Form("DCA_pippim"), dcapippim);
        
        //reaction vertex is determined from beam and nearest vtx 
        if(dcapipvtx <= dcapimvtx){
          //follows sakuma/sada's way , avg. of scattered particle ana beam particle [20180829]
          vtx_react = 0.5*(vtx_pip+vtx_beam_wpip);
          //if(cdscuts::useclosestpi) vtx_dis  = vtx_pip;
          //else              vtx_dis  = vtx_pim;
          //vtx_dis  = vtx_pim;
          vtx_dis  = CA_pim_pippim;
          vtx_beam = vtx_beam_wpip;
        }else{
          vtx_react = 0.5*(vtx_pim+vtx_beam_wpim);
          //if(cdscuts::useclosestpi) vtx_dis = vtx_pim;
          //else             vtx_dis = vtx_pip;
          //vtx_dis = vtx_pip;
          vtx_dis = CA_pip_pippim;
          vtx_beam = vtx_beam_wpim;
        }

        // beam kaon tof 
        TVector3 Pos_T0;
        confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
        double beamtof=0;
        double momout=0;
        double z_pos = Pos_T0.Z();;
        ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), vtx_react,
            LVec_beambf.Vect().Mag(), kpMass, momout, beamtof );
        // LVec_beam.SetVectM( momout*LVec_beambf.Vect().Unit(), kpMass ); // not need energy-loss correction [20180329]
        double beamtof_vtx[2];
        double momout_vtx[2];
        //Sp mode assumption
        ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), 0.5*(vtx_pim+vtx_beam_wpim),
            LVec_beambf.Vect().Mag(), kpMass, momout_vtx[0], beamtof_vtx[0] );
        LVec_beam_vtx[0].SetVectM( momout_vtx[0]*LVec_beambf.Vect().Unit(), kpMass );
        //Sm mode assumption
        ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), 0.5*(vtx_pip+vtx_beam_wpip),
            LVec_beambf.Vect().Mag(), kpMass, momout_vtx[1], beamtof_vtx[1] );
        LVec_beam_vtx[1].SetVectM( momout_vtx[1]*LVec_beambf.Vect().Unit(), kpMass );

        
        double ntof = ncdhhit->ctmean()-ctmT0-beamtof;
        const double ntof_vtx[2] = {ncdhhit->ctmean()-ctmT0-beamtof_vtx[0], ncdhhit->ctmean()-ctmT0-beamtof_vtx[1]};
        double nlen = (Pos_CDH-vtx_dis).Mag();
        double nlen_vtx[2];
        //nlen_vtx[0] = (Pos_CDH-vtx_pip).Mag();
        //nlen_vtx[1] = (Pos_CDH-vtx_pim).Mag();
        nlen_vtx[0] = (Pos_CDH-CA_pip_pippim).Mag();
        nlen_vtx[1] = (Pos_CDH-CA_pim_pippim).Mag();
        NeutralBetaCDH = nlen/ntof/(Const*100.);
        for(int ivtx=0;ivtx<2;ivtx++){
          NeutralBetaCDH_vtx[ivtx] = nlen_vtx[ivtx]/ntof_vtx[ivtx]/(Const*100.);
        }
        double tmp_mom = NeutralBetaCDH<1. ? nMass*NeutralBetaCDH/sqrt(1.-NeutralBetaCDH*NeutralBetaCDH) : 0.;
        double tmp_mom_vtx[2];
        for(int ivtx=0;ivtx<2;ivtx++){
          tmp_mom_vtx[ivtx] = NeutralBetaCDH_vtx[ivtx]<1. ? nMass*NeutralBetaCDH_vtx[ivtx]/sqrt(1.-NeutralBetaCDH_vtx[ivtx]*NeutralBetaCDH_vtx[ivtx]) : 0;
        }
        if(Verbosity_){
          std::cout<<"$$$ beta = "<<NeutralBetaCDH<<" mom_n = "<<tmp_mom<<std::endl; //" "<<1/sqrt(1+nMass*nMass)<<std::endl;
	      }

        //** reconstructoin of missing neutorn **//
        TVector3 P_pim; // Momentum(pi-)
        TVector3 P_pip; // Momentum(pi+)
	
        TLorentzVector LVec_pim; // 4-Momentum(pi-)
        TLorentzVector LVec_pip; // 4-Momentum(pi+)
        TLorentzVector LVec_n;   // 4-Momentum(n)
        TLorentzVector LVec_n_vtx[2];   // 4-Momentum(n)
        TLorentzVector LVec_nmiss; // 4-Momentum(n_miss)
        TLorentzVector LVec_nmiss_vtx[2]; // 4-Momentum(n_miss)

        if( !track_pip->GetMomentum( vtx_pip, P_pip, true, true ) ){
          std::cout<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
        }
        if( !track_pim->GetMomentum( vtx_pim, P_pim, true, true ) ){
          std::cout<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
        }
        TVector3 P_n = tmp_mom*((Pos_CDH-vtx_dis).Unit());
	
        if(Verbosity_) std::cout << tmp_mom<<" ("<<P_n.CosTheta()<<" , "<<P_n.Phi()*360./TwoPi<<")"<<std::endl;

        TVector3 P_n_vtx[2];
        //P_n_vtx[0] = tmp_mom_vtx[0]*((Pos_CDH-vtx_pip).Unit());
        //P_n_vtx[1] = tmp_mom_vtx[1]*((Pos_CDH-vtx_pim).Unit());
        P_n_vtx[0] = tmp_mom_vtx[0]*((Pos_CDH-CA_pip_pippim).Unit());
        P_n_vtx[1] = tmp_mom_vtx[1]*((Pos_CDH-CA_pim_pippim).Unit());
        
        LVec_pim.SetVectM( P_pim, piMass );
        LVec_pip.SetVectM( P_pip, piMass );
        LVec_n.SetVectM(   P_n,   nMass );//CDS n
        for(int ivtx=0;ivtx<2;ivtx++){
          LVec_n_vtx[ivtx].SetVectM(  P_n_vtx[ivtx],   nMass );//CDS n
        }
	
        const double mm_mass   = (LVec_target+LVec_beam-LVec_pim-LVec_pip-LVec_n).M();
        double mm_mass_vtx[2];
        for(int ivtx=0;ivtx<2;ivtx++){
          mm_mass_vtx[ivtx]= (LVec_target+LVec_beam_vtx[ivtx]-LVec_pim-LVec_pip-LVec_n_vtx[ivtx]).M();       
        }
        
        const TVector3 P_missn = (LVec_target+LVec_beam-LVec_pim-LVec_pip-LVec_n).Vect();
        TVector3 P_missn_vtx[2];
        for(int ivtx=0;ivtx<2;ivtx++){
          P_missn_vtx[ivtx] = (LVec_target+LVec_beam_vtx[ivtx]-LVec_pim-LVec_pip-LVec_n_vtx[ivtx]).Vect();  
        }
        
        LVec_nmiss.SetVectM( P_missn, nMass );
        for(int ivtx=0;ivtx<2;ivtx++){
          LVec_nmiss_vtx[ivtx].SetVectM( P_missn_vtx[ivtx], nMass );
        }
        
        if(Verbosity_)std::cout<<"  missing mass = "<<mm_mass<<std::endl;
	
        TVector3 boost = (LVec_target+LVec_beam).BoostVector();
        TLorentzVector LVec_nmiss_CM = LVec_nmiss;
        TLorentzVector LVec_beam_CM = LVec_beam;
        LVec_nmiss_CM.Boost(-boost);
        LVec_beam_CM.Boost(-boost);
        double cos_n = LVec_nmiss_CM.Vect().Dot(LVec_beam_CM.Vect())/(LVec_nmiss_CM.Vect().Mag()*LVec_beam_CM.Vect().Mag());
        if(Verbosity_)std::cout<<"  missing mom = "<<LVec_nmiss.P()<<" | cos_CM = "<<cos_n<<std::endl;
	
	
        //** + + + + + + + + + + + + + **//
        //**  fill histograms & tree   **//
        //** + + + + + + + + + + + + + **//
        kf_flag = -1;
        bool K0rejectFlag=false;
        bool MissNFlag=false;
        bool SigmaPFlag=false;
        bool SigmaMFlag=false;
        bool NBetaOK=false;
        bool NdEOK=false;

        Tools::Fill2D( Form("dE_betainv"), 1./NeutralBetaCDH, ncdhhit->emean() );
        Tools::Fill2D( Form("MMom_MMass"), mm_mass, P_missn.Mag() );
        
        Tools::Fill2D(Form("Vtx_ZX_nofid"),vtx_pip_mean.Z(),vtx_pip_mean.X());
        Tools::Fill2D(Form("Vtx_ZY_nofid"),vtx_pip_mean.Z(),vtx_pip_mean.Y());
        Tools::Fill2D(Form("Vtx_XY_nofid"),vtx_pip_mean.X(),vtx_pip_mean.Y());
        Tools::Fill2D(Form("Vtx_ZX_nofid"),vtx_pim_mean.Z(),vtx_pim_mean.X());
        Tools::Fill2D(Form("Vtx_ZY_nofid"),vtx_pim_mean.Z(),vtx_pim_mean.Y());
        Tools::Fill2D(Form("Vtx_XY_nofid"),vtx_pim_mean.X(),vtx_pim_mean.Y());
        //Fiducial cuts OK
        if( (!IsVtxDoubleCheck && (GeomTools::GetID(vtx_react)==CID_Fiducial)) || 
            ( IsVtxDoubleCheck && 
            (GeomTools::GetID(vtx_pim_mean)==CID_Fiducial) &&
            (GeomTools::GetID(vtx_pip_mean)==CID_Fiducial)))  {
           
          for( int i=0; i<cdsMan->nCDH(); i++ ) {
            if((cdsMan->CDH(i)->CheckRange()) && (cdsMan->CDH(i)->ctmean()<cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset)){
              Tools::Fill2D(Form("dE_CDHtime_pippimn"), cdsMan->CDH(i)->ctmean(), cdsMan->CDH(i)->emean());
            }
          }

           
          Tools::Fill2D(Form("Vtx_ZX_fid"),vtx_pip_mean.Z(),vtx_pip_mean.X());
          Tools::Fill2D(Form("Vtx_ZY_fid"),vtx_pip_mean.Z(),vtx_pip_mean.Y());
          Tools::Fill2D(Form("Vtx_XY_fid"),vtx_pip_mean.X(),vtx_pip_mean.Y());
          Tools::Fill2D(Form("Vtx_ZX_fid"),vtx_pim_mean.Z(),vtx_pim_mean.X());
          Tools::Fill2D(Form("Vtx_ZY_fid"),vtx_pim_mean.Z(),vtx_pim_mean.Y());
          Tools::Fill2D(Form("Vtx_XY_fid"),vtx_pim_mean.X(),vtx_pim_mean.Y());
          Tools::Fill2D(Form("NeutraltimeEnergy"),ncdhhit->ctmean()-ctmT0-beamtof,ncdhhit->emean());
          Tools::Fill2D(Form("CDHzNeutraltime"),Pos_CDH.z(),ncdhhit->ctmean()-ctmT0-beamtof);
          Tools::Fill2D( Form("dE_betainv_fid"), 1./NeutralBetaCDH, ncdhhit->emean() );
          Tools::Fill2D( Form("MMom_MMass_fid"), mm_mass, P_missn.Mag() );
         
          if(NeutralBetaCDH<anacuts::beta_MAX) NBetaOK=true;
        
          if(NBetaOK){
            Tools::Fill2D( Form("dE_betainv_fid_beta"), 1./NeutralBetaCDH, ncdhhit->emean() );
            Tools::Fill2D( Form("MMom_MMass_fid_beta"), mm_mass, P_missn.Mag() );
          }
          if(anacuts::dE_MIN<ncdhhit->emean()) NdEOK=true;

          if( NBetaOK && NdEOK ){
            Tools::Fill2D( Form("dE_betainv_fid_beta_dE"), 1./NeutralBetaCDH, ncdhhit->emean() );
            Tools::Fill2D( Form("MMom_MMass_fid_beta_dE"), mm_mass, P_missn.Mag() );
            Tools::Fill1D( Form("IMpipi_dE"), (LVec_pim+LVec_pip).M() );
            Tools::Fill2D( Form("IMpipi_NMom_dE"),P_n.Mag(), (LVec_pim+LVec_pip).M());
      //added Jul.28th,2019
      //purpose 
      for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ) {
        CDSTrack *track = cdstrackMan->Track( cdstrackMan->GoodTrackID(it) );

        double mom = track->Momentum();//charge X momentum
        double tof = 999.;//TOF of CDH-T0 (slewing corrected)
        double mass2 = -999.;
        double correctedtof=0;//CDH-T0 (corrected by energy loss)
        double beta_calc=0;
        for( int icdh=0; icdh<track->nCDHHit(); icdh++ ) {
          HodoscopeLikeHit *cdhhit = track->CDHHit( cdsMan, icdh );
          double tmptof = cdhhit->ctmean()-ctmT0;
          if( tmptof<tof || tof==999. ) {
            tof = tmptof;
          }
        }
        if( !TrackTools::FindMass2( track, bpctrack, tof, LVec_beam.Vect().Mag(),
                                Beam_Kaon, beta_calc, mass2, correctedtof ) ) {

        }
        //const int pid = TrackTools::PIDcorr_wide(mom,mass2);
        const int pid = TrackTools::PIDcorr(mom,mass2);
        track->SetPID( pid );
        Tools::Fill2D( "PID_CDS_beta_select2", 1./beta_calc, mom );
        Tools::Fill2D( "PID_CDS_select2", mass2, mom );
        if(pid == CDS_PiMinus){
          Tools::Fill2D("PID_CDS_PIM_beta_select2",1./beta_calc,mom);
          Tools::Fill2D("PID_CDS_PIM_select2",mass2,mom);
        }else if(pid == CDS_PiPlus){
          Tools::Fill2D("PID_CDS_PIP_beta_select2",1./beta_calc,mom);
          Tools::Fill2D("PID_CDS_PIP_select2",mass2,mom);
        }
        else if(pid == CDS_Proton) Tools::Fill2D("PID_CDS_Proton_select2",mass2,mom);
        else if(pid == CDS_Kaon) Tools::Fill2D("PID_CDS_Kaon_select2",mass2,mom);
      }//for it
          }//NbetaOK

          if( ((LVec_pim+LVec_pip).M()<anacuts::pipi_MIN || anacuts::pipi_MAX<(LVec_pim+LVec_pip).M())) K0rejectFlag=true;
        
          //missing mass neutron ID
          if( anacuts::neutron_MIN<mm_mass && mm_mass<anacuts::neutron_MAX ) MissNFlag=true;
        
          //Sigma+ production in CDS
          if( (anacuts::Sigmap_MIN<(LVec_n+LVec_pip).M() && (LVec_n+LVec_pip).M()<anacuts::Sigmap_MAX)) SigmaPFlag=true;
        
          //Sigma- production in CDS
          if( (anacuts::Sigmam_MIN<(LVec_n+LVec_pim).M() && (LVec_n+LVec_pim).M()<anacuts::Sigmam_MAX)) SigmaMFlag=true;

          if( NBetaOK && NdEOK ){
            //K0rejection 
            if(K0rejectFlag){
              // K0 rejection
              Tools::Fill2D( Form("dE_betainv_fid_beta_dE_woK0"), 1./NeutralBetaCDH, ncdhhit->emean() );
              Tools::Fill2D( Form("MMom_MMass_fid_beta_dE_woK0"), mm_mass, P_missn.Mag() );

              Tools::Fill2D(Form("CDHseg_MMass_fid_beta_dE_woK0"),ncdhhit->seg(),mm_mass);
              Tools::Fill2D(Form("CDHz_MMass_fid_beta_dE_woK0"),Pos_CDH.z(),mm_mass);
              //Tools::Fill2D(Form("zVTX_MMass_fid_beta_dE_woK0"),vtx_react.z(),mm_mass);
              Tools::Fill2D( Form("IMnpim_IMnpip_dE_woK0"), (LVec_n+LVec_pip).M(), (LVec_n+LVec_pim).M() );
              Tools::Fill2D( Form("dE_MMom_fid_beta_woK0"), P_missn.Mag() , ncdhhit->emean() );
              Tools::Fill2D( Form("dE_MMass_fid_beta_woK0"), mm_mass , ncdhhit->emean() );
              Tools::Fill2D( Form("CDHz_IMnpip_fid_beta_dE_woK0_n"),Pos_CDH.z(),(LVec_n+LVec_pip).M());
              Tools::Fill2D( Form("CDHz_IMnpim_fid_beta_dE_woK0_n"),Pos_CDH.z(),(LVec_n+LVec_pim).M());
            }else{
              // K0 selection
              Tools::Fill2D( Form("dE_betainv_fid_beta_dE_wK0"), 1./NeutralBetaCDH, ncdhhit->emean() );
              Tools::Fill2D( Form("MMom_MMass_fid_beta_dE_wK0"), mm_mass, P_missn.Mag() );
            }

            if(K0rejectFlag && MissNFlag){
              Tools::Fill2D( Form("dE_betainv_fid_beta_dE_woK0_n"), 1./NeutralBetaCDH, ncdhhit->emean() );
              Tools::Fill2D( Form("MMom_MMass_fid_beta_dE_woK0_n"), mm_mass, P_missn.Mag() );
              Tools::Fill2D( Form("NMom_NMom_fid_beta_dE_woK0_n"), P_n.Mag(), P_missn.Mag() );
              Tools::Fill2D( Form("IMnpim_IMnpip_dE_woK0_n"), (LVec_n+LVec_pip).M(), (LVec_n+LVec_pim).M() );
            }

            if(K0rejectFlag && (SigmaPFlag || SigmaMFlag)){
              Tools::Fill2D(Form("MMom_MMass_fid_beta_dE_woK0_wSid"),mm_mass, P_missn.Mag());
              for( int i=0; i<cdsMan->nCDH(); i++ ){
                if((cdsMan->CDH(i)->CheckRange()) && (cdsMan->CDH(i)->ctmean()<cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset)){
                  Tools::Fill2D( Form("CDHdE_woK0_wSid"),cdsMan->CDH(i)->seg(),cdsMan->CDH(i)->emean());
                }
              }
            }

            if( MissNFlag ){
              Tools::Fill1D( Form("IMnpipi_n"), (LVec_n+LVec_pim+LVec_pip).M() );
              Tools::Fill2D( Form("MMnmiss_IMnpipi_n"),(LVec_n+LVec_pim+LVec_pip).M(), P_missn.Mag());
            }

            if( MissNFlag && (SigmaPFlag || SigmaMFlag)){
              Tools::Fill1D( Form("IMnpipi_wSid_n"), (LVec_n+LVec_pim+LVec_pip).M() );
              Tools::Fill2D( Form("MMnmiss_IMnpipi_wSid_n"),(LVec_n+LVec_pim+LVec_pip).M(), P_missn.Mag());
            }

            if( MissNFlag && K0rejectFlag && (SigmaPFlag || SigmaMFlag)){
              Tools::Fill2D( Form("IMmnpim_IMmnpip_woK0_wSid_n"), (LVec_nmiss+LVec_pip).M(), (LVec_nmiss+LVec_pim).M() );
              Tools::Fill2D( Form("MMnpip_MMnpim_woK0_wSid_n"), (LVec_target+LVec_beam-LVec_pim-LVec_n).M(),
                  (LVec_target+LVec_beam-LVec_pip-LVec_n).M() );

              Tools::Fill1D( Form("IMnpipi_woK0_wSid_n"), (LVec_n+LVec_pim+LVec_pip).M() );

              Tools::Fill2D( Form("dE_IMnpipi_woK0_wSid_n"), (LVec_n+LVec_pim+LVec_pip).M(), ncdhhit->emean());
              //cos theta 
              Tools::Fill2D( Form("Cosn_IMnpipi_woK0_wSid_n"), (LVec_n+LVec_pim+LVec_pip).M(), cos_n );
              //
              Tools::Fill2D( Form("MMnmiss_IMnpipi_woK0_wSid_n"), (LVec_n+LVec_pim+LVec_pip).M(), P_missn.Mag());
              Tools::Fill2D( Form("nmom_IMnpipi_woK0_wSid_n"), (LVec_n+LVec_pim+LVec_pip).M(), LVec_n.P());
              //momentum transfer 
              Tools::Fill2D( Form("q_IMnpipi_woK0_wSid_n"),(LVec_n+LVec_pim+LVec_pip).M(), (LVec_beam.Vect()-LVec_nmiss.Vect()).Mag());

              Tools::Fill1D( Form("vertex_diff_X"), vtx_react.X()-mcData->track(ID[kin::kmbeam])->vertex().X() );
              Tools::Fill1D( Form("vertex_diff_Y"), vtx_react.Y()-mcData->track(ID[kin::kmbeam])->vertex().Y() );
              Tools::Fill1D( Form("vertex_diff_Z"), vtx_react.Z()-mcData->track(ID[kin::kmbeam])->vertex().Z() );
              

              Tools::Fill1D( Form("DCA_pip_SigmaPM"),dcapipvtx);
              Tools::Fill1D( Form("DCA_pim_SigmaPM"),dcapimvtx);
              Tools::Fill1D( Form("DCA_pippim_SigmaPM"),dcapippim);
              if(Verbosity_){
                std::cout << "L."<< __LINE__ <<" Kinematical Fit using KinFitter" << std::endl;
              }

              for( int i=0; i<cdsMan->nCDH(); i++ ){
                if((cdsMan->CDH(i)->CheckRange()) && (cdsMan->CDH(i)->ctmean()<cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset)){
                  Tools::Fill2D( Form("CDHdE_woK0_wSid_n"),cdsMan->CDH(i)->seg(),cdsMan->CDH(i)->emean());
                }
              }
            }//if (MissNFlag && K0rejectFlag && (SigmaPFlag || SigmaMFlag))

            if(K0rejectFlag && MissNFlag && SigmaPFlag) {
              Tools::Fill1D( Form("DCA_pip_SigmaP"),dcapipvtx);
              Tools::Fill1D( Form("DCA_pim_SigmaP"),dcapimvtx);
              Tools::Fill1D( Form("DCA_pippim_SigmaP"),dcapippim);
            }

            if(K0rejectFlag && MissNFlag && SigmaMFlag) {
              Tools::Fill1D( Form("DCA_pip_SigmaM"),dcapipvtx);
              Tools::Fill1D( Form("DCA_pim_SigmaM"),dcapimvtx);
              Tools::Fill1D( Form("DCA_pippim_SigmaM"),dcapippim);
            }


            // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
            // %%% Kinematical Fit using KinFitter %%% //
            // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
            //--- set TLorentzVector for MC study---//
            // beam_K(K+), pi-/+, Sigma+/-, n, n from Sigma, pi+/- from Sigma 
            //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+ 
            //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma- 
            TLorentzVector TL_meas[kin::npart]; // measured
            //TL_meas[kin::kmbeam] = LVec_beam;
            //TL_meas[kin::nmiss] = LVec_nmiss; // * which n?
            //TL_meas[kin::ncds] = LVec_n;     // * which n?
            if( reactionID == gen::reactionID_Spmode ){
              TL_meas[kin::kmbeam] = LVec_beam_vtx[0];
              TL_meas[kin::nmiss] = LVec_nmiss_vtx[0]; // * which n?
              TL_meas[kin::ncds] = LVec_n_vtx[0];     // * which n?
              TL_meas[kin::pim_g1] = LVec_pim;
              //TL_meas[kin::Sp] = (LVec_n+LVec_pip);
              TL_meas[kin::Sp] = (LVec_n_vtx[0]+LVec_pip);
              TL_meas[kin::pip_g2] = LVec_pip;
            } else if ( reactionID == gen::reactionID_Smmode ){
              TL_meas[kin::kmbeam] = LVec_beam_vtx[1];
              TL_meas[kin::nmiss] = LVec_nmiss_vtx[1]; // * which n?
              TL_meas[kin::ncds] = LVec_n_vtx[1];     // * which n?
              TL_meas[kin::pip_g1] = LVec_pip;
              //TL_meas[kin::Sm] = (LVec_n+LVec_pim);
              TL_meas[kin::Sm] = (LVec_n_vtx[1]+LVec_pim);
              TL_meas[kin::pim_g2] = LVec_pim;
            }

            double val1 = (TL_meas[kin::ncds]-TL_gene[kin::nmiss]).P(); // n_measured - n_initial
            double val2 = (TL_meas[kin::ncds]-TL_gene[kin::ncds]).P(); // n_measured - n_Sigma
            //int genID[kin::npart] = {0,1,2,3,4,5};
            IsncdsfromSigma = true;
            if( val1<val2 ){ // is there more good selection way?
              genID[kin::nmiss] = kin::ncds;
              genID[kin::ncds] = kin::nmiss;

              //ncds(gen.) is not detected, initial n is detected in CDS instead.
              //abort this event !
              if(IsrecoPassed)nAbort_anothern++;
              //IsncdsfromSigma = false;
            }
            mcmom_beam = TL_gene[kin::kmbeam];
            mcmom_ncds  = TL_gene[genID[kin::ncds]];
            mcmom_nmiss  = TL_gene[genID[kin::nmiss]];
            if( reactionID==gen::reactionID_Spmode ){
              mcmom_pip  = TL_gene[kin::pip_g2];
              mcmom_pim  = TL_gene[kin::pim_g1];
            } else if ( reactionID==gen::reactionID_Smmode ){
              mcmom_pip  = TL_gene[kin::pip_g1];
              mcmom_pim  = TL_gene[kin::pim_g2];
            }



            if(Verbosity_)std::cout<< "L." << __LINE__ << " val = "<<val1<<" "<<val2<<" -> "<< genID[kin::nmiss] <<" "<< genID[kin::ncds] << std::endl;

            //--- set TLorentzVector ---//
            // beam_K(K+), pi-/+, Sigma+/-, p, n, n from S, pi+/- from S 
            //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
            TLorentzVector TL_measSpmode[kin::npart]; // measured
            //TL_measSpmode[kin::kmbeam] = LVec_beam;
            TL_measSpmode[kin::kmbeam] = LVec_beam_vtx[0];
            TL_measSpmode[kin::pim_g1] = LVec_pim;
            //TL_measSpmode[kin::Sp] = (LVec_n+LVec_pip);
            TL_measSpmode[kin::Sp] = (LVec_n_vtx[0]+LVec_pip);
            //TL_measSpmode[kin::nmiss] = LVec_nmiss;
            TL_measSpmode[kin::nmiss] = LVec_nmiss_vtx[0];
            //TL_measSpmode[kin::ncds] = LVec_n;
            TL_measSpmode[kin::ncds] = LVec_n_vtx[0];
            TL_measSpmode[kin::pip_g2] = LVec_pip;
            //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
            TLorentzVector TL_measSmmode[kin::npart]; // measured
            //TL_measSmmode[kin::kmbeam] = LVec_beam;
            TL_measSmmode[kin::kmbeam] = LVec_beam_vtx[1];
            TL_measSmmode[kin::pip_g1] = LVec_pip;
            //TL_measSmmode[kin::Sm] = (LVec_n+LVec_pim);
            TL_measSmmode[kin::Sm] = (LVec_n_vtx[1]+LVec_pim);
            //TL_measSmmode[kin::nmiss] = LVec_nmiss;
            TL_measSmmode[kin::nmiss] = LVec_nmiss_vtx[1];
            //TL_measSmmode[kin::ncds] = LVec_n;
            TL_measSmmode[kin::ncds] = LVec_n_vtx[1];
            TL_measSmmode[kin::pim_g2] = LVec_pim;
            TLorentzVector TL_kfitSpmode[kin::npart]; // kinematical fitted
            TLorentzVector TL_kfitSmmode[kin::npart]; // kinematical fitted
            // LVec_target is defined as (0, 0, 0, M_D2)
            TVector3 TV_target = LVec_target.Vect();
            TVector3 TV_measSpmode[kin::npart];
            TVector3 TV_measSmmode[kin::npart];
            for( int ip=0; ip<kin::npart; ip++ ){
              TV_measSpmode[ip] = TL_measSpmode[ip].Vect();
              TV_measSmmode[ip] = TL_measSmmode[ip].Vect();
            }//for npart

            //--- KinFitter :: initialization ---//
            //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip),  LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
            //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim),  LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
            //*** definition of fit particles in cartesian coordinates ***//
            TString str_particleSpmode[kin::npart] = {"LVec_beam", "LVec_pim", "LVec_Sp",  "LVec_mn", "LVec_n", "LVec_pip"};
            TString str_particleSmmode[kin::npart] = {"LVec_beam", "LVec_pip", "LVec_Sm",  "LVec_mn", "LVec_n", "LVec_pim"};
            TFitParticlePxPyPz ParticleTgt = TFitParticlePxPyPz("target", "target", &TV_target,
                pdg->GetParticle("deuteron")->Mass(), covZero);
            TFitParticlePxPyPz ParticleSpmode[kin::npart];
            TFitParticlePxPyPz ParticleSmmode[kin::npart];
            for( int ip=0; ip<kin::npart; ip++ ){
              ParticleSpmode[ip] = TFitParticlePxPyPz(str_particleSpmode[ip], str_particleSpmode[ip], &TV_measSpmode[ip],
                  pdg->GetParticle(PDG_Spmode[ip])->Mass(), covParticleSpmode[ip]);
              ParticleSmmode[ip] = TFitParticlePxPyPz(str_particleSmmode[ip], str_particleSmmode[ip], &TV_measSmmode[ip],
                  pdg->GetParticle(PDG_Smmode[ip])->Mass(), covParticleSmmode[ip]);
            }
            //*** definition of constraints ***//
            // constraint :: mass of Sigma
            TFitConstraintM ConstMSSpmode = TFitConstraintM("M_Sp", "M_Sp", 0, 0, pdg->GetParticle(PDG_Spmode[kin::Sp])->Mass());
            TFitConstraintM ConstMSSmmode = TFitConstraintM("M_Sm", "M_Sm", 0, 0, pdg->GetParticle(PDG_Smmode[kin::Sm])->Mass());
            ConstMSSpmode.addParticles1(&ParticleSpmode[kin::ncds], &ParticleSpmode[kin::pip_g2]);
            ConstMSSmmode.addParticles1(&ParticleSmmode[kin::ncds], &ParticleSmmode[kin::pim_g2]);
            // constraint :: 4-momentum conservation
            TFitConstraintEp ConstEpSpmode[4];
            TFitConstraintEp ConstEpSmmode[4];
            TString str_constEpSpmode[4]  = {"Px", "Py", "Pz", "E"};
            TString str_constEpSmmode[4]  = {"Px", "Py", "Pz", "E"};
            for( int i=0; i<4; i++ ){
              ConstEpSpmode[i] = TFitConstraintEp(str_constEpSpmode[i], str_constEpSpmode[i], 0, TFitConstraintEp::component(i), 0);
              ConstEpSmmode[i] = TFitConstraintEp(str_constEpSmmode[i], str_constEpSmmode[i], 0, TFitConstraintEp::component(i), 0);
              ConstEpSpmode[i].addParticles1(&ParticleTgt, &ParticleSpmode[kin::kmbeam]);
              ConstEpSmmode[i].addParticles1(&ParticleTgt, &ParticleSmmode[kin::kmbeam]);
              ConstEpSpmode[i].addParticles2(&ParticleSpmode[kin::pim_g1],&ParticleSpmode[kin::nmiss], &ParticleSpmode[kin::ncds], &ParticleSpmode[kin::pip_g2]);
              ConstEpSmmode[i].addParticles2(&ParticleSmmode[kin::pip_g1],&ParticleSmmode[kin::nmiss], &ParticleSmmode[kin::ncds], &ParticleSmmode[kin::pim_g2]);
            }//for i

            //--- KinFitter :: execution ---//
            //*** definition of the fitter ***//
            TKinFitter kinfitter_Spmode;
            TKinFitter kinfitter_Smmode;
            // add measured particles
            // K-, pi-, ncds, pi+  
            kinfitter_Spmode.addMeasParticles(&ParticleSpmode[kin::kmbeam], &ParticleSpmode[kin::pim_g1], &ParticleSpmode[kin::ncds], &ParticleSpmode[kin::pip_g2]); 
            // K, pi+,  n, pi- 
            kinfitter_Smmode.addMeasParticles(&ParticleSmmode[kin::kmbeam], &ParticleSmmode[kin::pip_g1], &ParticleSmmode[kin::ncds], &ParticleSmmode[kin::pim_g2]); 
            // unmeasured particle forward missing neutron
            kinfitter_Spmode.addUnmeasParticles(&ParticleSpmode[kin::nmiss]); // missing-n
            kinfitter_Smmode.addUnmeasParticles(&ParticleSmmode[kin::nmiss]); // missing-n
            // add constraints 
            kinfitter_Spmode.addConstraint(&ConstMSSpmode); // mass of Sigma+
            kinfitter_Smmode.addConstraint(&ConstMSSmmode); // mass of Sigma-
            for( int i=0; i<4; i++ ){
              kinfitter_Spmode.addConstraint(&ConstEpSpmode[i]); // 4-momentum conservation
              kinfitter_Smmode.addConstraint(&ConstEpSmmode[i]); // 4-momentum conservation
            }

            //*** perform the fit ***//
            kinfitter_Spmode.setMaxNbIter(kin::maxitr);       // max number of iterations
            kinfitter_Smmode.setMaxNbIter(kin::maxitr);       // max number of iterations
            kinfitter_Spmode.setMaxDeltaS(kin::maxdchi2);     // max delta chi2
            kinfitter_Smmode.setMaxDeltaS(kin::maxdchi2);     // max delta chi2
            kinfitter_Spmode.setMaxF(kin::maxsumconst);          // max sum of constraints
            kinfitter_Smmode.setMaxF(kin::maxsumconst);          // max sum of constraints
            kinfitter_Spmode.setVerbosity(KFDEBUG);  // verbosity level
            kinfitter_Smmode.setVerbosity(KFDEBUG);  // verbosity level
            kinfitter_Spmode.fit();
            kinfitter_Smmode.fit();
            //*** copy fit results ***//
            for( int ip=0; ip<kin::npart; ip++ ){
              TL_kfitSpmode[ip] = (*ParticleSpmode[ip].getCurr4Vec());
              TL_kfitSmmode[ip] = (*ParticleSmmode[ip].getCurr4Vec());
            }
            //reconstruct Lorentz vector of Sigma+/-
            TL_kfitSpmode[kin::Sp] = TL_kfitSpmode[kin::ncds]+TL_kfitSpmode[kin::pip_g2];
            TL_kfitSmmode[kin::Sm] = TL_kfitSmmode[kin::ncds]+TL_kfitSmmode[kin::pim_g2];

            int correct_flag = 0;
            if( kinfitter_Spmode.getStatus()==0 &&  //0 means that kinfit is converged 
                kinfitter_Spmode.getS()<kinfitter_Smmode.getS() && 
                reactionID==gen::reactionID_Spmode ){ 
              correct_flag = 1;//Spmode
            }else if( kinfitter_Smmode.getStatus()==0 && 
                kinfitter_Smmode.getS()<kinfitter_Spmode.getS() && 
                reactionID==gen::reactionID_Smmode ){ 
              correct_flag = 1;//Smmode
            }

            double chi2 = kinfitter_Spmode.getS()<kinfitter_Smmode.getS() ? kinfitter_Spmode.getS():kinfitter_Smmode.getS();
            Tools::Fill2D( Form("KFchi2_vs"), kinfitter_Spmode.getS()/kinfitter_Spmode.getNDF(),
                kinfitter_Smmode.getS()/kinfitter_Smmode.getNDF() );
            if( chi2 < kin::chi2cut ) Tools::Fill1D( Form("KF_decision"), correct_flag );

            if(Verbosity_){
              std::cout<<"pi- S+ : status = "<<kinfitter_Spmode.getStatus()<<", chi2/NDF = "<<kinfitter_Spmode.getS()<<"/"<<kinfitter_Spmode.getNDF()<<std::endl;
              std::cout<<"pi+ S- : status = "<<kinfitter_Smmode.getStatus()<<", chi2/NDF = "<<kinfitter_Smmode.getS()<<"/"<<kinfitter_Smmode.getNDF()<<std::endl;
              if      ( reactionID==gen::reactionID_Spmode ) std::cout<<"*** pi- S+ ==> "<<correct_flag<<" ***"<<std::endl;
              else if ( reactionID==gen::reactionID_Smmode ) std::cout<<"*** pi+ S- ==> "<<correct_flag<<" ***"<<std::endl;
            }
            //** fill tree **//
            kfMomBeamSpmode   = TL_kfitSpmode[kin::kmbeam];
            kfMom_pip_Spmode    = TL_kfitSpmode[kin::pip_g2];
            kfMom_pim_Spmode    = TL_kfitSpmode[kin::pim_g1];
            kfMom_n_Spmode      = TL_kfitSpmode[kin::ncds];
            kf_chi2_Spmode      = kinfitter_Spmode.getS();//chi2
            kf_NDF_Spmode       = kinfitter_Spmode.getNDF();
            kf_status_Spmode    = kinfitter_Spmode.getStatus();
            kf_pvalue_Spmode    = ROOT::Math::chisquared_cdf_c(kinfitter_Spmode.getS(), kinfitter_Spmode.getNDF());
            kfMomBeamSmmode   = TL_kfitSmmode[kin::kmbeam];
            kfMom_pim_Smmode    = TL_kfitSmmode[kin::pim_g1];
            kfMom_pip_Smmode    = TL_kfitSmmode[kin::pip_g2];
            kfMom_n_Smmode      = TL_kfitSmmode[kin::ncds];
            kf_chi2_Smmode      = kinfitter_Smmode.getS();
            kf_NDF_Smmode       = kinfitter_Smmode.getNDF();
            kf_status_Smmode    = kinfitter_Smmode.getStatus();
            kf_pvalue_Smmode    = ROOT::Math::chisquared_cdf_c(kinfitter_Smmode.getS(), kinfitter_Smmode.getNDF());
            kf_flag       = reactionID; //correct_flag;

            // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
            // %%% Kinematical Fit using KinFitter %%% //
            // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //

            //--- for the covariance matrix evaluation ---//
            if( flagG4Decay && IsncdsfromSigma && MissNFlag && K0rejectFlag ){
              if( ((reactionID==gen::reactionID_Spmode)&&SigmaPFlag)
                  ||  ((reactionID==gen::reactionID_Smmode)&&SigmaMFlag)){
                TVector3 primvtx;
                bool IsncdsMatchOK=true;
                //16.041, 16.0446, 7.08828 [MeV]
                //double valpx = TL_meas[kin::ncds][0] - TL_gene[genID[kin::ncds]][0];  
                //double valpy = TL_meas[kin::ncds][1] - TL_gene[genID[kin::ncds]][1];  
                //double valpz = TL_meas[kin::ncds][2] - TL_gene[genID[kin::ncds]][2];  
                //if(  !( -3.* 16.041/1000.  < valpx && valpx < 3.* 16.041/1000.)
                //  || !( -3.* 16.045/1000.  < valpy && valpy < 3.* 16.045/1000.) 
                //  || !( -3.* 7.0883/1000.  < valpz && valpz < 3.* 7.0883/1000.) ){
                //  IsncdsMatchOK=false;
                //}

                //evaluate 
                for( int ip=0; ip<kin::npart+1; ip++ ){
                  for( int ii=0; ii<4; ii++ ){
                    for( int jj=0; jj<4; jj++ ){
                      if(ip!=kin::npart){
                        double val  = (TL_meas[ip][ii] - TL_gene[genID[ip]][jj]);
                        //Sigma should be suffered energy loss in the target (?)
                        //Use Lorentz vector ncds + decay pion
                        if(IsncdsMatchOK) Tools::Fill1D(Form("cov_%d_%d_%d", ip, ii, jj), val);
                        if(ip==kin::kmbeam) primvtx = mcData->track(ID[ip])->vertex();
                        TVector3 vertex = mcData->track(ID[ip])->vertex();
                        double mcDCA = (vertex.Mag()-primvtx.Mag())/10.0;
                        //double mcDCA = vertex.Mag()-vtx_react.Mag();
                        TVector3 vertexc(vertex.x()/10.,vertex.y()/10.,vertex.z()/10.); 

                        double momX  = fabs(mcData->track(ID[ip])->momentum().x());
                        double momY  = fabs(mcData->track(ID[ip])->momentum().y());
                        double momZ  = fabs(mcData->track(ID[ip])->momentum().z());
                        double mom  = mcData->track(ID[ip])->momentum().Mag();

                        //double mcDCAc = vertexc.Mag()-vtx_react.Mag();
                        //Tools::Fill2D(Form("cov_zvtx_%d_%d_%d", ip, ii,jj), val, vertexc.z());
                        if(IsncdsMatchOK ){
                          if(ii==0) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momX*0.001);
                          if(ii==1) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momY*0.001);
                          if(ii==2) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momZ*0.001);
                          if(ii==3) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, mom*0.001);
                        }
                        if( ii==3 &&  ii==jj && ip==4 ){ 
                          Tools::H1(Form("vtxdiffx"),vertexc.x()-vtx_react.x() ,1000,-2,2);
                          Tools::H1(Form("vtxdiffy"),vertexc.y()-vtx_react.y() ,1000,-2,2);
                          Tools::H1(Form("vtxdiffz"),vertexc.z()-vtx_react.z() ,1000,-10,10);
                          if(Verbosity_){
                            TLorentzVector TL_S = TL_gene[kin::ncds]+TL_gene[kin::pip_g2];
                            TLorentzVector TL_Sreco = TL_meas[kin::ncds]+TL_meas[kin::pip_g2];
                            std::cout << __LINE__ << std::endl;
                            std::cout << "Mass gen n+pi " << TL_S.M() << std::endl;
                            std::cout << "Mass reco n+pi " << TL_Sreco.M() << std::endl;
                            std::cout << "IP " << ip << std::endl;
                            std::cout << "mom (gen.) " << mom*0.001 << std::endl;
                            std::cout << "LVec_n " << LVec_n.P() << std::endl;
                            std::cout << "TL_meas[ip] " << TL_meas[ip].P() << std::endl;
                            std::cout << "TL_gen[genID[ip]] " << TL_gene[genID[ip]].P() << std::endl;
                            std::cout << "val " << val << std::endl;
                            //  std::cout<< iev << std::endl;
                            //  std::cout<< "ip:" << ip << std::endl;
                            //std::cout<<" cov "<<ii<<" , "<<jj<<" = "<<TL_meas[ii][jj]<<" - "<<TL_gene[ii][jj]
                            //<<" = "<< (TL_meas[ii][jj] - TL_gene[ii][jj])<<std::endl;
                            std::cout << "mcDCA: " << mcDCA << std::endl;
                            std::cout << "vertex X: " <<  vertex.x() << std::endl;
                            std::cout << "vertex Y: " <<  vertex.y() << std::endl;
                            std::cout << "vertex Z: " <<  vertex.z() << std::endl;
                            std::cout << "reaVTX X: " <<  vtx_react.x() << std::endl;
                            std::cout << "reaVTX Y: " <<  vtx_react.y() << std::endl;
                            std::cout << "reaVTX Z: " <<  vtx_react.z() << std::endl;
                            std::cout << "flight l: " << mcData->track(ID[ip])->FlightLength() << std::endl;
                          }
                        }
                      }else if(ip==kin::npart){
                        TLorentzVector TL_S = TL_gene[kin::ncds]+TL_gene[kin::pip_g2];
                        double val = TL_meas[kin::Sp][ii] - TL_S[jj];
                        if(IsncdsMatchOK) Tools::Fill1D(Form("cov_%d_%d_%d", ip, ii, jj), val);
                        double momX  = fabs(mcData->track(ID[kin::Sp])->momentum().x());
                        double momY  = fabs(mcData->track(ID[kin::Sp])->momentum().y());
                        double momZ  = fabs(mcData->track(ID[kin::Sp])->momentum().z());
                        double mom  = mcData->track(ID[kin::Sp])->momentum().Mag();
                        if(IsncdsMatchOK ){
                          if(ii==0) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momX*0.001);
                          if(ii==1) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momY*0.001);
                          if(ii==2) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momZ*0.001);
                          if(ii==3) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, mom*0.001);
                        }
                      }
                    }//for jj
                  }//for ii
                }//for ip
              }//if ((SigmaPFlag || SigmaMFlag))
            }//if flagG4Decay MissNFlag && K0rejectFlag 

            kf_flag = reactionID; //correct_flag;

          } // if( NBetaOK && NdEOK )

          //** fill tree **//
          if(IsncdsfromSigma && IsrecoPassed){
            dE = ncdhhit->emean();
            neutralseg = ncdhhit->seg();
            mom_n_Sp = LVec_n_vtx[0];            // 4-momentum(neutron)
            mom_n_Sm = LVec_n_vtx[1];            // 4-momentum(neutron)
            mom_beam_Sp = LVec_beam_vtx[0];
            mom_beam_Sm = LVec_beam_vtx[1];
            mom_target = LVec_target; // 4-momentum(target)
            mom_pip = LVec_pip;        // 4-momentum(pi+)
            mom_pim = LVec_pim;        // 4-momentum(pi-)
            mom_n = LVec_n;            // 4-momentum(neutron)
            // beta is already filled
            vtx_reaction = vtx_react; // vertex(reaction)
            vtx_pip_beam = vtx_beam_wpip;
            vtx_pim_beam = vtx_beam_wpim;
            vtx_pip_cdc = vtx_pip;
            vtx_pim_cdc = vtx_pim;
            CA_pip = CA_pip_pippim;
            CA_pim = CA_pim_pippim;
            CDH_Pos = Pos_CDH;
            TLorentzVector mcmom_ncdspi = TL_gene[genID[kin::ncds]]+TL_gene[kin::pip_g2];
            //std::cout << __LINE__ << mcmom_ncdspi.M() << std::endl;
            mc_nparticle = nparticle;
            TVector3 mcvertex = mcData->track(kin::kmbeam)->vertex();
            TVector3 mcvertexc(mcvertex.x()/10.,mcvertex.y()/10.,mcvertex.z()/10.); 
            mc_vtx = mcvertexc;
            run_num   = confMan->GetRunNumber(); // run number
            event_num = iev;     // event number
            block_num = 0;      // block number (temp)

            if(Verbosity_){
              std::cout<<"%%% pippimn event: Event_Number, Block_Event_Number, CDC_Event_Number = "
                <<iev<<" , "<<" ---, "<<ev_cdc<<std::endl;
            }
            mom_beam   = LVec_beam;   // 4-momentum(beam)
            outfile2->cd();
            //if(IsncdsfromSigma && piSigma_detect)
            //if(IsncdsfromSigma ){
            npippimTree->Fill();
            nFill_pippimn++;
            //}
            outfile->cd();
	        }//IsrecoPassed
        } // if( GeomTools::GetID(vtx_react)==CID_Fiducial )
      } // if( !nCDCforVeto )
    }else{  //if pi+ pi- X event  
      nAbort_pippim++;
    }

    
    
    nAbort_end++;
    delete detData2;
    
  } // for iev
  
  std::cout<<"===== Sigma pi reconstruction in MC END ====="<<std::endl;
  std::cout<<" nEvent       = "<<exen<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nG4Event_piSigma  = "<<nG4Event_piSigma<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" AllGoodTrack = "<<AllGoodTrack<<std::endl;
  std::cout<<" nTrack       = "<<nTrack<<std::endl;
  std::cout<<" nTrack_PID   = "<<nTrack_PID<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nAbort_nGoodTrack  = "<<nAbort_nGoodTrack<<std::endl;
  std::cout<<" nAbort_nCDH        = "<<nAbort_nCDH<<std::endl;
  std::cout<<" nAbort_nT0         = "<<nAbort_nT0<<std::endl;
  std::cout<<" nAbort_nbpc        = "<<nAbort_nbpc<<std::endl;
  std::cout<<" nAbort_bpctrack    = "<<nAbort_bpctrack<<std::endl;
  std::cout<<" nAbort_nblc2       = "<<nAbort_nblc2<<std::endl;
  std::cout<<" nAbort_fblc2bpc    = "<<nAbort_fblc2bpc<<std::endl;
  std::cout<<" nAbort_flagbmom    = "<<nAbort_flagbmom<<std::endl;
  std::cout<<" nAbort_ftarget     = "<<nAbort_ftarget<<std::endl;
  std::cout<<" nAbort_CDHiso      = "<<nAbort_CDHiso<<std::endl;
  std::cout<<" nAbort_pippim      = "<<nAbort_pippim<<std::endl;
  std::cout<<" nAbort_anothern    = "<<nAbort_anothern<<std::endl;
  std::cout<<" nAbort_end         = "<<nAbort_end<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<std::endl;
  std::cout<<"*** # of pi+ pi- p n n events = "<<nFill_pippimn<<" ***"<<std::endl;
  std::cout<<"==============================================="<<std::endl;

  outfile->Write();
  outfile->Close();

  outfile2->Write();
  outfile2->Close();

  simfile->Close();
  cdcfile->Close();

  delete pdg;

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}

//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
void InitializeHistogram()
//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
{
  
  //** geneneral informantion **//
  Tools::newTH1F( Form("EventCheck"), 20, 0, 20 );

  //defined in IMPiSigmaHist.hh
  bool MCFlag=true;
  InitBasicHist(MCFlag);
  InitIMPiSigmaHist();
  return;
}

void InitTreeVal()
{

  mom_beam.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam)
  mom_beam_Sp.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam)
  mom_beam_Sm.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam)
  mom_target.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.); // 4-momentum(target)
  mom_pip.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(pi+)
  mom_pim.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi-)
  mom_n.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron)
  mom_n_Sp.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.) ;      // 4-momentum(neutron)
  mom_n_Sm.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.) ;      // 4-momentum(neutron)
  NeutralBetaCDH=-9999.; // veracity of neutral particle on CDH
  NeutralBetaCDH_vtx[0]=-9999.; // veracity of neutral particle on CDH
  NeutralBetaCDH_vtx[1]=-9999.; // veracity of neutral particle on CDH
  dE=-9999.;   // energy deposit on CDH
  neutralseg =-1;   // energy deposit on CDH
  vtx_reaction.SetXYZ(-9999., -9999., -9999.); //  vertex(reaction)   
  vtx_pip_beam.SetXYZ(-9999., -9999., -9999.); //  
  vtx_pim_beam.SetXYZ(-9999., -9999., -9999.); //   
  vtx_pip_cdc.SetXYZ(-9999., -9999., -9999.);
  vtx_pim_cdc.SetXYZ(-9999., -9999., -9999.);
  CA_pip.SetXYZ(-9999., -9999., -9999.);
  CA_pim.SetXYZ(-9999., -9999., -9999.);
  CDH_Pos.SetXYZ(-9999., -9999., -9999.);
  run_num=-9999;   // run number
  event_num=-9999; // event number
  block_num=-9999; // block number
  mc_nparticle=-9999;
  mcmom_beam.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // generated 4-momentum(beam)
  mcmom_pip.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // generated 4-momentum(pi+)
  mcmom_pim.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // generated 4-momentum(pi-)
  mcmom_ncds.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // generated 4-momentum(neutron)
  mcmom_nmiss.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // generated 4-momentum(neutron)
  react_nmiss.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  react_Sigma.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  react_pi.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  
  mc_vtx.SetXYZ(-9999., -9999., -9999.);
  kfMomBeamSpmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam) after kinematical refit for pi- Sigma+
  kfMom_pip_Spmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi+) after kinematical refit for pi- Sigma+
  kfMom_pim_Spmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi-) after kinematical refit for pi- Sigma+
  kfMom_n_Spmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron) after kinematical refit for pi- Sigma+
  kf_chi2_Spmode=-9999.;   // chi2 of kinematical refit
  kf_NDF_Spmode=-9999.;    // NDF of kinematical refit
  kf_status_Spmode=-9999; // status of kinematical refit -> details can be found in this code
  kf_pvalue_Spmode=-9999; // p-value of kinematical refit
  kfMomBeamSmmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam) after kinematical refit for pi+ Sigma-
  kfMom_pip_Smmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi+) after kinematical refit for pi+ Sigma-
  kfMom_pim_Smmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi-) after kinematical refit for pi+ Sigma-
  kfMom_n_Smmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron) after kinematical refit for pi+ Sigma-
  kf_chi2_Smmode=-9999.;   // chi2 of kinematical refit
  kf_NDF_Smmode=-9999.;    // NDF of kinematical refit
  kf_status_Smmode=-9999.; // status of kinematical refit -> details can be found in this code
  kf_pvalue_Smmode=-9999.; // p-value of kinematical refit
  kf_flag=-9999; // flag of correct pair reconstruction, etc
//= = = = pippimn final-sample tree = = = =//

}

