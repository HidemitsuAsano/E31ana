//----------------------------------------------------------------//
// H.Asano Aug.8th, 2018
// UserSimIMPiSigma.cpp 
// originated from UserSimpipipnn.cpp 
// 
// the purpose is to reconstruct pi S n event
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// reconstruction method is based on "EventAnalysis_pipipnn_sakuma.cpp"
//----------------------------------------------------------------//
//  exe-file: simIMpisigma [./simIMpisigma $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: when $(OutFile) is "tmp.root", the following 2 files are generated.
//     "tmp.root":      histogram file
//     "tmp_pipipnn.root": basic information of pippimn event is listed up in TTree 
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"
#include "TrackTools.h"
#include "EventHeader.h"
#include "Tools.h"
#include "ELossTools.h"

#include <TDatabasePDG.h>
#include <KinFitter/TKinFitter.h>
#include <KinFitter/TFitParticlePxPyPz.h>
#include <KinFitter/TFitConstraintM.h>
#include <KinFitter/TFitConstraintEp.h>
#include <Math/ProbFuncMathCore.h>

#define VTX_SIGMA 0 // 1: Sigma reconstruction,  vertex = K- & p
                    // 0: Lambda reconstruction, vertex = K- & pi+

#define KFDEBUG 0 // verbose level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices

const double MOM_RES = 2.0; // MeV/c
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)

//** cut parameters **//
double PARA_blc2bpc_dx_MIN;
double PARA_blc2bpc_dx_MAX;
double PARA_blc2bpc_dy_MIN;
double PARA_blc2bpc_dy_MAX;
double PARA_blc2bpc_dxdz_MIN;
double PARA_blc2bpc_dxdz_MAX;
double PARA_blc2bpc_dydz_MIN;
double PARA_blc2bpc_dydz_MAX;
double PARA_lnL_MAX;
double PARA_MM_LP_MIN;
double PARA_MM_LP_MAX;

const double TDC_CDH_MAX = 999999; //ns (original:20 nsec.)
const double ADC_CDH_MIN = 1;  // MeV

//= = = = pippimn final-sample tree = = = =//
TLorentzVector mom_beam;   // 4-momentum(beam)
TLorentzVector mom_target; // 4-momentum(target)
TLorentzVector mom_pip;    // 4-momentum(pi+)
TLorentzVector mom_pim;    // 4-momentum(pi-)
TLorentzVector mom_n;      // 4-momentum(neutron)
double beta; // veracity of neutral particle on CDH
double dE;   // energy deposit on CDH
TVector3 vtx_reaction; // vertex(reaction)
int run_num;   // run number
int event_num; // event number
int block_num; // block number
TLorentzVector mcmom_beam;   // generated 4-momentum(beam)
TLorentzVector mcmom_pip;    // generated 4-momentum(pi+)
TLorentzVector mcmom_pim;    // generated 4-momentum(pi-)
TLorentzVector mcmom_n;      // generated 4-momentum(neutron)
TLorentzVector kfMomBeamSpmode;   // 4-momentum(beam) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_pip_Spmode;    // 4-momentum(pi+) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_pim_Spmode;    // 4-momentum(pi-) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_n_Spmode;      // 4-momentum(neutron) after kinematical refit for pi- Sigma+
double kf_chi2_Spmode;   // chi2 of kinematical refit
double kf_NDF_Spmode;    // NDF of kinematical refit
double kf_status_Spmode; // status of kinematical refit -> details can be found in this code
double kf_pvalue_Spmode; // p-value of kinematical refit
TLorentzVector kfMomBeamSmmode;   // 4-momentum(beam) after kinematical refit for pi+ Sigma-
TLorentzVector kfMom_pip_Smmode;    // 4-momentum(pi+) after kinematical refit for pi+ Sigma-
TLorentzVector kfMom_pim_Smmode;    // 4-momentum(pi-) after kinematical refit for pi+ Sigma-
TLorentzVector kfMom_n_Smmode;      // 4-momentum(neutron) after kinematical refit for pi+ Sigma-
double kf_chi2_Smmode;   // chi2 of kinematical refit
double kf_NDF_Smmode;    // NDF of kinematical refit
double kf_status_Smmode; // status of kinematical refit -> details can be found in this code
double kf_pvalue_Smmode; // p-value of kinematical refit
int kf_flag; // flag of correct pair reconstruction, etc
//= = = = pippimn final-sample tree = = = =//

int Verbosity_ = 0 ;

void InitializeHistogram();


namespace kin{
  const int npart=6;
  const int kmbeam=0;
  const int pim_g1=1;//pi- 1st generation, Sigma+ mode
  const int Sp=2;//Sigma+ mode
  const int nmiss=3;
  const int ncds=4;
  const int pip_g2=5;//pi+ 2nd generation, Sigma+ mode
  const int pip_g1=1;//pi- 1st generation, Sigma- mode
  const int Sm=2;//Sigma- mode
  const int pim_g2=5;//pi- 2nd generation, Sigma- mode
}



int main( int argc, char** argv )
{
  if( argc!=5 ){
    std::cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<std::endl;
    return 0;
  }

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");

  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//
  // ### obtained from (p_meas[j]-p_gene[j])
  // ###  using G4-data with TH1F(Form("cov_%d_%d_%d", i, j, j), 100, -cov_MAX, cov_MAX);
  // ###  and evaluated using "Air" Dora MC
  // 1) TLorentzVector LVec_beam, LVec_pim, (L_n+LVec_pip), LVec_nmiss, L_n, LVec_pip = for pi- Sigma+
  const double covVal_Spmode[kin::npart][16] = {
    { 2.03675e-05, 0, 0, 0,
      0, 1.72317e-05, 0, 0,
      0, 0, 3.63879e-06, 0,
      0, 0, 0, 3.13463e-06 },
    { 9.61619e-06, 0, 0, 0,
      0, 9.71896e-06, 0, 0,
      0, 0, 1.95299e-05, 0,
      0, 0, 0, 1.23025e-05 },
    { 0.000344907, 0, 0, 0,
      0, 0.000344784, 0, 0,
      0, 0, 6.33015e-05, 0,
      0, 0, 0, 4.95287e-05 },
    { 0.000624282, 0, 0, 0,
      0, 0.000664143, 0, 0,
      0, 0, 0.00028286, 0,
      0, 0, 0, 0.000121639 },
    { 0.000253317, 0, 0, 0,
      0, 0.000234635, 0, 0,
      0, 0, 1.96443e-05, 0,
      0, 0, 0, 2.26387e-05 },
    { 9.82579e-06, 0, 0, 0,
      0, 1.00648e-05, 0, 0,
      0, 0, 1.50993e-05, 0,
      0, 0, 0, 7.68311e-06 }
  };
  // 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), L_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
  const double covVal_Smmode[kin::npart][16] = {
    { 2.03675e-05, 0, 0, 0,
      0, 1.72317e-05, 0, 0,
      0, 0, 3.63879e-06, 0,
      0, 0, 0, 3.13463e-06 },
    { 9.61619e-06, 0, 0, 0,
      0, 9.71896e-06, 0, 0,
      0, 0, 1.95299e-05, 0,
      0, 0, 0, 1.23025e-05 },
    { 0.000344907, 0, 0, 0,
      0, 0.000344784, 0, 0,
      0, 0, 6.33015e-05, 0,
      0, 0, 0, 4.95287e-05 },
    { 0.000624282, 0, 0, 0,
      0, 0.000664143, 0, 0,
      0, 0, 0.00028286, 0,
      0, 0, 0, 0.000121639 },
    { 0.000253317, 0, 0, 0,
      0, 0.000234635, 0, 0,
      0, 0, 1.96443e-05, 0,
      0, 0, 0, 2.26387e-05 },
    { 9.82579e-06, 0, 0, 0,
      0, 1.00648e-05, 0, 0,
      0, 0, 1.50993e-05, 0,
      0, 0, 0, 7.68311e-06 }
  };


  TMatrixD *covZero = new TMatrixD(4, 4);
  covZero->Zero();
  covZero->ResizeTo(3, 3); // resize from 4x4 to 3x3
  TMatrixD *covParticleSpmode[kin::npart];
  TMatrixD *covParticleSmmode[kin::npart];
  for( int ip=0; ip<kin::npart; ip++ ){
    covParticleSpmode[ip] = new TMatrixD(4, 4);
    covParticleSmmode[ip] = new TMatrixD(4, 4);
    int n = 0;
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( j==k ){
	  (*covParticleSpmode[ip])[j][k] = covVal_Spmode[ip][n]; // only diagonal elements
	  (*covParticleSmmode[ip])[j][k] = covVal_Smmode[ip][n]; // only diagonal elements
	} else{
	  (*covParticleSpmode[ip])[j][k] = 0;
	  (*covParticleSmmode[ip])[j][k] = 0;
	}
	n++;
      }
    }
    covParticleSpmode[ip]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticleSmmode[ip]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticleSpmode[ip]->Print(); // Print all
    covParticleSmmode[ip]->Print(); // Print all
  }
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//


  //** Conf file open **// 
  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  //** Simulation file open **// 
  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);
  if( tree2->GetEntries()==1 ) std::cout<<"  !!! tree2 entries==1 !!!"<<std::endl;
  else tree2->GetEntry(0);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  //** Getting CDSTracking info. from CDCfile **//
  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
  EventHeader      *header = new EventHeader();
  evTree->SetBranchAddress("EventHeader", &header );
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan  = new BeamLineTrackMan();
  CDSTrackingMan   *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  //** output file 1 : histograms **//
  TFile *outfile = new TFile(argv[2], "recreate");
  outfile->cd();

  //** output file 2 : pippimn final-sample tree **// 
  std::string outfile2_name = string(argv[2]);
  outfile2_name.insert( outfile2_name.size()-5, "_pippimn" );
  std::cout<<"pippimn file "<<outfile2_name<<std::endl;
  TFile *outfile2 = new TFile( outfile2_name.c_str(), "recreate" );
  outfile2->cd();
  TTree *pippimnTree = new TTree( "EventTree", "EventTree" );
  pippimnTree->Branch( "mom_beam",   &mom_beam );
  pippimnTree->Branch( "mom_target", &mom_target );
  pippimnTree->Branch( "mom_pip", &mom_pip );
  pippimnTree->Branch( "mom_pim", &mom_pim );
  pippimnTree->Branch( "mom_n", &mom_n );
  pippimnTree->Branch( "beta", &beta );
  pippimnTree->Branch( "dE", &dE );
  pippimnTree->Branch( "vtx_reaction", &vtx_reaction );
  pippimnTree->Branch( "run_num", &run_num );
  pippimnTree->Branch( "event_num", &event_num );
  pippimnTree->Branch( "block_num", &block_num );
  pippimnTree->Branch( "mcmom_beam",   &mcmom_beam );
  pippimnTree->Branch( "mcmom_pip", &mcmom_pip );
  pippimnTree->Branch( "mcmom_pim", &mcmom_pim );
  pippimnTree->Branch( "mcmom_n", &mcmom_n );
  pippimnTree->Branch( "kfMomBeamSpmode",   &kfMomBeamSpmode );
  pippimnTree->Branch( "kfMom_pip_Spmode", &kfMom_pip_Spmode );
  pippimnTree->Branch( "kfMom_pim_Spmode", &kfMom_pim_Spmode );
  pippimnTree->Branch( "kfMom_n_Spmode", &kfMom_n_Spmode );
  pippimnTree->Branch( "kf_chi2_Spmode", &kf_chi2_Spmode );
  pippimnTree->Branch( "kf_NDF_Spmode", &kf_NDF_Spmode );
  pippimnTree->Branch( "kf_status_Spmode", &kf_status_Spmode );
  pippimnTree->Branch( "kf_pvalue_Spmode", &kf_pvalue_Spmode );
  pippimnTree->Branch( "kfMomBeamSmmode",   &kfMomBeamSmmode );
  pippimnTree->Branch( "kfMom_pip_Smmode", &kfMom_pip_Smmode );
  pippimnTree->Branch( "kfMom_pim_Smmode", &kfMom_pim_Smmode );
  pippimnTree->Branch( "kfMom_n_Smmode", &kfMom_n_Smmode );
  pippimnTree->Branch( "kf_chi2_Smmode", &kf_chi2_Smmode );
  pippimnTree->Branch( "kf_NDF_Smmode", &kf_NDF_Smmode );
  pippimnTree->Branch( "kf_status_Smmode", &kf_status_Smmode );
  pippimnTree->Branch( "kf_pvalue_Smmode", &kf_pvalue_Smmode );
  pippimnTree->Branch( "kf_flag", &kf_flag );
  outfile->cd();



  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    //return 0;
  }

  InitializeHistogram();


  //*** for kinematical fit ***//
  // beam_K(K+), pi-/+, Sigma+/-, forward n, n from S, pi+/- from S
  // !!! only diagonal components !!!
  const int BIN = 100;
  double cov_MAX;
  for( int ip=0; ip<kin::npart; ip++ ){
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( ip==kin::kmbeam || ip==kin::pim_g1 || ip==kin::pip_g2 ) // K-, pi, pi
	  cov_MAX = 0.02;
	else // Sigma, p, n_miss, n
	  cov_MAX = 0.1;
	Tools::newTH1F(Form("cov_%d_%d_%d", ip, j, k), BIN, -cov_MAX, cov_MAX);
      }
    }
  }//for ip

  Tools::newTH2F( Form("KFchi2_vs"), 100, 0, 100, 100, 0, 100 );
  Tools::newTH1F( Form("KF_decision"), 2, -0.5, 1.5 );

  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  std::cout<<"=====Sigma pi reconstruction in MC START ============="<<std::endl;
  std::cout<<"     # of All  Event in EventTree:     "<<eventn<<std::endl;
  std::cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<std::endl;
  std::cout<<"     # of Exe  Event in this program:  "<<exen<<std::endl;
  std::cout<<"========================================================="<<std::endl;

  //** set cut parameters **//
  PARA_blc2bpc_dx_MIN = -0.75;
  PARA_blc2bpc_dx_MAX = 0.75;
  PARA_blc2bpc_dy_MIN = -0.75;
  PARA_blc2bpc_dy_MAX = 0.75;
  PARA_blc2bpc_dxdz_MIN = -0.02;
  PARA_blc2bpc_dxdz_MAX = 0.02;
  PARA_blc2bpc_dydz_MIN = -0.02;
  PARA_blc2bpc_dydz_MAX = 0.02;
  PARA_lnL_MAX = 9.95;

  PARA_MM_LP_MIN = 0.85;
  PARA_MM_LP_MAX = 1.03;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;
  int nEvent_Lp    = 0;
  int nEvent_Lpn   = 0;

  int nG4Event_piSpn   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_nCDH = 0;
  int nAbort_nT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_ftarget = 0;
  int nAbort_CDHiso = 0;
  int nAbort_pppi = 0;
  int nAbort_end = 0;

  int nFill_pippim = 0;
  int nFill_pippimn = 0;

  int nTrack_CDHshare = 0;

  int ev_cdc = 0;

  //=== event loop ===//
  for( int iev=0; iev<exen; iev++ ){
    if( /*iev<100 ||*/ iev%100==0 ) std::cout<<"> Event Number "<< iev <<std::endl;
    std::cout<<"> Event Number "<<iev<<std::endl;

    Tools::Fill1D( Form("EventCheck"), 1 );

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(iev); // MC
    evTree->GetEntry(ev_cdc); // CDC-tracking
    
    //### event ID matching
    if( evHeaderMC->eventID()!=header->ev() ){
      continue;
    }
    ev_cdc++;


    //### CDH ADC cut ###//TODO check this later
    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ){
      if( !(detData->detectorHit(i)->detectorID()==CID_CDH && detData->detectorHit(i)->adc()<ADC_CDH_MIN) ){
	detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }


    simMan->Convert(detData2, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);
    bltrackMan->DoTracking(blMan, confMan, true, true);


    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4Decay = false;
    bool piSpn_detect = false;
    int pi_parent  = 0;
    int Y_parent  = 0;
    int N_parent  = 0;
    //for( int itrk=0; itrk<mcData->trackSize(); itrk++ ){
    //  int pdgcode = mcData->track(itrk)->pdgID();
    //  int parent  = mcData->track(itrk)->parentTrackID();
    //  int track   = mcData->track(itrk)->trackID();
    //}
    std::cerr<<"======================"<<std::endl;
    std::cerr<<std::endl;
    if(Verbosity_){
      for( int j=0; j<reacData->ParticleSize(); j++ ){
        std::cerr<<j<<" "<<reacData->PDG(j)<<" "<<reacData->GetParticle(j).P()<<std::endl;
      }
    }

    int reactionID = reacData->ReactionID();
    //These partcile IDs are defined in pythia6
    //see http://home.fnal.gov/~mrenna/lutp0613man2/node44.html
    //                              K-    pi-  S+     n     n     pi+
    int PDG_Spmode[kin::npart] = {-321, -211, 3222, 2112, 2112,  211}; // pi-Sigma+
    //                              K-    pi+  S-     n     n     pi-
    int PDG_Smmode[kin::npart] = {-321,  211, 3112, 2112, 2112, -211}; // pi+Sigma-
    int PDG[kin::npart] = {0, 0, 0, 0, 0, 0};
    for( int i=0; i<kin::npart; i++ ){
      if( reactionID==2120 )      PDG[i] = PDG_Spmode[i];
      else if( reactionID==2130 ) PDG[i] = PDG_Smmode[i];
    }
    // beam_K(K-), pi, Y, N, N, N from Y, pi from Y
    int parentID[7] = {0, pi_parent, Y_parent, N_parent, 0, -1, -1}; //to be modified ?
    int ID[7]       = {-1, -1, -1, -1, -1, -1, -1}; //to be modified ?
    int trackID[7]  = {-1, -1, -1, -1, -1, -1, -1}; //to be modified ?
    int nparticle = 0;

    for( int itrk=0; itrk<mcData->trackSize(); itrk++ ){
      int pdgcode = mcData->track(itrk)->pdgID();
      int parent  = mcData->track(itrk)->parentTrackID();
      int track   = mcData->track(itrk)->trackID();
      //cerr<<j<<" | "<<pdgcode<<" "<<parent<<" "<<track<<std::endl;
      for( int k=0; k<6; k++ ){ // index k to be modified
        if( pdgcode==PDG[k] && parent==parentID[k] && ID[k]==-1 ){
	  ID[k] = itrk;
	  trackID[k] = track;
	  nparticle++;
	  //cerr<<j<<","<<k<<" | "<<pdgcode<<" "<<parent<<" "<<track<<std::endl;
	  if( k==2 ){
	    parentID[5] = track;
	    parentID[6] = track;
	  }
	  if( k==3 || k==4 || k==5 ) std::cerr<<k<<" | "<<pdgcode<<" "<<parent<<" "<<track<<" "<<mcData->track(itrk)->momentum().Mag()
				      <<" ("<<mcData->track(itrk)->momentum().CosTheta()<<" , "<<mcData->track(itrk)->momentum().Phi()*360./TwoPi<<")"<<std::endl;
	  break;
	}
      }
    }
    //cerr<<" nparticle = "<<nparticle<<std::endl;
    if( nparticle==6 ) flagG4Decay = true;//to be checked 7->6 in E31

    int nCDHhit[7] = {0, 0, 0, 0, 0, 0, 0};
    if( flagG4Decay ){ // Y -> N pi decay
      for( int ihit=0; ihit<detData2->detectorHitSize(); ihit++ ){
	int cid    = detData2->detectorHit(ihit)->detectorID();
	int track  = detData2->detectorHit(ihit)->trackID();
	int parent = mcData->track(ihit)->parentTrackID();
	for( int k=1; k<7; k++ ){
	  if( cid==CID_CDH && track==trackID[k] ) nCDHhit[k]++;
	}
	//*** neutron hit search ***//
	for( int k=4; k<6; k++ ){
	  if( cid==CID_CDH && parent==trackID[k] ) nCDHhit[k]++;
	}
	//*** neutron hit search ***//
      }//ihit
    }//flagG4Decay
    if( nCDHhit[1] && nCDHhit[3] && nCDHhit[5] && nCDHhit[6] ){
      piSpn_detect = true;
      nG4Event_piSpn++;
    }

    
    //*** for kinematical fit ***//
    // beam_K(K+), pi, Y, N, N, N from Sigma, pi from Sigma
    TLorentzVector TL_gene[kin::npart]; // generated
    for( int i=0; i<kin::npart; i++ ){
      if( i ) TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*0.001,  pdg->GetParticle(PDG[i])->Mass()); // GeV
      else    TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*-0.001, pdg->GetParticle(PDG[i])->Mass()); // GeV
    }
    //##########################//
    //### get G4 information ###//
    //##########################//


    int nGoodTrack = cdstrackMan->nGoodTrack();
    int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;
    Tools::Fill1D( Form("nGoodTrack"), nGoodTrack );

    if( nGoodTrack!=2 ){ // dedicated for pi+ pi- event
      nAbort_nGoodTrack++;
      continue;
    }

    //** # of CDH-hits cut **// 
    int nCDH = 0;
    for( int i=0; i<cdsMan->nCDH(); i++ ){
      //if( cdsMan->CDH(i)->CheckRange() ){
      if( cdsMan->CDH(i)->CheckRange() && cdsMan->CDH(i)->ctmean()<TDC_CDH_MAX ){
	nCDH++;
      }
    }
    Tools::Fill1D( Form("mul_CDH"), nCDH );
    if( nCDH!=3 ){ //** only 3 hits events **// pi+, pi-, neutron from Sigma
      nAbort_nCDH++;
      continue;
    }

    //** T0 = 1hit selection **//
    int nT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      HodoscopeLikeHit *hit = blMan->T0(i);
      if( hit->CheckRange() ) nT0++;
    }
    Tools::Fill1D( Form("mul_T0"),  nT0 );
    if( nT0!=1 ){ 
      nAbort_nT0++;
      continue;
    }

    //** Beam PID **//
    double ctmT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      if( blMan->T0(i)->CheckRange() ){
	ctmT0 = blMan->T0(i)->ctmean();
      }
    }
    int pid_beam = 0; //0:K 1:pi 3:else

    //** BPC track selection **//
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ){
      nbpc++;
      bpcid = i;
    }
    Tools::Fill1D( Form("ntrack_BPC"), nbpc );
    if( nbpc!=1 ){
      nAbort_nbpc++;
      continue;
    }
    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);    
    if( bpctrack->chi2all()>10 ){
      nAbort_bpctrack++;
      continue;
    }

    //** vertex calculation **//
    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ){
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }


    //** vectors for PID container **//
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    std::vector <int> d_ID;
    
    std::vector <int> vCDHseg;

    bool flagbmom = false;
    TVector3 vtx_react;

    //** BLC2 track **//
    int nblc2 = 0;
    int blc2id = -1;
    for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ){
      nblc2++;
      if( bltrackMan->trackBLC2(iblc2trk)->chi2all()<10 ) blc2id = iblc2trk;
    }
    Tools::Fill1D( Form("ntrack_BLC2"), nblc2 );
    if( !(nblc2==1 && blc2id!=-1) ){
      nAbort_nblc2++;
      continue;
    }

    //### BLC2-BPC position matching
    bool fblc2bpc = false;
    for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ){
      if( iblc2trk!=blc2id ) continue;
      LocalTrack *blc2 = bltrackMan->trackBLC2(iblc2trk);
      double xblc2bpc[2], yblc2bpc[2];
      double xmom[2], ymom[2];

      TVector3 Pos_BPC, Pos_BLC2, tmp;
      confMan->GetBLDCWireMapManager()->GetGParam( CID_BPC, Pos_BPC, tmp );
      confMan->GetBLDCWireMapManager()->GetGParam( CID_BLC2a, Pos_BLC2, tmp );
      double zPos_BPC = Pos_BPC.Z();
      double zPos_BLC2 = Pos_BLC2.Z();
      double zPos_BPC_BLC2 = (Pos_BPC.Z()+Pos_BLC2.Z())/2;

      bpctrack->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[0], yblc2bpc[0] );
      bpctrack->XYPosatZ( zPos_BPC, xmom[0], ymom[0] );
      blc2->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[1], yblc2bpc[1]);
      blc2->XYPosatZ( zPos_BLC2, xmom[1], ymom[1]);
      double dxdz[2], dydz[2];
      dxdz[0] = (xmom[0]-xblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
      dxdz[1] = (xmom[1]-xblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);
      dydz[0] = (ymom[0]-yblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
      dydz[1] = (ymom[1]-yblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);

      if( (xblc2bpc[1]-xblc2bpc[0])<PARA_blc2bpc_dx_MIN ||
	       (xblc2bpc[1]-xblc2bpc[0])>PARA_blc2bpc_dx_MAX ) fblc2bpc = false;
      else if( (yblc2bpc[1]-yblc2bpc[0])<PARA_blc2bpc_dy_MIN ||
	       (yblc2bpc[1]-yblc2bpc[0])>PARA_blc2bpc_dy_MAX ) fblc2bpc = false;
      else if( (dxdz[1]-dxdz[0])<PARA_blc2bpc_dxdz_MIN ||
	       (dxdz[1]-dxdz[0])>PARA_blc2bpc_dxdz_MAX ) fblc2bpc = false;
      else if( (dydz[1]-dydz[0])<PARA_blc2bpc_dydz_MIN ||
	       (dydz[1]-dydz[0])>PARA_blc2bpc_dydz_MAX ) fblc2bpc = false;
      else fblc2bpc = true;

      Tools::Fill2D( Form("dydx_BLC2BPC"), xblc2bpc[1]-xblc2bpc[0], yblc2bpc[1]-yblc2bpc[0] );
      Tools::Fill2D( Form("dydzdxdz_BLC2BPC"), dxdz[1]-dxdz[0], dydz[1]-dydz[0] );
    }//iblc2trk

    if( !fblc2bpc ){
      nAbort_fblc2bpc++;
      continue;
    }

    //** beam momentum calculation **//
    TLorentzVector LVec_beambf;  // 4-Momentum(beam) in LAB
    TLorentzVector LVec_beam;    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector LVec_target;  // 4-Momentum(He3-target) in LAB
    TLorentzVector LVec_targetP; // 4-Momentum(p-target) in LAB
    TLorentzVector LVec_beambfCM;  // 4-Momentum(beam) in CM
    TLorentzVector LVec_beamCM;    // 4-Momentum(beam) in CM with dE correcion
    TLorentzVector LVec_targetCM;  // 4-Momentum(He3-target) in CM
    TLorentzVector LVec_targetPCM; // 4-Momentum(p-target) in CM

    TVector3 Pos_T0;
    confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
    double zPos_T0 = Pos_T0.Z();

    double beammom = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      if( pdgcode==-321 && parent==0 ){
	beammom = (mcData->track(j)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
	break;
      }
    }

    double x1, y1, x2, y2;
    double z1 = 0, z2 = 20;
    bpctrack->XYPosatZ(z1, x1, y1);
    bpctrack->XYPosatZ(z2, x2, y2);
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls; 
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    LVec_beambf.SetVectM(Pp_beam , kpMass);
    LVec_target.SetVectM(Pp_target, dMass);
    LVec_targetP.SetVectM(Pp_target, pMass);
    LVec_beam = LVec_beambf;
    TVector3 boost = (LVec_target+LVec_beam).BoostVector();
    LVec_beambfCM = LVec_beam;
    LVec_targetCM = LVec_target;
    LVec_targetPCM = LVec_targetP;
    LVec_beambfCM.Boost(-1.*boost);
    LVec_targetCM.Boost(-1.*boost);
    LVec_targetPCM.Boost(-1.*boost);
    flagbmom = true;

    if( !flagbmom ){
      nAbort_flagbmom++;
      continue;
    }
    Tools::Fill1D( Form("momentum_beam"), LVec_beambf.P() );

    //** + + + + + + + + + + + + **//
    //**  PID in CDS             **//
    //** + + + + + + + + + + + + **//

    int CDHseg=0;

    //** PID of CDS tracks **//
    for( int icdstrk=0; icdstrk<cdstrackMan->nGoodTrack(); icdstrk++ ){
      CDSTrack *cdstrack = cdstrackMan->Track(cdstrackMan->GoodTrackID(icdstrk));

      Tools::Fill1D( Form("trackchi2_CDC"), cdstrack->Chi() );

      if( cdstrack->Chi()>30 ) continue; 
      if( !cdstrack->CDHFlag() ) continue;

      double mom = cdstrack->Momentum();
      TVector3 vtxb1, vtxb2, vtxb;
      cdstrack->GetVertex( bpctrack->GetPosatZ(zPos_T0), bpctrack->GetMomDir(), vtxb1, vtxb2 );
      cdstrack->SetPID(-1);
      vtxb = (vtxb1+vtxb2)*0.5;

      double tof = 999.;
      double mass2 = -999.;
      for( int icdhhit=0; icdhhit<cdstrack->nCDHHit(); icdhhit++ ){
        HodoscopeLikeHit *cdhhit = cdstrack->CDHHit(cdsMan,icdhhit);
        double tmptof = cdhhit->ctmean() - ctmT0;      
        //cerr<<icdh<<": "<<cdhhit->ctmean()<<" - "<<ctmT0<<" = "<<tmptof<<std::endl;
        if( tmptof<tof || tof==999. ){ //*** apply minimum TOF hit ***//
          tof = tmptof;
          CDHseg = cdhhit->seg();
        }
      }//icdh
      //*************************************
      // In a CDH hit-shared event, only some one track is adopted and the others are discarded
      //*************************************

      bool CDHflag = true;
      for( int icdhseg=0; icdhseg<(int)vCDHseg.size(); icdhseg++ ){
        if( CDHseg==vCDHseg[icdhseg] ) CDHflag = false;
      }
      if( !CDHflag ){
        nTrack_CDHshare++;
        continue;
      }
      vCDHseg.push_back(CDHseg);

      //** calculation of beta and squared-mass **//
      double tmptof, beta_calc;
      if( !TrackTools::FindMass2( cdstrack, bpctrack, tof, LVec_beam.Vect().Mag(),
				  pid_beam, beta_calc, mass2, tmptof ) ){
        std::cerr<<" !!! failure in PID_CDS [FindMass2()] !!! "<<std::endl;
        continue;
      }
      int pid = TrackTools::PIDcorr(mom,mass2);      
      cdstrack->SetPID(pid);
      Tools::Fill2D( "PID_CDS_beta", 1./beta_calc, mom );
      Tools::Fill2D( "PID_CDS", mass2, mom );

      //** energy loss calculation **//
      double tmpl;
      TVector3 vtx_beam, vtx_cds;
      if( !cdstrack->CalcVertexTimeLength(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), cdstrack->Mass(),
				       vtx_beam, vtx_cds, tmptof, tmpl, true) ){
        std::cerr<<" !!! failure in energy loss calculation [CalcVertexTimeLength()] !!! "<<std::endl;
        continue;
      }

      if( pid==CDS_PiMinus )
        pim_ID.push_back(cdstrackMan->GoodTrackID(icdstrk));
      else if( pid==CDS_PiPlus )
        pip_ID.push_back(cdstrackMan->GoodTrackID(icdstrk));
      else if( pid==CDS_Proton )
        p_ID.push_back(cdstrackMan->GoodTrackID(icdstrk));
      else if( pid==CDS_Deuteron )
        d_ID.push_back(cdstrackMan->GoodTrackID(icdstrk));
      else if( pid==CDS_Kaon )
        km_ID.push_back(cdstrackMan->GoodTrackID(icdstrk));
      
      if( pid<7 ) nTrack_PID++;

      //cerr<<"    pid = "<<pid<<", tof = "<<tmptof<<", beta = "<<beta_calc
      //<<", mom = "<<mom<<", mass = "<<sqrt(fabs(mass2))<<std::endl;

    }// for icdstrk
    //** end of PID **//

    Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+d_ID.size()+pim_ID.size()+km_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_plus"),  pip_ID.size() );
    Tools::Fill1D( Form("ntrack_proton"),   p_ID.size() );
    Tools::Fill1D( Form("ntrack_deuteron"), d_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_minus"), pim_ID.size() );
    Tools::Fill1D( Form("ntrack_K_minus"),  km_ID.size() );



    //** charge veto with BVC, CVC (TOF=CVC), & PC **//
    int nBVC = 0;
    int nCVC = 0;
    int nPC  = 0;
    for( int i=0; i<blMan->nBVC(); i++ ){
      if( blMan->BVC(i)->CheckRange() ) nBVC++;
    }
    for( int i=0; i<blMan->nTOF(); i++ ){
      if( blMan->TOF(i)->CheckRange() ) nCVC++;
    }
    for( int i=0; i<blMan->nPC(); i++ ){
      if( blMan->PC(i)->CheckRange() ) nPC++;
    }
    Tools::Fill1D( Form("mul_BVC"), nBVC );
    Tools::Fill1D( Form("mul_CVC"), nCVC );
    Tools::Fill1D( Form("mul_PC"),  nPC );
    bool chargedhit = false;
    if( nBVC || nCVC || nPC ) chargedhit = true;


#if 0
    //** find neighboring hits on CDH **//
    std::vector <int> nCDHseg;     // neutral hit candidates
    std::vector <int> CDHhit_list; // CDH hit container
    for( int n=0; n<cdsMan->nCDH(); n++ ){
      if( cdsMan->CDH(n)->CheckRange() && cdsMan->CDH(n)->ctmean()<TDC_CDH_MAX ){
        CDHhit_list.push_back( cdsMan->CDH(n)->seg() );
      }
    }
    std::sort(vCDHseg.begin(), vCDHseg.end());
    std::sort(CDHhit_list.begin(), CDHhit_list.end());
    std::set_difference( CDHhit_list.begin(), CDHhit_list.end(),
                         vCDHseg.begin(), vCDHseg.end(),
                         std::back_inserter(nCDHseg) );

    int nCDH_neighb = 0;
    for( int l=0; l<(int)nCDHseg.size(); l++ ){   // neutral hit candidates
      int flag_neighb = 0;
      for( int m=0; m<(int)vCDHseg.size(); m++ ){ // track associated hits
	if( abs(nCDHseg[l]-vCDHseg[m])==1 || abs(nCDHseg[l]-vCDHseg[m])==35 ) flag_neighb++;
      }
      if( flag_neighb ) nCDH_neighb++;
    }
    std::cerr<<"all   hits : ";
    for( int n=0; n<(int)CDHhit_list.size(); n++ ){
      std::cerr<<CDHhit_list[n]<<" ";
    } std::cerr<<std::endl;
    std::cerr<<"track hits : ";
    for( int n=0; n<(int)vCDHseg.size(); n++ ){
      std::cerr<<vCDHseg[n]<<" ";
    } std::cerr<<std::endl;
    std::cerr<<"diff  hits : ";
    for( int n=0; n<(int)nCDHseg.size(); n++ ){
      std::cerr<<nCDHseg[n]<<" ";
    } std::cerr<<std::endl;
    std::cerr<<" nCDH = "<<nCDH<<", nCDH_neighb = "<<nCDH_neighb<<std::endl;

    //** re-count CDH multiplicity **//
    int nCDHc = nCDH-nCDH_neighb;
#endif


    //** + + + + + + + + + + + **//
    //**  pi+ pi- X event  **//
    //** + + + + + + + + + + + **//
    
    if( flagbmom && pim_ID.size()==1 && pip_ID.size()==1 && cdstrackMan->nGoodTrack()==2 && !chargedhit ){
      
      nFill_pippim++;
      
      //** find CDH hit from neutral particles **//
      std::vector <int> nCDHseg;
      std::vector <int> CDHhit_list;
      for( int icdhhit=0; icdhhit<cdsMan->nCDH(); icdhhit++ ){
        if( cdsMan->CDH(icdhhit)->CheckRange() && cdsMan->CDH(icdhhit)->ctmean()<TDC_CDH_MAX )
          CDHhit_list.push_back( cdsMan->CDH(icdhhit)->seg() );
      }
      std::sort(vCDHseg.begin(), vCDHseg.end());
      std::sort(CDHhit_list.begin(), CDHhit_list.end());
      std::set_difference( CDHhit_list.begin(), CDHhit_list.end(),
			   vCDHseg.begin(), vCDHseg.end(),
			   std::back_inserter(nCDHseg) );

      if( nCDHseg.size()!=1 ){
        std::cerr<< "L." << __LINE__ << " CDH neutral hit is not 1 :: "<<nCDHseg.size()<<std::endl;
      }
      
      if(Verbosity_){
        std::cerr<<"# of diff = "<<nCDHseg.size()<<std::endl;
        std::cerr<<"CDH hits =   ";
        for( int n=0; n<(int)CDHhit_list.size(); n++ ){
          std::cerr<<CDHhit_list[n]<<" ";
        } std::cerr<<std::endl;
        std::cerr<<"track hits = ";
        for( int n=0; n<(int)vCDHseg.size(); n++ ){
          std::cerr<<vCDHseg[n]<<" ";
        } std::cerr<<std::endl;
        std::cerr<<"diff hits =  ";
        for( int n=0; n<(int)nCDHseg.size(); n++ ){
          std::cerr<<nCDHseg[n]<<" ";
        } std::cerr<<std::endl;
      }

      //** isolation cut **//
      int flag_isolation = 0;
      for( int l=0; l<(int)nCDHseg.size(); l++ ){
        for( int m=0; m<(int)CDHhit_list.size(); m++ ){
          if( nCDHseg[l]-CDHhit_list[m] ) Tools::Fill1D( Form("diff_CDH"), nCDHseg[l]-CDHhit_list[m] );
          if( abs(nCDHseg[l]-CDHhit_list[m])==1 || abs(nCDHseg[l]-CDHhit_list[m])==35 )
            flag_isolation++;
        }
      }
      if( flag_isolation ){
        std::cerr<<"CDH hit candidate is NOT isolated !!!"<<std::endl;
        nAbort_CDHiso++;
        continue;
      }
      
      //** copy neutral CDH hit candidate **//
      int icdh = -1;
      for( int icdhhit=0; icdhhit<cdsMan->nCDH(); icdhhit++ ){
        if( cdsMan->CDH(icdhhit)->seg()==nCDHseg[0] ) icdh = icdhhit;
      }
      HodoscopeLikeHit *ncdhhit = cdsMan->CDH(icdh);
      
      //** charge veto using CDC **//
      TVector3 Pos_CDH;
      confMan->GetGeomMapManager()->GetPos( CID_CDH, ncdhhit->seg(), Pos_CDH );
      //std::cerr<<"CDH candidate = "<<ncdhhit->seg()<<" -> "<<Pos_CDH.Phi()/TwoPi*360<<" deg"<<std::endl;
      
      const double PhiMin = -15.0/360.*TwoPi; // rad
      const double PhiMax =  15.0/360.*TwoPi; // rad
      //std::cerr<<"Min/Max = "<<PhiMin/TwoPi*360<<"/"<<PhiMax/TwoPi*360<<" deg"<<std::endl;
      
      int nCDC = 0;
      for( int ilr=14; ilr<16; ilr++ ){ // charge veto using layer 14, 15
        for( int icdhhit=0; icdhhit<cdsMan->nCDC(ilr); icdhhit++ ){
          CDCHit *cdc=cdsMan->CDC(ilr,icdhhit);
          TVector3 Pos_CDC = cdc->wpos();
          Pos_CDC.SetZ(0); // only xy pos is used
          double angle = Pos_CDC.Angle(Pos_CDH); // rad
          //std::cerr<<"CDC "<<l<<" "<<m<<" "<<cdc->wire()<<" -> "<<Pos_CDC.Phi()/TwoPi*360
          //<<" deg :: diff = "<<angle/TwoPi*360<<" deg"<<std::endl;
          Tools::Fill1D( Form("diff_CDH_CDC"), angle/TwoPi*360 );
          if( PhiMin<angle && angle<PhiMax ) nCDC++;
        }
      }
      //std::cerr<<"# of CDC hits for nCDH candidate = "<<nCDC<<std::endl;
      
      //Pos_CDH.SetZ(-1*ncdhhit->hitpos()); // (-1*) is wrong in SIM [20170925]
      Pos_CDH.SetZ(ncdhhit->hitpos());
      
      //** neutral particle in CDH **//
      if( !nCDC ){
        CDSTrack *track_pip = cdstrackMan->Track( pip_ID[0] ); // only 1 track
        CDSTrack *track_pim = cdstrackMan->Track( pim_ID[0] ); // only 1 track
	       
        //TODO : fix vertex RECONSTRUCTION !
        TVector3 vtx_b; // Vertex(baem-particle)_on_beam
        TVector3 vtx_p; // Vertex(baem-particle)_on_particle
        //track_p->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_b, vtx_p );
        vtx_react = 0.5*(vtx_b+vtx_p); // reaction vertex

        //double tof = 999.;
        //for( int icdh=0; icdh<track_p->nCDHHit(); icdh++ ){
        //  HodoscopeLikeHit *cdhhit = track_p->CDHHit( cdsMan, icdh );
        //  double tmptof = cdhhit->ctmean()-ctmT0;
        //  if( tmptof<tof || tof==999. ){
        //    tof = tmptof;
        //    CDHseg = cdhhit->seg();
        //  }
        //}
	
        // beam kaon tof 
        TVector3 Pos_T0;
        confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
        double beamtof, momout;
        double z_pos = Pos_T0.Z();;
        ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), vtx_react,
            LVec_beambf.Vect().Mag(), kpMass, momout, beamtof );
        // LVec_beam.SetVectM( momout*LVec_beambf.Vect().Unit(), kpMass ); // not need energy-loss correction [20180329]
        double ntof = ncdhhit->ctmean()-ctmT0-beamtof;
        double nlen = (Pos_CDH-vtx_react).Mag();
        beta = nlen/ntof/(Const*100.);
        double tmp_mom = beta<1. ? nMass*beta/sqrt(1-beta*beta) : 0;
        std::cerr<<"$$$ beta = "<<beta<<" mom_n = "<<tmp_mom<<std::endl; //" "<<1/sqrt(1+nMass*nMass)<<std::endl;
	
        //** reconstructoin of missing neutorn **//
        TVector3 P_pim; // Momentum(pi-)
        TVector3 P_pip; // Momentum(pi+)
        TVector3 P_n;   // Momentum(n)
	
        TLorentzVector LVec_pim; // 4-Momentum(pi-)
        TLorentzVector LVec_pip; // 4-Momentum(pi+)
        TLorentzVector LVec_n;   // 4-Momentum(n)
        TLorentzVector LVec_nmiss; // 4-Momentum(n_miss)

        track_pip->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_b, vtx_p );
        double dca_pip  = (vtx_b-vtx_p).Mag(); // DCA(beam-pip)
        if( !track_pip->GetMomentum( vtx_p, P_pip, true, true ) ){
          std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
        }
        track_pim->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_b, vtx_p );
        double dca_pim  = (vtx_b-vtx_p).Mag(); // DCA(beam-pim)
        if( !track_pim->GetMomentum( vtx_p, P_pim, true, true ) ){
          std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
        }
        P_n = tmp_mom*(Pos_CDH-vtx_react).Unit();
	
        std::cerr<<tmp_mom<<" ("<<P_n.CosTheta()<<" , "<<P_n.Phi()*360./TwoPi<<")"<<std::endl;

        LVec_pim.SetVectM( P_pim, piMass );
        LVec_pip.SetVectM( P_pip, piMass );
        LVec_n.SetVectM(   P_n,   nMass );
	
        double mm_mass   = (LVec_target+LVec_beam-LVec_pim-LVec_pip-LVec_n).M();
        TVector3 P_missn = (LVec_target+LVec_beam-LVec_pim-LVec_pip-LVec_n).Vect();
        LVec_nmiss.SetVectM( P_missn, nMass );
        std::cerr<<"  missing mass = "<<mm_mass<<std::endl;
	
        TVector3 boost = (LVec_target+LVec_beam).BoostVector();
        TLorentzVector LVec_nmiss_CM = LVec_nmiss;
        TLorentzVector LVec_beam_CM = LVec_beam;
        LVec_nmiss_CM.Boost(-boost);
        LVec_beam_CM.Boost(-boost);
        double cos_n = LVec_nmiss_CM.Vect().Dot(LVec_beam_CM.Vect())/(LVec_nmiss_CM.Vect().Mag()*LVec_beam_CM.Vect().Mag());
        std::cerr<<"  missing mom = "<<LVec_nmiss.P()<<" | cos_CM = "<<cos_n<<std::endl;
	
	
        //** + + + + + + + + + + + + + **//
        //**  fill histograms & tree   **//
        //** + + + + + + + + + + + + + **//
	
        const double beta_MAX = 0.728786; // p = 1.0 GeV/c for neutron & 1/beta = 1.372
        //const double dE_MIN = 5.0; // 8.0MeVee * 3cm / 5cm;
        const double dE_MIN = 0.0;
	
        const double pipi_MIN = 0.485;
        const double pipi_MAX = 0.510;
	
        const double neutron_MIN = 0.85;
        const double neutron_MAX = 1.03;
	
        const double Sigmap_MIN = 1.18;
        const double Sigmap_MAX = 1.20;
        const double Sigmam_MIN = 1.19;
        const double Sigmam_MAX = 1.21;

        kf_flag = -1;
	
        Tools::Fill2D( Form("dE_betainv"), 1./beta, ncdhhit->emean() );
        Tools::Fill2D( Form("MMom_MMass"), mm_mass, P_missn.Mag() );
	
        if( GeomTools::GetID(vtx_react)==CID_Fiducial ){
          Tools::Fill2D( Form("dE_betainv_fiducial"), 1./beta, ncdhhit->emean() );
          Tools::Fill2D( Form("MMom_MMass_fiducial"), mm_mass, P_missn.Mag() );
  
          if(  beta<beta_MAX ){
            Tools::Fill2D( Form("dE_betainv_fiducial_beta"), 1./beta, ncdhhit->emean() );
            Tools::Fill2D( Form("MMom_MMass_fiducial_beta"), mm_mass, P_missn.Mag() );
	    
            if( dE_MIN<ncdhhit->emean() ){
              Tools::Fill2D( Form("dE_betainv_fiducial_beta_dE"), 1./beta, ncdhhit->emean() );
              Tools::Fill2D( Form("MMom_MMass_fiducial_beta_dE"), mm_mass, P_missn.Mag() );
	      
              Tools::Fill1D( Form("IMpipi"), (LVec_pim+LVec_pip).M() );

              // ********************** //	      
              // *** pi Sigma mode *** //
              // ********************** //
              // 1: Sigma reconstruction,  vertex = K- & p
              if(((LVec_pim+LVec_pip).M()<pipi_MIN || pipi_MAX<(LVec_pim+LVec_pip).M())){ // K0 subtraction
                Tools::Fill2D( Form("dE_betainv_fiducial_beta_dE_res"), 1./beta, ncdhhit->emean() );
                Tools::Fill2D( Form("MMom_MMass_fiducial_beta_dE_res"), mm_mass, P_missn.Mag() );
		
                if( neutron_MIN<mm_mass && mm_mass<neutron_MAX ){ // missing n selection
                  Tools::Fill2D( Form("dE_betainv_fiducial_beta_dE_res_n"), 1./beta, ncdhhit->emean() );
                  Tools::Fill2D( Form("MMom_MMass_fiducial_beta_dE_res_n"), mm_mass, P_missn.Mag() );

                  Tools::Fill2D( Form("MMom_NMom"), P_n.Mag(), P_missn.Mag() );
                  Tools::Fill2D( Form("IMnpim_IMnpip"), (LVec_n+LVec_pip).M(), (LVec_n+LVec_pim).M() );
		  
                  if( (Sigmap_MIN<(LVec_n+LVec_pip).M() && (LVec_n+LVec_pip).M()<Sigmap_MAX) ||
                      (Sigmam_MIN<(LVec_n+LVec_pim).M() && (LVec_n+LVec_pim).M()<Sigmam_MAX) ){ // Sigma selection
                    Tools::Fill2D( Form("IMmnpim_IMmnpip"), (LVec_nmiss+LVec_pip).M(), (LVec_nmiss+LVec_pim).M() );
                    Tools::Fill2D( Form("MMnpip_MMnpim"), (LVec_target+LVec_beam-LVec_pim-LVec_n).M(),
                        (LVec_target+LVec_beam-LVec_pip-LVec_n).M() );

                    Tools::Fill2D( Form("Cosn_IMnpipi"), (LVec_n+LVec_pim+LVec_pip).M(), cos_n );
                    Tools::Fill2D( Form("IMnpipi_IMnppipi"), (LVec_n+LVec_pim+LVec_pip).M(), (LVec_n+LVec_pim+LVec_pip).M() );

                    Tools::Fill1D( Form("DCA_pip"), dca_pip );
                    Tools::Fill1D( Form("DCA_pim"), dca_pim );
                  }
                } // if( neutron_MIN<mm_mass && mm_mass<neutron_MAX )

                // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
                // %%% Kinematical Fit using KinFitter %%% //
                // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
                //--- set TLorentzVector for MC study---//
                // beam_K(K+), pi-/+, Sigma+/-, n, n from S, pi+/- from S 
                //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+ ( reactionID==2120 )
                //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma- ( reactionID==2130 )
                TLorentzVector TL_meas[kin::npart]; // measured
                TL_meas[kin::kmbeam] = LVec_beam;
                TL_meas[kin::nmiss] = LVec_nmiss; // * which n?
                TL_meas[kin::ncds] = LVec_n;     // * which n?
                if( reactionID==2120 ){//TODO modify later
                  TL_meas[kin::pim_g1] = LVec_pim;
                  TL_meas[kin::Sp] = (LVec_n+LVec_pip);
                  TL_meas[kin::pip_g2] = LVec_pip;
                } else if ( reactionID==2130 ){
                  TL_meas[kin::pip_g1] = LVec_pip;
                  TL_meas[kin::Sm] = (LVec_n+LVec_pim);
                  TL_meas[kin::pim_g2] = LVec_pim;
                }

                double val1 = (TL_meas[kin::ncds]-TL_gene[kin::nmiss]).P(); // n_measured - n_initial
                double val2 = (TL_meas[kin::ncds]-TL_gene[kin::ncds]).P(); // n_measured - n_Sigma
                int genID[7] = {0,1,2,3,4,5,6};
                if( val1<val2 ){ // is there more good selection way?
                  genID[4] = 5;//TODO modify later
                  genID[5] = 4;//TODO modify later
                }
		std::cerr<<" val = "<<val1<<" "<<val2<<" -> "<<genID[4]<<" "<<genID[5]<<std::endl;
		mcmom_beam = TL_gene[kin::kmbeam];
		mcmom_n    = TL_gene[genID[5]];
		if( reactionID==2120 ){
		  mcmom_pip  = TL_gene[kin::pip_g2];
		  mcmom_pim  = TL_gene[kin::pim_g1];
		} else if ( reactionID==2130 ){
		  mcmom_pip  = TL_gene[kin::pip_g1];
		  mcmom_pim  = TL_gene[kin::pim_g2];
		}

		//--- set TLorentzVector ---//
		// beam_K(K+), pi-/+, Sigma+/-, p, n, n from S, pi+/- from S 
		//  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
		TLorentzVector TL_measSpmode[kin::npart]; // measured
		TL_measSpmode[kin::kmbeam] = LVec_beam;
		TL_measSpmode[kin::pim_g1] = LVec_pim;
		TL_measSpmode[kin::Sp] = (LVec_n+LVec_pip);
		TL_measSpmode[kin::nmiss] = LVec_nmiss;
		TL_measSpmode[kin::ncds] = LVec_n;
		TL_measSpmode[kin::pip_g2] = LVec_pip;
		//  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
		TLorentzVector TL_measSmmode[kin::npart]; // measured
		TL_measSmmode[kin::kmbeam] = LVec_beam;
		TL_measSmmode[kin::pip_g1] = LVec_pip;
		TL_measSmmode[kin::Sm] = (LVec_n+LVec_pim);
		TL_measSmmode[kin::nmiss] = LVec_nmiss;
		TL_measSmmode[kin::ncds] = LVec_n;
		TL_measSmmode[kin::pim_g2] = LVec_pim;
		TLorentzVector TL_kfitSpmode[kin::npart]; // kinematical fitted
		TLorentzVector TL_kfitSmmode[kin::npart]; // kinematical fitted
		// LVec_target is defined as (0, 0, 0, M_D2)
		TVector3 TV_target = LVec_target.Vect();
		TVector3 TV_measSpmode[kin::npart];
		TVector3 TV_measSmmode[kin::npart];
		for( int i=0; i<kin::npart; i++ ){
		  TV_measSpmode[i] = TL_measSpmode[i].Vect();
		  TV_measSmmode[i] = TL_measSmmode[i].Vect();
		}
		
		//--- KinFitter :: initialization ---//
		//  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip),  LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
		//  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim),  LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
		//*** definition of fit particles in cartesian coordinates ***//
		TString str_particleSpmode[kin::npart] = {"LVec_beam", "LVec_pim", "LVec_Sp",  "LVec_mn", "LVec_n", "LVec_pip"};
		TString str_particleSmmode[kin::npart] = {"LVec_beam", "LVec_pip", "LVec_Sm",  "LVec_mn", "LVec_n", "LVec_pim"};
		TFitParticlePxPyPz ParticleTgt = TFitParticlePxPyPz("target", "target", &TV_target,
								    pdg->GetParticle("deuteron")->Mass(), covZero);
		TFitParticlePxPyPz ParticleSpmode[kin::npart];
		TFitParticlePxPyPz ParticleSmmode[kin::npart];
		for( int i=0; i<kin::npart; i++ ){
		  ParticleSpmode[i] = TFitParticlePxPyPz(str_particleSpmode[i], str_particleSpmode[i], &TV_measSpmode[i],
						    pdg->GetParticle(PDG_Spmode[i])->Mass(), covParticleSpmode[i]);
		  ParticleSmmode[i] = TFitParticlePxPyPz(str_particleSmmode[i], str_particleSmmode[i], &TV_measSmmode[i],
						    pdg->GetParticle(PDG_Smmode[i])->Mass(), covParticleSmmode[i]);
		}
		//*** definition of constraints ***//
		// constraint :: mass of Sigma
		TFitConstraintM ConstMSSpmode = TFitConstraintM("M_Sp", "M_Sp", 0, 0, pdg->GetParticle(PDG_Spmode[kin::Sp])->Mass());
		TFitConstraintM ConstMSSmmode = TFitConstraintM("M_Sm", "M_Sm", 0, 0, pdg->GetParticle(PDG_Smmode[kin::Sm])->Mass());
		ConstMSSpmode.addParticles1(&ParticleSpmode[kin::ncds], &ParticleSpmode[kin::pip_g2]);
		ConstMSSmmode.addParticles1(&ParticleSmmode[kin::ncds], &ParticleSmmode[kin::pim_g2]);
		// constraint :: 4-momentum conservation
		TFitConstraintEp ConstEpSpmode[4];
		TFitConstraintEp ConstEpSmmode[4];
		TString str_constEpSpmode[4]  = {"Px", "Py", "Pz", "E"};
		TString str_constEpSmmode[4]  = {"Px", "Py", "Pz", "E"};
		for( int i=0; i<4; i++ ){
		  ConstEpSpmode[i] = TFitConstraintEp(str_constEpSpmode[i], str_constEpSpmode[i], 0, TFitConstraintEp::component(i), 0);
		  ConstEpSmmode[i] = TFitConstraintEp(str_constEpSmmode[i], str_constEpSmmode[i], 0, TFitConstraintEp::component(i), 0);
		  ConstEpSpmode[i].addParticles1(&ParticleTgt, &ParticleSpmode[kin::kmbeam]);
		  ConstEpSmmode[i].addParticles1(&ParticleTgt, &ParticleSmmode[kin::kmbeam]);
		  ConstEpSpmode[i].addParticles2(&ParticleSpmode[kin::pim_g1],&ParticleSpmode[kin::nmiss], &ParticleSpmode[kin::ncds], &ParticleSpmode[kin::pip_g2]);
		  ConstEpSmmode[i].addParticles2(&ParticleSmmode[kin::pip_g1],&ParticleSmmode[kin::nmiss], &ParticleSmmode[kin::ncds], &ParticleSmmode[kin::pim_g2]);
		}

		//--- KinFitter :: execution ---//
		//*** definition of the fitter ***//
		TKinFitter kinfitter_Spmode;
		TKinFitter kinfitter_Smmode;
		// add measured particles
		kinfitter_Spmode.addMeasParticles(&ParticleSpmode[kin::kmbeam], &ParticleSpmode[kin::pim_g1], &ParticleSpmode[kin::ncds], &ParticleSpmode[kin::pip_g2]); // K, pi-,  n, pi+
		kinfitter_Smmode.addMeasParticles(&ParticleSmmode[kin::kmbeam], &ParticleSmmode[kin::pip_g1], &ParticleSmmode[kin::ncds], &ParticleSmmode[kin::pim_g2]); // K, pi+,  n, pi-
		kinfitter_Spmode.addUnmeasParticles(&ParticleSpmode[kin::nmiss]); // missing-n
		kinfitter_Smmode.addUnmeasParticles(&ParticleSmmode[kin::nmiss]); // missing-n
		// add constraints
		kinfitter_Spmode.addConstraint(&ConstMSSpmode); // mass of Sigma+
		kinfitter_Smmode.addConstraint(&ConstMSSmmode); // mass of Sigma-
		for( int i=0; i<4; i++ ){
		  kinfitter_Spmode.addConstraint(&ConstEpSpmode[i]); // 4-momentum conservation
		  kinfitter_Smmode.addConstraint(&ConstEpSmmode[i]); // 4-momentum conservation
		}
		//*** perform the fit ***//
		kinfitter_Spmode.setMaxNbIter(50);       // max number of iterations
		kinfitter_Smmode.setMaxNbIter(50);       // max number of iterations
		kinfitter_Spmode.setMaxDeltaS(5e-5);     // max delta chi2
		kinfitter_Smmode.setMaxDeltaS(5e-5);     // max delta chi2
		kinfitter_Spmode.setMaxF(1e-4);          // max sum of constraints
		kinfitter_Smmode.setMaxF(1e-4);          // max sum of constraints
		kinfitter_Spmode.setVerbosity(KFDEBUG);  // verbosity level
		kinfitter_Smmode.setVerbosity(KFDEBUG);  // verbosity level
		kinfitter_Spmode.fit();
		kinfitter_Smmode.fit();
		//*** copy fit results ***//
		for( int i=0; i<kin::npart; i++ ){
		  TL_kfitSpmode[i] = (*ParticleSpmode[i].getCurr4Vec());
		  TL_kfitSmmode[i] = (*ParticleSmmode[i].getCurr4Vec());
		}
		TL_kfitSpmode[kin::Sp] = TL_kfitSpmode[kin::ncds]+TL_kfitSpmode[kin::pip_g2];
		TL_kfitSmmode[kin::Sm] = TL_kfitSmmode[kin::ncds]+TL_kfitSmmode[kin::pim_g2];


		int correct_flag = 0;
		if      ( kinfitter_Spmode.getStatus()==0 && kinfitter_Spmode.getS()<kinfitter_Smmode.getS() && reactionID==2120 ) correct_flag = 1;
		else if ( kinfitter_Smmode.getStatus()==0 && kinfitter_Smmode.getS()<kinfitter_Spmode.getS() && reactionID==2130 ) correct_flag = 1;

		double chi2 = kinfitter_Spmode.getS()<kinfitter_Smmode.getS() ? kinfitter_Spmode.getS():kinfitter_Smmode.getS();
		Tools::Fill2D( Form("KFchi2_vs"), kinfitter_Spmode.getS()/kinfitter_Spmode.getNDF(),
			       kinfitter_Smmode.getS()/kinfitter_Smmode.getNDF() );
		if( chi2 < 6 ) Tools::Fill1D( Form("KF_decision"), correct_flag );

		std::cerr<<"pi- S+ : status = "<<kinfitter_Spmode.getStatus()<<", chi2/NDF = "<<kinfitter_Spmode.getS()<<"/"<<kinfitter_Spmode.getNDF()<<std::endl;
		std::cerr<<"pi+ S- : status = "<<kinfitter_Smmode.getStatus()<<", chi2/NDF = "<<kinfitter_Smmode.getS()<<"/"<<kinfitter_Smmode.getNDF()<<std::endl;
		if      ( reactionID==2120 ) std::cerr<<"*** pi- S+ ==> "<<correct_flag<<" ***"<<std::endl;
		else if ( reactionID==2130 ) std::cerr<<"*** pi+ S- ==> "<<correct_flag<<" ***"<<std::endl;

		//** fill tree **//
		kfMomBeamSpmode   = TL_kfitSpmode[kin::kmbeam];
		kfMom_pip_Spmode    = TL_kfitSpmode[kin::pip_g2];
		kfMom_pim_Spmode    = TL_kfitSpmode[kin::pim_g1];
		kfMom_n_Spmode      = TL_kfitSpmode[kin::ncds];
		kf_chi2_Spmode      = kinfitter_Spmode.getS();
		kf_NDF_Spmode       = kinfitter_Spmode.getNDF();
		kf_status_Spmode    = kinfitter_Spmode.getStatus();
		kf_pvalue_Spmode    = ROOT::Math::chisquared_cdf_c(kinfitter_Spmode.getS(), kinfitter_Spmode.getNDF());
		kfMomBeamSmmode   = TL_kfitSmmode[kin::kmbeam];
		kfMom_pim_Smmode    = TL_kfitSmmode[kin::pim_g1];
		kfMom_pip_Smmode    = TL_kfitSmmode[kin::pip_g2];
		kfMom_n_Smmode      = TL_kfitSmmode[kin::ncds];
		kf_chi2_Smmode      = kinfitter_Smmode.getS();
		kf_NDF_Smmode       = kinfitter_Smmode.getNDF();
		kf_status_Smmode    = kinfitter_Smmode.getStatus();
		kf_pvalue_Smmode    = ROOT::Math::chisquared_cdf_c(kinfitter_Smmode.getS(), kinfitter_Smmode.getNDF());
		kf_flag       = reactionID; //correct_flag;

		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
		// %%% Kinematical Fit using KinFitter %%% //
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //

		//--- for the covariance matrix evaluation ---//
		if( flagG4Decay ){
		  if( neutron_MIN<mm_mass && mm_mass<neutron_MAX ){
		    if( (Sigmap_MIN<(LVec_n+LVec_pip).M() && (LVec_n+LVec_pip).M()<Sigmap_MAX) ||
			(Sigmam_MIN<(LVec_n+LVec_pim).M() && (LVec_n+LVec_pim).M()<Sigmam_MAX) ){
		      for( int i=0; i<kin::npart; i++ ){
            for( int j=0; j<4; j++ ){
              double val = (TL_meas[i][j] - TL_gene[genID[i]][j]);
              Tools::Fill1D(Form("cov_%d_%d_%d", i, j, j), val);
              //if( j==k ) std::cerr<<" cov "<<i<<" , "<<j<<" = "<<TL_meas[i][j]<<" - "<<TL_gene[i][j]
              //<<" = "<< (TL_meas[i][j] - TL_gene[i][j])<<std::endl;
            }
		      } // for
		    }
		  }
		}//if flagG4Decay


              } // if( ((LVec_pim+LVec_pip).M()<pipi_MIN || pipi_MAX<(LVec_pim+LVec_pip).M()) &&


		kf_flag       = reactionID; //correct_flag;
		
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
		// %%% Kinematical Fit using KinFitter %%% //
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //

		//--- for the covariance matrix evaluation ---//
		if( flagG4Decay ){
		  //cerr<<" flagG4Decay "<<flagG4Decay<<std::endl;
		  if( neutron_MIN<mm_mass && mm_mass<neutron_MAX ){
        for( int i=0; i<kin::npart; i++ ){
          for( int j=0; j<4; j++ ){
            double val = (TL_meas[i][j] - TL_gene[genID[i]][j]);
            Tools::Fill1D(Form("cov_%d_%d_%d", i, j, j), val);
            //if( j==k ) std::cerr<<" cov "<<i<<" , "<<j<<" = "<<TL_meas[i][j]<<" - "<<TL_gene[i][j]
            //<<" = "<< (TL_meas[i][j] - TL_gene[i][j])<<std::endl;
          }
        } // for( int i=0; i<7; i++ ){
		  }
		}

		

	      
	    } // if( dE_MIN<ncdhhit->emean() ){
	  } // if(  beta<beta_MAX ){

	  //** fill tree **//
	  mom_beam   = LVec_beam;   // 4-momentum(beam)
	  mom_target = LVec_target; // 4-momentum(target)
	  mom_pip = LVec_pip;        // 4-momentum(pi+)
	  mom_pim = LVec_pim;        // 4-momentum(pi-)
	  mom_n = LVec_n;            // 4-momentum(neutron)
	  dE = ncdhhit->emean();
	  // beta is already filled
	  vtx_reaction = vtx_react; // vertex(reaction)
	  run_num   = confMan->GetRunNumber(); // run number
	  event_num = iev;     // event number
	  block_num = 0;      // block number (temp)
  
	  std::cout<<"%%% pippimn event: Event_Number, Block_Event_Number, CDC_Event_Number = "
		   <<iev<<" , "<<" ---, "<<ev_cdc<<std::endl;
	  outfile2->cd();
	  pippimnTree->Fill();
	  outfile->cd();
	  nFill_pippimn++;
	  //** fill tree **//
	  
            } // if( GeomTools::GetID(vtx_react)==CID_Fiducial )
      } // if( !nCDC ){
    }
    else{
      nAbort_pppi++;
    }
    
    nAbort_end++;
    delete detData2;
    
  } // for iev
  
  std::cout<<"===== Sigma pi reconstruction in MC END ====="<<std::endl;
  std::cout<<" nEvent       = "<<exen<<std::endl;
  std::cout<<" nEvent_Lp    = "<<nEvent_Lp<<std::endl;
  std::cout<<" nEvent_Lpn   = "<<nEvent_Lpn<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nG4Event_piSpn  = "<<nG4Event_piSpn<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" AllGoodTrack = "<<AllGoodTrack<<std::endl;
  std::cout<<" nTrack       = "<<nTrack<<std::endl;
  std::cout<<" nTrack_PID   = "<<nTrack_PID<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nAbort_nGoodTrack  = "<<nAbort_nGoodTrack<<std::endl;
  std::cout<<" nAbort_nCDH        = "<<nAbort_nCDH<<std::endl;
  std::cout<<" nAbort_nT0         = "<<nAbort_nT0<<std::endl;
  std::cout<<" nAbort_nbpc        = "<<nAbort_nbpc<<std::endl;
  std::cout<<" nAbort_bpctrack    = "<<nAbort_bpctrack<<std::endl;
  std::cout<<" nAbort_nblc2       = "<<nAbort_nblc2<<std::endl;
  std::cout<<" nAbort_fblc2bpc    = "<<nAbort_fblc2bpc<<std::endl;
  std::cout<<" nAbort_flagbmom    = "<<nAbort_flagbmom<<std::endl;
  std::cout<<" nAbort_ftarget     = "<<nAbort_ftarget<<std::endl;
  std::cout<<" nAbort_CDHiso      = "<<nAbort_CDHiso<<std::endl;
  std::cout<<" nAbort_pppi        = "<<nAbort_pppi<<std::endl;
  std::cout<<" nAbort_end         = "<<nAbort_end<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<std::endl;
  std::cout<<"*** # of pi+ pi- p n n events = "<<nFill_pippimn<<" ***"<<std::endl;
  std::cout<<"==============================================="<<std::endl;

  outfile->Write();
  outfile->Close();

  outfile2->Write();
  outfile2->Close();

  simfile->Close();
  cdcfile->Close();

  delete pdg;

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}

//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
void InitializeHistogram()
//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
{
  //** geneneral informantion **//
  Tools::newTH1F( Form("Time"), 3000, -0.5, 2999.5 );
  Tools::newTH1F( Form("EventCheck"), 20, 0, 20 );
  Tools::newTH1F( Form("Scaler"), 41, -0.5, 40.5 );

  //** CDC and CDH information from CDC-trackig file **//
  Tools::newTH1F( Form("nGoodTrack"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_CDH"),Form("CDH multiplicity"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_CDH_assoc"), 11, -0.5, 10.5 );
  Tools::newTH2F( Form("CDHtime"), 36, -0.5, 35.5,1600,0,40);
  Tools::newTH1F( Form("CDHNeutralSeg"),36,-0.5,35.5);
  Tools::newTH1F( Form("npimangle"),628,0,2*3.14);
  Tools::newTH1F( Form("npipangle"),628,0,2*3.14);

  //** beam line **//
  Tools::newTH1F( Form("mul_BHD"), 12, -0.5, 11.5 );
  Tools::newTH1F( Form("mul_T0"),   6, -0.5, 5.5 );
  Tools::newTH1F( Form("tof_T0BHD"), 2000, 20, 40 );
  Tools::newTH1F( Form("tracktime_BPC"),  1200, -200, 400 );
  Tools::newTH1F( Form("trackchi2_BPC"),  200, 0, 20 );
  Tools::newTH1F( Form("ntrack_BPC"),  6, -0.5, 5.5 );
  Tools::newTH1F( Form("tracktime_BLC1"), 1200, -200, 400 );
  Tools::newTH1F( Form("tracktime_BLC2"), 1200, -200, 400 );
  Tools::newTH1F( Form("trackchi2_BLC1"), 200, 0, 20 );
  Tools::newTH1F( Form("trackchi2_BLC2"), 200, 0, 20 );
  Tools::newTH1F( Form("ntrack_BLC1"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_BLC2"), 6, -0.5, 5.5 );
  Tools::newTH2F( Form("dydx_BLC2BPC"),     130, -1.3, 1.3, 130, -1.3, 1.3 );
  Tools::newTH2F( Form("dydzdxdz_BLC2BPC"), 175, -0.035, 0.035, 175, -0.035, 0.035 );
  Tools::newTH1F( Form("trackchi2_beam"), 400, 0, 40 );
  Tools::newTH1F( Form("momentum_beam"), 180, 0.92, 1.10 );
  Tools::newTH1F( Form("PID_beam"),5,-1.5,3.5);

  //** CDS **//
  Tools::newTH1F( Form("trackchi2_CDC"), 1000, 0, 50 );
  Tools::newTH2F( Form("PID_CDS_beta"), 2000, 0, 10., 1000, -1.2, 1.2 );
  Tools::newTH2F( Form("PID_CDS"), 1000, -0.6, 5, 1000, -1.2, 1.2 );
  Tools::newTH1F( Form("ntrack_CDS"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_pi_plus"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_proton"), 6, -0.5, 5.5 );
  //Tools::newTH1F( Form("ntrack_deuteron"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_pi_minus"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_K_minus"), 6, -0.5, 5.5 );
  Tools::newTH2F( Form("Vtx_ZX"),1000,-25,25,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_ZY"),1000,-25,25,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_XY"),500,-12.5,12.5,500,-12.5,12.5);

  Tools::newTH2F( Form("Vtx_ZX_nofid"),1000,-25,25,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_ZY_nofid"),1000,-25,25,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_XY_nofid"),500,-12.5,12.5,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_ZX_fid"),1000,-25,25,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_ZY_fid"),1000,-25,25,500,-12.5,12.5);
  Tools::newTH2F( Form("Vtx_XY_fid"),500,-12.5,12.5,500,-12.5,12.5);
  //** forward counters **//
  Tools::newTH1F( Form("mul_BVC"), 9, -0.5, 8.5 );
  Tools::newTH1F( Form("mul_CVC"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_PC"), 11, -0.5, 10.5 );

  //** pi+ pi- X event **//
  Tools::newTH1F( Form("diff_CDH"), 73, -36.5, 36.5 );
  Tools::newTH1F( Form("diff_CDH_CDC"), 181, 0, 181 );
  Tools::newTH2F( Form("dE_betainv"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("dE_betainv_fid"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("dE_betainv_fid_beta"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("dE_betainv_fid_beta_dE"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("dE_betainv_fid_beta_dE_woK0"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("dE_betainv_fid_beta_dE_wK0"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("dE_betainv_fid_beta_dE_woK0_n"), 200, 0, 10, 200, 0, 50);
  Tools::newTH2F( Form("MMom_MMass"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid_beta"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid_beta_dE"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid_beta_dE_woK0"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid_beta_dE_woK0_wSid"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid_beta_dE_wK0"), 140, 0.4, 1.8, 100, 0, 1.5 );
  Tools::newTH2F( Form("MMom_MMass_fid_beta_dE_woK0_n"), 140, 0.4, 1.8, 100, 0, 1.5 );
 
  
  
  Tools::newTH1F( Form("IMpipi_dE"), 200, 0.4, 0.6 );
  Tools::newTH2F( Form("IMpipi_NMom_dE"),100,0, 1.5, 200, 0.4,0.6);

  Tools::newTH2F( Form("MMom_NMom"), 100, 0, 1.5, 100, 0, 1.5 );
  Tools::newTH2F( Form("IMnpim_IMnpip_dE"), 140, 1, 1.7, 140, 1, 1.7 );
  Tools::newTH2F( Form("IMnpim_IMnpip_wmn_dE"), 140, 1, 1.7, 140, 1, 1.7 );
  Tools::newTH2F( Form("IMmnpim_IMmnpip"), 70, 1, 1.7, 70, 1, 1.7 );
  Tools::newTH2F( Form("MMnpip_MMnpim"), 70, 1, 1.7, 70, 1, 1.7 );
  Tools::newTH2F( Form("Cosn_IMnpipi"), 100, 1, 2, 50, -1, 1 );
  Tools::newTH1F( Form("IMnpipi"), 100, 1, 2 );
  Tools::newTH1F( Form("IMnpipi_wSid"), 100, 1, 2 );
  Tools::newTH1F( Form("IMnpipi_woK0_wSid"), 100, 1, 2 );
  Tools::newTH2F( Form("IMnpipi_MMnmiss"),100,0,1.5,100,1,2);
  Tools::newTH2F( Form("IMnpipi_MMnmiss_wSid"),100,0,1.5,100,1,2);
  Tools::newTH2F( Form("IMnpipi_MMnmiss_woK0_wSid"),100,0,1.5,100,1,2);
  Tools::newTH2F( Form("IMnpipi_q_woK0_wSid"),200,0,2,100,1,2);
  Tools::newTH1F( Form("DCA_pip"), 500, 0, 5 );
  Tools::newTH1F( Form("DCA_pim"), 500, 0, 5 );
  Tools::newTH1F( Form("DCA_pip_SigmaP"), 500, 0, 5 );
  Tools::newTH1F( Form("DCA_pim_SigmaP"), 500, 0, 5 );
  Tools::newTH1F( Form("DCA_pip_SigmaM"), 500, 0, 5 );
  Tools::newTH1F( Form("DCA_pim_SigmaM"), 500, 0, 5 );
  Tools::newTH1F( Form("DCA_pippim"), 500, 0, 5);
   
  Tools::newTH2F( Form("KFchi2_vs"),100,0,100,100,0,100);
  return;
}
