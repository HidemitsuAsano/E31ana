//----------------------------------------------------------------//
// H.Asano Aug.8th, 2018
// UserSimIMPiSigma.cpp 
// originated from UserSimpipipnn.cpp 
// 
// the purpose is to reconstruct pi Sigma n event in p(K^-,Sigma^{+/-})"pi^{-/+}" reaction
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// Analysis method for neutron_cds is based on "EventAnalysis_pipipnn_sakuma.cpp"
//----------------------------------------------------------------//
//  exe-file: simIMpisigma [./simIMpisigma $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: when $(OutFile) is "tmp.root", the following 2 files are generated.
//     "tmp.root":      histogram file
//     "tmp_pipipnn.root": basic information of pippimn event is listed up in TTree 
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"

#include <TLorentzVector.h>
#include "TrackTools.h"
#include "EventHeader.h"
#include "Tools.h"
#include "ELossTools.h"

#include "IMPiSigmaAnaPar.h"
#include "IMPiSigmaHist.h"
#include "IMPiSigmaUtil.h"

#include <TDatabasePDG.h>
#include <Math/ProbFuncMathCore.h>



#define KFDEBUG 0 // verbosity level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices

int Verbosity_ = 0;//verbosity level of this code
const bool DoCDCRetiming = false;
const double MOM_RES = 2.0; // MeV/c
const bool IsVtxDoubleCheck = false;//Double check 2 vertex of pi+/pi- ?
const int IsolationCutFlag = 1;//2 is also avilable to check next-next segments
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)

//** cut parameters **//
double PARA_blc2bpc_dx_MIN;
double PARA_blc2bpc_dx_MAX;
double PARA_blc2bpc_dy_MIN;
double PARA_blc2bpc_dy_MAX;
double PARA_blc2bpc_dxdz_MIN;
double PARA_blc2bpc_dxdz_MAX;
double PARA_blc2bpc_dydz_MIN;
double PARA_blc2bpc_dydz_MAX;
double PARA_lnL_MAX;
double PARA_MM_LP_MIN;
double PARA_MM_LP_MAX;

const double ADC_CDH_MIN = 1;  // MeV

//= = = = pippimn final-sample tree = = = =//
TLorentzVector mom_beam;   // 4-momentum(beam)
TLorentzVector mom_target; // 4-momentum(target)
TLorentzVector mom_pi;    // 4-momentum(pi+)
int chargepi;
TLorentzVector mom_n;      // 4-momentum(neutron)
double NeutralBetaCDH; // verocity of neutral particle on CDH
double tofpi;
double tofn;
double dE;   // energy deposit on CDH
int neutralseg;   // energy deposit on CDH
int nhitOutCDC;
int ForwardCharge;
TVector3 vtx_reaction; //  vertex(reaction)   
TVector3 vtx_pi_beam; //  
TVector3 vtx_pi_cdc;
TVector3 CDH_Pos;
TVector3 CDH_Pos_pi;
int run_num;   // run number
int event_num; // event number
int block_num; // block number
int mc_nparticle;

//GEANT4 info after decay, interaction with detector, momentum is true
TLorentzVector mcmom_beam;  // generated 4-momentum(beam)
TLorentzVector mcmom_pi;   // generated 4-momentum(pi+)
int mcchargepi;   // generated 4-momentum(pi-)
TLorentzVector mcmom_ncds;    // generated 4-momentum(neutron)
TLorentzVector mcmom_pimiss;    // generated 4-momentum(neutron)
double mcncanvtxr;
double mcncanvtxz;
double mcfirstvtxr;
double mcfirstvtxz;
int mcncdsgen;
int mcpattern;
int mcnanc;

//GEANT4 info generated particle before interaction
TLorentzVector react_pimiss;
TLorentzVector react_Sigma;//Sigma+ or Simga -
TLorentzVector react_pi;//pi- or pi +


TVector3 mc_vtx;
TVector3 mc_disvtx;
//= = = = pin final-sample tree = = = =//


void InitializeHistogram();
void InitTreeVal();

int main( int argc, char** argv )
{
  if( argc!=5 ){
    std::cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<std::endl;
    return 0;
  }
  

  std::cout <<"L." << __LINE__ << " MOM_RES beam line: " << MOM_RES << std::endl;
  std::cout <<"L." << __LINE__ << " TDC_CDH_MAX: " << cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset << std::endl;
  std::cout << " Double Check VTX fid cut ? " ;
  if(IsVtxDoubleCheck) std::cout << " Yes" << std::endl;
  else         std::cout << " No"  << std::endl;
  
  std::cout << "Isolation cut range ? " ;
  std::cout << IsolationCutFlag <<  " segments" << std::endl;

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");
  //pdg->Print();

  //** Conf file open **// 
  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  std::cout << __LINE__  << " ** Simulation file open ** " << std::endl;
  //** Simulation file open **// 
  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  std::cout << __LINE__  << " Getting CDSTracking info. from CDCfile " << std::endl;
  //** Getting CDSTracking info. from CDCfile **//
  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
  EventHeader      *header = new EventHeader();
  evTree->SetBranchAddress("EventHeader", &header );
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan  = new BeamLineTrackMan();
  CDSTrackingMan   *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  //** output file 1 : histograms **//
  TFile *outfile = new TFile(argv[2], "recreate");
  //outfile->cd();
  //check seed distribution
  if( tree2->GetEntries()==1 ){
    std::cout<<"  !!! tree2 entries==1 !!!"<<std::endl;
    tree2->GetEntry(0);
    std::cout << runHeader->seed() << std::endl;
    Tools::H1("Seed",runHeader->seed(),10000,0,10000);
  }

  //** output file 2 : pippimn final-sample tree **// 
  std::string outfile2_name = std::string(argv[2]);
  outfile2_name.insert( outfile2_name.size()-5, "_npi" );
  std::cout<<"pippimn file "<<outfile2_name<<std::endl;
  TFile *outfile2 = new TFile( outfile2_name.c_str(), "recreate" );
  outfile2->cd();
  TTree *npiTree = new TTree( "EventTree", "EventTree" );
  npiTree->Branch( "mom_beam",   &mom_beam );//
  npiTree->Branch( "mom_target", &mom_target );
  npiTree->Branch( "mom_pi", &mom_pi );
  npiTree->Branch( "chargepi", &chargepi );
  npiTree->Branch( "mom_n", &mom_n );
  npiTree->Branch( "NeutralBetaCDH", &NeutralBetaCDH );
  npiTree->Branch( "tofpi",&tofpi);
  npiTree->Branch( "tofn",&tofn);
  npiTree->Branch( "dE", &dE );
  npiTree->Branch( "neutralseg", &neutralseg );
  npiTree->Branch( "nhitOutCDC", &nhitOutCDC );
  npiTree->Branch( "ForwardCharge", &ForwardCharge );
  npiTree->Branch( "vtx_reaction", &vtx_reaction );
  npiTree->Branch( "vtx_pi_beam", &vtx_pi_beam );
  npiTree->Branch( "vtx_pi_cdc", &vtx_pi_cdc );
  npiTree->Branch( "CDH_Pos",&CDH_Pos);
  npiTree->Branch( "CDH_Pos_pi",&CDH_Pos_pi);
  //npiTree->Branch( "run_num", &run_num );
  //npiTree->Branch( "event_num", &event_num );
  //npiTree->Branch( "block_num", &block_num );
  npiTree->Branch( "mc_nparticle",   &mc_nparticle );
  npiTree->Branch( "mcmom_beam",   &mcmom_beam );
  npiTree->Branch( "mcmom_pi", &mcmom_pi );
  npiTree->Branch( "mcchargepi", &mcchargepi);
  npiTree->Branch( "mcmom_ncds", &mcmom_ncds );
  npiTree->Branch( "mcmom_pimiss", &mcmom_pimiss );
  npiTree->Branch( "mcncanvtxr",&mcncanvtxr);
  npiTree->Branch( "mcncanvtxz",&mcncanvtxz);
  npiTree->Branch( "mcfirstvxr",&mcfirstvtxr);
  npiTree->Branch( "mcfirstvxz",&mcfirstvtxz);
  npiTree->Branch( "mcncdsgen",&mcncdsgen);
  npiTree->Branch( "mcpattern",&mcpattern);
  npiTree->Branch( "mcnanc",&mcnanc);
  npiTree->Branch( "react_pimiss",&react_pimiss);
  npiTree->Branch( "react_Sigma",&react_Sigma);
  npiTree->Branch( "react_pi",&react_pi);
  npiTree->Branch( "mc_vtx", &mc_vtx );//true reaction vertex
  npiTree->Branch( "mc_disvtx", &mc_disvtx );//true reaction vertex
  outfile->cd();



  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    //return 0;
  }

  InitializeHistogram();


  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  std::cout<<"=====Sigma pi reconstruction in MC START ============="<<std::endl;
  std::cout<<"     # of All  Event in EventTree:     "<<eventn<<std::endl;
  std::cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<std::endl;
  std::cout<<"     # of Exe  Event in this program:  "<<exen<<std::endl;
  std::cout<<"========================================================="<<std::endl;

  //** set cut parameters **//
  PARA_blc2bpc_dx_MIN = -0.75;
  PARA_blc2bpc_dx_MAX = 0.75;
  PARA_blc2bpc_dy_MIN = -0.75;
  PARA_blc2bpc_dy_MAX = 0.75;
  PARA_blc2bpc_dxdz_MIN = -0.02;
  PARA_blc2bpc_dxdz_MAX = 0.02;
  PARA_blc2bpc_dydz_MIN = -0.02;
  PARA_blc2bpc_dydz_MAX = 0.02;
  PARA_lnL_MAX = 9.95;

  PARA_MM_LP_MIN = 0.85;
  PARA_MM_LP_MAX = 1.03;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;

  int nG4Event_piSigma   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_CDSPID = 0;
  int nAbort_nCDH = 0;
  int nAbort_nT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_ftarget = 0;
  int nAbort_CDHiso = 0;
  int nAbort_pippim = 0;
  int nAbort_anothern = 0;
  int nAbort_end = 0;
  bool IsncdsfromSigma = true;
  
  int nFill_pippim = 0;
  int nFill_pippimn = 0;

  int nTrack_CDHshare = 0;

  int ev_cdc = 0;

  //=== event loop ===//
  for( int iev=0; iev<exen; iev++ ){
    
    //clean up 
    InitTreeVal();
    bool IsrecoPassed=true;
    bool IsBLAnaPassed=true;
    if(Verbosity_){
      std::cout<<"> Event Number "<<iev<<std::endl;
    }else if( /*iev<100 ||*/ iev%1000==0 ){
      std::cout<<"> Event Number "<< iev <<std::endl;
    }
    Tools::Fill1D( Form("EventCheck"), 1 );

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(iev); // MC
    evTree->GetEntry(ev_cdc); // CDC-tracking
    
    //### event ID matching
    if( evHeaderMC->eventID()!=header->ev() ){
      std::cout << "event ID mismatch !!"  << std::endl;
      std::cout << "evHeaderMC: " << evHeaderMC->eventID() << std::endl;
      std::cout << "header:     " << header->ev()  << std::endl;
      continue;
    }
    ev_cdc++;

    //### CDH ADC cut ###//
    //cut values is determined segement by segment, because the hardware threshold for each is different 
    /* 
    double discri[36]={
      2.65-0.4,//0
      2.25-0.2,//1
      1.95-0.2,//2
      1.85-0.2,//3
      1.55-0.2,//4
      2.05-0.2,//5
      1.95-0.2,//6
      1.95-0.2,//7
      1.95-0.2,//8
      1.75-0.2,//9
      1.65-0.2,//10
      1.75-0.2,//11
      1.95-0.2,//12
      1.95-0.2,//13
      1.65-0.2,//14
      1.75-0.2,//15
      1.75-0.2,//16
      1.85-0.2,//17
      1.65-0.2,//18
      1.75-0.2,//19
      1.95-0.3,//20
      2.35-0.3,//21
      1.55-0.1,//22
      1.75-0.2,//23
      1.65-0.2,//24
      1.85-0.2,//25
      1.85-0.2,//26
      1.75-0.2,//27
      1.85-0.2,//28
      1.85-0.2,//29
      1.65-0.1,//30
      1.95-0.2,//31
      1.65-0.2,//32
      1.85-0.2,//33
      1.65-0.2,//34
      1.95-0.3//35
    };

    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ){
      if( !((detData->detectorHit(i)->detectorID()==CID_CDH) && (detData->detectorHit(i)->adc()<discri[detData->detectorHit(i)->channelID()])) ){
        detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }
   */
    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ){
      if( !(detData->detectorHit(i)->detectorID()==CID_CDH && detData->detectorHit(i)->adc()<ADC_CDH_MIN) ){
	detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }

    simMan->Convert(detData2, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);
    bltrackMan->DoTracking(blMan, confMan, true, true);
    

    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4Decay = false;
    //bool piSigma_detect = false;
    //int pi_parent  = 0;
    //int Y_parent  = 0;
    //int N_parent  = 0;
    if(Verbosity_){
      std::cout<<"======================"<<std::endl;
      std::cout<<std::endl;
      std::cout<<"particle size :" <<   reacData->ParticleSize() << std::endl;
      for( int ip=0; ip<reacData->ParticleSize(); ip++ ){
        std::cout<< "L." << __LINE__ << " " 
          << ip<<" pdg code:"<<reacData->PDG(ip)<<" mom:"<<reacData->GetParticle(ip).P()
          <<std::endl;
      }
    }
    //reaction data (=generated particle info.)
    Util::AnaReactionData(reacData);
    
    react_pimiss = reacData->GetParticle(0);
    react_Sigma = reacData->GetParticle(1);
    react_pi = reacData->GetParticle(2);

    const int reactionID = reacData->ReactionID();
    //These partcile IDs are defined in pythia6
    //see http://home.fnal.gov/~mrenna/lutp0613man2/node44.html
    //
    //Here, K+ is used as beam particle because every particle is emitted from the target volume in GEANT simulation
    //                                   K+    pi-  S+   ncds    pi+  //
    const int PDG_Spmode[kinh2::npart] = {321, -211, 3222, 2112,  211}; // pi-Sigma+ mode
    //                                   K+    pi+  S-    ncds    pi- 
    const int PDG_Smmode[kinh2::npart] = {321,  211, 3112, 2112, -211}; // pi+Sigma- mode
    //                                   K+  ncds  K0bar nmiss pi-  pi+
    int PDG[kinh2::npart] = {0, 0, 0, 0, 0};
    for( int i=0; i<kinh2::npart; i++ ){
      if( reactionID==gen::reactionID_h2Spmode ){
        PDG[i] = PDG_Spmode[i];
        if(Verbosity_)std::cout << "L." << __LINE__ << " This is Sigma+ mode sim. " << std::endl;
      }
      else if( reactionID==gen::reactionID_h2Smmode ){
        PDG[i] = PDG_Smmode[i];
        if(Verbosity_)std::cout << "L." << __LINE__ << " This is Sigma- mode sim. " << std::endl;
      }
    }

    //  beam_K(K-), prompt pi, Sigma, nmiss, n from Sigma, pi from Sigma
    //  0: init. val. for prompt particles , -1:init. val. for decay particles            
    int parentID[kinh2::npart] = {0, 0, 0, -1, -1}; 
    // IDs defined by imctrk which is the serial number in mcData class
    int ID[kinh2::npart]       = {-1, -1, -1, -1, -1}; 
    // track ID assigned in mcData class
    int trackID[kinh2::npart]  = {-1, -1, -1, -1, -1}; 
    int nparticle = 0;
    
    if(Verbosity_){
      std::cout<< std::endl;
      std::cout<< "L." << __LINE__ << "loop over track Size:" << mcData->trackSize() 
      << std::endl;
      std::cout<< std::endl;
    }
    
    bool FoundSigmaNMcData = false;
    for( int imctrk=0; imctrk<mcData->trackSize(); imctrk++ ){
      //pdg ID
      const int pdgcode = mcData->track(imctrk)->pdgID();
      //parent track ID, if it is primary particle, 0
      const int parent  = mcData->track(imctrk)->parentTrackID();
      //track ID
      const int track   = mcData->track(imctrk)->trackID();
      const double mom  = mcData->track(imctrk)->momentum().Mag();
      const TVector3 vec_vertex = mcData->track(imctrk)->vertex();
      //This is flight-length which is calcuted only when the track reaches to the CDH 
      double flightlength = mcData->track(imctrk)->FlightLength();
      if(Verbosity_){
        std::cout<<"imctrk:" << imctrk<<" | "<< "pdgcode:" << pdgcode<< std::endl;
        std::cout<<"parent_trkID:"<<  parent << std::endl;
        std::cout<<"trackID:"<<track<< std::endl;
        std::cout<<"mom:" << mom << std::endl;
        std::cout<<"vertex R: " << vec_vertex.Perp() << std::endl;
        std::cout<<"vertex Z: " << vec_vertex.Z() << std::endl;
        std::cout<<"flight length:" << flightlength << std::endl;
      }
      for( int ip=0; ip<kinh2::npart; ip++ ){ 
        //   pick up necessary particles stored in PDG[] array.
        //   if it is primary particle ,parentID is 0, decay particles are rejected by the parentID selection
        if( pdgcode==PDG[ip] && parent==parentID[ip] && ID[ip]==-1 ){
          ID[ip] = imctrk;
          trackID[ip] = track;
          nparticle++;
          if(Verbosity_){
            std::cout<<"ip:" << ip<<" | "<<pdgcode<<" "<<parent<<" "<<track<<" "<<mcData->track(imctrk)->momentum().Mag()
              <<" ("<<mcData->track(imctrk)->momentum().CosTheta()<<" , "<<mcData->track(imctrk)->momentum().Phi()*360./TwoPi<<")"<<std::endl;
          }
          
          //assign parent IDs for netron and pi+/- from Sigma+/- 
          if( ip==kinh2::Sp || ip==kinh2::Sm){ //Sp and Sm are same.
            if( reactionID == gen::reactionID_h2Spmode ||
                reactionID == gen::reactionID_h2Smmode){
              parentID[kinh2::ncds] = track;
              parentID[kinh2::pip_g2] = track;//pip_g2 and pim_g2 are same.
            }
            if(Verbosity_){
              std::cout << "parentID n  from Sigma:" << parentID[kinh2::ncds] << std::endl;
              std::cout << "parentID pi from Sigma:" << parentID[kinh2::pip_g2] << std::endl;
            }
          }
          break;
        }//if 
      }//for ip
    }//for imctrk

    if( nparticle==kinh2::npart ) { 
      flagG4Decay = true;
      

      if(Verbosity_) {
        std::cout << "L." << __LINE__ << " flagG4Decay OK " << std::endl;
      }
    }else{
      if(Verbosity_) std::cout << "L." <<  __LINE__ << " nparticle " << nparticle << std::endl;
    }

    

    //actually not used ?
    // beam_K(K+), pi, Y, N, N from Sigma, pi from Sigma
    // beam particle is emitted from the target
    TLorentzVector TL_gene[kinh2::npart]; // generated
    for( int ip=0; ip<kinh2::npart; ip++ ){
      if(ID[ip]==-1){
        TL_gene[ip].SetPxPyPzE(-9999.0,-9999.0,-9999.0,-9999999.0);
      }else{
        if( ip ) TL_gene[ip].SetVectM(mcData->track(ID[ip])->momentum()*0.001,  pdg->GetParticle(PDG[ip])->Mass()); // GeV
        else    TL_gene[ip].SetVectM(mcData->track(ID[ip])->momentum()*-0.001, pdg->GetParticle(PDG[ip])->Mass()); // GeV
      }
    }
    int genID[kinh2::npart] = {0,1,2,3,4};
    mcmom_beam = TL_gene[kinh2::kmbeam];

    //##########################//
    //### get G4 information ###//
    //##########################//


    const int nGoodTrack = cdstrackMan->nGoodTrack();
    const int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;
    Tools::Fill1D( Form("nGoodTrack"), nGoodTrack );
    Tools::Fill1D( Form("nTrack"),nallTrack);
    if(nGoodTrack==2){
      Tools::Fill1D( Form("nTrack_If2GoodTracks"),nallTrack);
    }
    
    for(int itr=0;itr<mcData->trackSize();itr++){
      TVector3 vtx = mcData->track(itr)->vertex();
      Tools::H1(Form("track_vtxr"),vtx.Perp()/10.,1200,0,120);
    }
    
    //put here tmp. solution for CDH eff. study
    double ncanvtxr=999.0;
    double ncanvtxz=999.0;
    int ncdsgen=10;

    if( Util::GetCDHMul(cdsMan,nGoodTrack,true,true)!=2 ){
      if(IsrecoPassed)nAbort_nCDH++;
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nCDH" << std::endl;
      //continue;
      IsrecoPassed=false;
    }else{
      //Util::AnaMcData(mcData,detData2,cdsMan,reacData,ncanvtxr,ncanvtxz,ncdsgen);
    }

    if( nGoodTrack!=1 ){ // dedicated for pi+ pi- event
      if(IsrecoPassed)nAbort_nGoodTrack++;
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nGoodTrack" << std::endl;
      //continue;
      IsrecoPassed=false;
    }
    
    //
    //beam line analysis and event selection
    //

    //** T0 = 1hit selection **//
    int t0seg=-1;
    const double ctmT0 = Util::AnalyzeT0(blMan,confMan,t0seg);
    if(ctmT0<-9000){
      if(IsBLAnaPassed) nAbort_nT0++;
      Tools::Fill1D( Form("EventCheck"), 15 );
      //continue;
      IsrecoPassed=false;
      IsBLAnaPassed=false;
    }

    //** BPC track selection **//
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ){
      nbpc++;
      bpcid = i;
    }
    Tools::Fill1D( Form("ntrack_BPC"), nbpc );
    if( nbpc!=1 ){
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nbpc" << std::endl;
      if(IsBLAnaPassed)nAbort_nbpc++;
      //continue;
      IsrecoPassed=false;
      IsBLAnaPassed=false;
    }

    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);    
    if(IsrecoPassed){
      Tools::Fill1D( Form("trackchi2_BPC"),bpctrack->chi2all());
      if(bpctrack->chi2all()>blcuts::bpc_chi2_max){
        if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_bpctrack" << std::endl;
        if(IsBLAnaPassed)nAbort_bpctrack++;
        //continue;
        IsrecoPassed=false;
        IsBLAnaPassed=false;
      }
    }

    // vertex calculation //
    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ){
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }

    //** vectors for PID container **//
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    //std::vector <int> d_ID;
    

    bool flagbmom = false;
    TVector3 vtx_react;

    //** BLC2 track **//
    int nblc2 = 0;
    int blc2id = -1;
    for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ){
      nblc2++;
      if( bltrackMan->trackBLC2(iblc2trk)->chi2all()<blcuts::blc2_chi2_max) blc2id = iblc2trk;
    }
    Tools::Fill1D( Form("ntrack_BLC2"), nblc2 );
    if(IsrecoPassed && !(nblc2==1 && blc2id!=-1) ){
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nblc2" << std::endl;
      if(IsBLAnaPassed)nAbort_nblc2++;
      //continue;
      IsrecoPassed=false;
      IsBLAnaPassed=false;
    }

    //### BLC2-BPC position matching
    //TODO : not tuned yet
    bool fblc2bpc = true;
    
    if(IsrecoPassed && IsBLAnaPassed){
      for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ){
        if( iblc2trk!=blc2id ) continue;
        LocalTrack *blc2 = bltrackMan->trackBLC2(iblc2trk);
        double xblc2bpc[2], yblc2bpc[2];
        double xmom[2], ymom[2];

        TVector3 Pos_BPC, Pos_BLC2, tmp;
        confMan->GetBLDCWireMapManager()->GetGParam( CID_BPC, Pos_BPC, tmp );
        confMan->GetBLDCWireMapManager()->GetGParam( CID_BLC2a, Pos_BLC2, tmp );
        const double zPos_BPC = Pos_BPC.Z();
        const double zPos_BLC2 = Pos_BLC2.Z();
        const double zPos_BPC_BLC2 = (Pos_BPC.Z()+Pos_BLC2.Z())/2;

        bpctrack->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[0], yblc2bpc[0] );
        bpctrack->XYPosatZ( zPos_BPC, xmom[0], ymom[0] );
        blc2->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[1], yblc2bpc[1]);
        blc2->XYPosatZ( zPos_BLC2, xmom[1], ymom[1]);
        double dxdz[2], dydz[2];
        dxdz[0] = (xmom[0]-xblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
        dxdz[1] = (xmom[1]-xblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);
        dydz[0] = (ymom[0]-yblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
        dydz[1] = (ymom[1]-yblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);

        if( (xblc2bpc[1]-xblc2bpc[0])<PARA_blc2bpc_dx_MIN ||
            (xblc2bpc[1]-xblc2bpc[0])>PARA_blc2bpc_dx_MAX ) fblc2bpc = false;
        else if( (yblc2bpc[1]-yblc2bpc[0])<PARA_blc2bpc_dy_MIN ||
            (yblc2bpc[1]-yblc2bpc[0])>PARA_blc2bpc_dy_MAX ) fblc2bpc = false;
        else if( (dxdz[1]-dxdz[0])<PARA_blc2bpc_dxdz_MIN ||
            (dxdz[1]-dxdz[0])>PARA_blc2bpc_dxdz_MAX ) fblc2bpc = false;
        else if( (dydz[1]-dydz[0])<PARA_blc2bpc_dydz_MIN ||
            (dydz[1]-dydz[0])>PARA_blc2bpc_dydz_MAX ) fblc2bpc = false;
        else fblc2bpc = true;

        Tools::Fill2D( Form("dydx_BLC2BPC"), xblc2bpc[1]-xblc2bpc[0], yblc2bpc[1]-yblc2bpc[0] );
        Tools::Fill2D( Form("dydzdxdz_BLC2BPC"), dxdz[1]-dxdz[0], dydz[1]-dydz[0] );
      }//iblc2trk
 
      if( !fblc2bpc ){
        if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_fblc2bpc" << std::endl;
        if(IsBLAnaPassed) nAbort_fblc2bpc++;
        //continue;
        //20220201 do not take into accout BLC-BPC matching
        //IsrecoPassed=false;
        //IsBLAnaPassed=false;
      }
    }

    //** beam momentum calculation **//
    TLorentzVector LVec_beambf;  // 4-Momentum(beam) in LAB
    TLorentzVector LVec_beam;    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector LVec_target;  // 4-Momentum(He3-target) in LAB
    TLorentzVector LVec_targetP; // 4-Momentum(p-target) in LAB
    TLorentzVector LVec_beambfCM;  // 4-Momentum(beam) in CM
    TLorentzVector LVec_beamCM;    // 4-Momentum(beam) in CM with dE correcion
    TLorentzVector LVec_targetCM;  // 4-Momentum(He3-target) in CM
    TLorentzVector LVec_targetPCM; // 4-Momentum(p-target) in CM


    //std::cout << "test" << std::endl;
    //std::cout << "bpctrack->GetPosatZ(0)" << std::endl;
    //std::cout << bpctrack->GetPosatZ(0).X() << "  " <<  bpctrack->GetPosatZ(0).Y()  << "  " << bpctrack->GetPosatZ(0).Z()  << std::endl;
    //std::cout << zPos_T0 << std::endl;
    //std::cout << bpctrack->GetPosatZ(zPos_T0 ).X() << "  " <<  bpctrack->GetPosatZ(zPos_T0).Y()  << "  " << bpctrack->GetPosatZ(zPos_T0).Z()  << std::endl;
    
    //beam momentum smearing
    double beammom = 0;
    for( int imctrk=0; imctrk<mcData->trackSize(); imctrk++ ){
      const int pdgcode = mcData->track(imctrk)->pdgID();
      const int parent  = mcData->track(imctrk)->parentTrackID();
      //beam K (K+) to -Z direction 
      //beam momentum is fixed in GEANT simulation. It is smeared here by gaussian.
      if( pdgcode==321 && parent==0 ){
        //std::cout << mcData->track(imctrk)->momentum().Mag() << std::endl;
        beammom = (mcData->track(imctrk)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
        if(Verbosity_>100){
          std::cout << "L." << __LINE__ << " beam mom:" << beammom << std::endl;
        }
        break;
      }
    }

    double x1, y1, x2, y2;
    const double z1 = 0, z2 = 20;//TODO: what is this 20 ?
    //if(IsrecoPassed){
    if(IsBLAnaPassed){
      bpctrack->XYPosatZ(z1, x1, y1);
      bpctrack->XYPosatZ(z2, x2, y2);
    }
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls; 
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    LVec_beambf.SetVectM(Pp_beam , kpMass);
    LVec_target.SetVectM(Pp_target, pMass);
    LVec_target.SetVectM(Pp_target, pMass);
    LVec_targetP.SetVectM(Pp_target, pMass);
    LVec_beam = LVec_beambf;
    //Lorentz boost Vector
    const TVector3 boost = (LVec_target+LVec_beam).BoostVector();
    LVec_beambfCM = LVec_beam;
    LVec_targetCM = LVec_target;
    LVec_targetPCM = LVec_targetP;
    LVec_beambfCM.Boost(-1.*boost);
    LVec_targetCM.Boost(-1.*boost);
    LVec_targetPCM.Boost(-1.*boost);
    flagbmom = true;

    
    //always OK, because this is simulation
    if( !flagbmom ){
      if(IsrecoPassed)nAbort_flagbmom++;
      //continue;
      //IsrecoPassed=false;
    }
    Tools::Fill1D( Form("momentum_beam"), LVec_beambf.P() );
    //generated info taking into account momentum bite
    double px = (LVec_beam).Px();
    double py = (LVec_beam).Py();
    double pz = (LVec_beam).Pz();
    double E = (LVec_beam).E();
    TLorentzVector LVec_beam_unit;
    LVec_beam_unit.SetPx(px*1000.0);
    LVec_beam_unit.SetPy(py*1000.0);
    LVec_beam_unit.SetPz(pz*1000.0);
    LVec_beam_unit.SetE(E*1000.0);
    //** + + + + + + + + + + + + **//
    //**  PID in CDS             **//
    //** + + + + + + + + + + + + **//
    
    std::vector <int> vCDHseg;
    int nIDedTrack=0;
    TVector3 pim_cdhprojected;
    TVector3 pip_cdhprojected;
    if(IsrecoPassed){
          nIDedTrack = Util::CDSChargedAna(
          DoCDCRetiming,
          bpctrack, cdsMan, cdstrackMan, confMan, blMan,
          LVec_beam, ctmT0,vCDHseg,pim_ID,pip_ID,km_ID,p_ID,pim_cdhprojected,pip_cdhprojected,true,1);
      if(nIDedTrack==-7) Tools::Fill1D( Form("EventCheck"), 7 );
      if(nIDedTrack==-8) Tools::Fill1D( Form("EventCheck"), 8 );
      if(nIDedTrack==-9){
        nTrack_CDHshare++;
        Tools::Fill1D( Form("EventCheck"), 9 );
      }
      if(nIDedTrack==-10) Tools::Fill1D( Form("EventCheck"), 10 );
      if(nIDedTrack==-11) Tools::Fill1D( Form("EventCheck"), 11 );
      if(nIDedTrack==-12) Tools::Fill1D( Form("EventCheck"), 12 );
      if(nIDedTrack<0){
        nAbort_CDSPID++;
        //continue;
        IsrecoPassed=false;
      }
    }

    //Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+d_ID.size()+pim_ID.size()+km_ID.size() );
    if(nIDedTrack>0) nTrack_PID =+ nIDedTrack;
    Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+pim_ID.size()+km_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_plus"),  pip_ID.size() );
    Tools::Fill1D( Form("ntrack_proton"),   p_ID.size() );
    //Tools::Fill1D( Form("ntrack_deuteron"), d_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_minus"), pim_ID.size() );
    Tools::Fill1D( Form("ntrack_K_minus"),  km_ID.size() );

    bool forwardcharge= Util::IsForwardCharge(blMan); 

    // + + + + + + + + + + + //
    //  pi+ pi- X event  //
    // + + + + + + + + + + + //
    if( IsrecoPassed && 
        flagbmom && 
        ((pim_ID.size()==1) ||  (pip_ID.size()==1))  &&
        (cdstrackMan->nGoodTrack()==1) 
        //&& !forwardcharge 
        ){
        
      nFill_pippim++;
      
      for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ) {
        CDSTrack *track = cdstrackMan->Track( cdstrackMan->GoodTrackID(it) );

        double mom = track->Momentum();//charge X momentum
        double tof = 999.;//TOF of CDH-T0 (slewing corrected)
        double mass2 = -999.;
        double correctedtof=0;//CDH-T0 (corrected by energy loss)
        double beta_calc=0;
        for( int icdh=0; icdh<track->nCDHHit(); icdh++ ) {
          HodoscopeLikeHit *cdhhit = track->CDHHit( cdsMan, icdh );
          double tmptof = cdhhit->ctmean()-ctmT0;
          if( tmptof<tof || tof==999. ) {
            tof = tmptof;
          }
        }
        if( !TrackTools::FindMass2( track, bpctrack, tof, LVec_beam.Vect().Mag(),
                                Beam_Kaon, beta_calc, mass2, correctedtof ) ) {

        }
        //const int pid = TrackTools::PIDcorr_wide(mom,mass2);
        const int pid = TrackTools::PIDcorr(mom,mass2);
        track->SetPID( pid );
        Tools::Fill2D( "PID_CDS_beta_select", 1./beta_calc, mom );
        Tools::Fill2D( "PID_CDS_select", mass2, mom );
        if(pid == CDS_PiMinus){
          Tools::Fill2D("PID_CDS_PIM_beta_select",1./beta_calc,mom);
          Tools::Fill2D("PID_CDS_PIM_select",mass2,mom);
          tofpi = tof;
        }else if(pid == CDS_PiPlus){
          Tools::Fill2D("PID_CDS_PIP_beta_select",1./beta_calc,mom);
          Tools::Fill2D("PID_CDS_PIP_select",mass2,mom);
          tofpi = tof;
        }
        else if(pid == CDS_Proton) Tools::Fill2D("PID_CDS_Proton_select",mass2,mom);
        else if(pid == CDS_Kaon) Tools::Fill2D("PID_CDS_Kaon_select",mass2,mom);
      }
      
      //** find CDH hit from neutral particles **//
      std::vector <int> NeutralCDHseg;
      std::vector <int> CDHhit_list;
      
      for( int icdhhit=0; icdhhit<cdsMan->nCDH(); icdhhit++ ){
        if( cdsMan->CDH(icdhhit)->CheckRange() && cdsMan->CDH(icdhhit)->ctmean()<(cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset) )
          CDHhit_list.push_back( cdsMan->CDH(icdhhit)->seg() );
      }
      std::sort(vCDHseg.begin(), vCDHseg.end());
      std::sort(CDHhit_list.begin(), CDHhit_list.end());
      std::set_difference( CDHhit_list.begin(), CDHhit_list.end(),
			   vCDHseg.begin(), vCDHseg.end(),
			   std::back_inserter(NeutralCDHseg) );

      if( NeutralCDHseg.size()!=1 ){
        std::cout<< "L." << __LINE__ << " CDH neutral hit is not 1 :: "<<NeutralCDHseg.size()<<std::endl;
        std::cout << "vCDHseg " << vCDHseg.size() << std::endl;
        std::cout << "CDHhit_list " << CDHhit_list.size() << std::endl;
      }
      
      if(Verbosity_){
        std::cout<<"# of diff = "<<NeutralCDHseg.size()<<std::endl;
        std::cout<<"CDH hits =   ";
        for( int n=0; n<(int)CDHhit_list.size(); n++ ){
          std::cout<<CDHhit_list[n]<<" ";
        } std::cout<<std::endl;
        std::cout<<"track hits = ";
        for( int n=0; n<(int)vCDHseg.size(); n++ ){
          std::cout<<vCDHseg[n]<<" ";
        } std::cout<<std::endl;
        std::cout<<"diff hits =  ";
        for( int n=0; n<(int)NeutralCDHseg.size(); n++ ){
          std::cout<<NeutralCDHseg[n]<<" ";
        } std::cout<<std::endl;
      }

      
      // isolation cut //
      int flag_isolation = 0;
      if(IsrecoPassed){
        if(IsolationCutFlag==2){
          flag_isolation = Util::GetCDHNeighboringNHits(NeutralCDHseg,CDHhit_list,vCDHseg,cdsMan,true);
          flag_isolation+= Util::GetCDHTwoSegAwayNHits(NeutralCDHseg,CDHhit_list,true);
        }else if(IsolationCutFlag==1){
          flag_isolation = Util::GetCDHNeighboringNHits(NeutralCDHseg,CDHhit_list,vCDHseg,cdsMan,true);
        }else{
          //check cdh hit position anyway, but don't apply isolation cuts 
          flag_isolation = Util::GetCDHNeighboringNHits(NeutralCDHseg,CDHhit_list,vCDHseg,cdsMan,true);
          flag_isolation = 0;
        }
      }
      if( flag_isolation ){
        if(Verbosity_>100)std::cout<< "L."<< __LINE__ << " Event Number: " <<iev <<  " CDH hit candidate is NOT isolated !!!"<<std::endl;
        //if(IsrecoPassed)nAbort_CDHiso++;
        //continue;
        //IsrecoPassed=false;
      }else{
        if(Verbosity_>100) std::cerr<<"CDH isolation cuts : OK " << std::endl;
        Tools::Fill1D( Form("EventCheck"), 14 );
      }
      
      //** copy neutral CDH hit candidate **//
      int icdh = -1;
      for( int icdhhit=0; icdhhit<cdsMan->nCDH(); icdhhit++ ){
        if( cdsMan->CDH(icdhhit)->seg()==NeutralCDHseg[0] ) icdh = icdhhit;
      }
      HodoscopeLikeHit *ncdhhit = cdsMan->CDH(icdh);
      
      //** charge veto using CDC **//
      TVector3 Pos_CDH;
      confMan->GetGeomMapManager()->GetPos( CID_CDH, ncdhhit->seg(), Pos_CDH );
      if(Verbosity_) std::cout<<"CDH candidate seg = "<<ncdhhit->seg()<<" -> "<<Pos_CDH.Phi()/TwoPi*360<<" deg"<<std::endl;
      
      const int nCDCInner3Lay = Util::GetNHitsCDCInner3Lay(cdsMan);
      if(IsrecoPassed)Tools::Fill1D(Form("CDCInner3Mul"),nCDCInner3Lay);
      
      int nCDCforVeto = 0;
      if(IsrecoPassed){
        //nCDCforVeto = Util::GetNHitsCDCOuter(Pos_CDH,cdsMan,cdscuts::chargevetoangle);
        nCDCforVeto = Util::GetNHitsCDCOuterNoAss(Pos_CDH,cdsMan,cdstrackMan,cdscuts::chargevetoangle);
        //Util::AnaPipPimCDCCDH(Pos_CDH,NeutralCDHseg,pip_ID[0],pim_ID[0],cdsMan,cdstrackMan);
        Tools::Fill1D(Form("NCDCOutHit"),nCDCforVeto);
      }
      //Pos_CDH.SetZ(-1*ncdhhit->hitpos()); // (-1*) is wrong in SIM [20170925]
      Pos_CDH.SetZ(ncdhhit->hitpos());
      
      if(Verbosity_){
        std::cout << "L." << __LINE__ << " CDH Z " << ncdhhit->hitpos() << std::endl;
        double angle = Pos_CDH.Angle(Pos_CDH); // rad
        std::cout << "L." << __LINE__ << " CDH angle " << angle << std::endl;
        std::cout<<"L."<<__LINE__ << "CDH phi " << Pos_CDH.Phi()/TwoPi*360. <<std::endl;
        std::cout<<"L."<<__LINE__ << "CDH costheta " << Pos_CDH.CosTheta() <<std::endl;
      }
         

      // neutral particle in CDH //
      if(NeutralCDHseg.size()!=1) {
        std::cout << "L." << __LINE__ << " # of seg for neutral hits " << NeutralCDHseg.size() << std::endl;
      } else {
        Tools::Fill1D(Form("CDHNeutralSeg"),NeutralCDHseg.at(0));
      }

      CDSTrack *track_pi;
      if(pip_ID.size()==1){  
        track_pi = cdstrackMan->Track( pip_ID[0] ); // only 1 track
      }else if(pim_ID.size()==1){
        track_pi = cdstrackMan->Track( pim_ID[0] ); // only 1 track
      }

      TVector3 vtx_react;//reaction vertex
      TVector3 vtx_dis;//displaced vertex
        
      TVector3 vtx_beam_wpi;//closest approach (beam-pip) on beam
      TVector3 vtx_pi;//closest approach(beam-pip) on cdc track
      TVector3 vtx_beam;
      track_pi->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_beam_wpi, vtx_pi ); 
      double dcapivtx =  (vtx_pi-vtx_beam_wpi).Mag();
      const TVector3 vtx_pi_mean = 0.5*(vtx_pi+vtx_beam_wpi);
      //Tools::Fill1D( Form("DCA_pi"), dcapivtx );

      vtx_react = 0.5*(vtx_pi+vtx_beam_wpi);
      vtx_dis  = vtx_pi;//determined by CDC-beam
      vtx_beam = vtx_beam_wpi;

      //** reconstructoin of missing neutorn **//
      TVector3 P_pi; // Momentum(pi-)
      
      if( !track_pi->GetMomentum( vtx_pi, P_pi, true, true ) ){
        std::cout<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
      }

      // beam kaon tof 
      TVector3 Pos_T0;
      confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
      double beamtof=0;
      double momout=0;
      double z_pos = Pos_T0.Z();;
      ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), vtx_react,
          LVec_beambf.Vect().Mag(), kpMass, momout, beamtof );
      // LVec_beam.SetVectM( momout*LVec_beambf.Vect().Unit(), kpMass ); // not need energy-loss correction [20180329]
      double ntof = ncdhhit->ctmean()-ctmT0-beamtof;
      tofpi -= beamtof;
      tofn = ntof;

      Tools::Fill1D(Form("CDH%d_T0%d_TOF_Neutral",ncdhhit->seg() ,t0seg),ntof);
      //std::cout <<"cdh time "<<  ncdhhit->ctmean() << std::endl;
      //std::cout << "ctmt0   " << ctmT0 << std::endl;
      //std::cout <<"beamtof  " <<  beamtof << std::endl;
      //double ntof = ncdhhit->ctmean();
      double nlen = (Pos_CDH-vtx_react).Mag();
      Tools::Fill2D(Form("ntof_nlen"),ntof,nlen);
      NeutralBetaCDH = nlen/ntof/(Const*100.);
      double tmp_mom = NeutralBetaCDH<1. ? nMass*NeutralBetaCDH/sqrt(1.-NeutralBetaCDH*NeutralBetaCDH) : 0.;
      if(Verbosity_){
        std::cout<<"$$$ beta = "<<NeutralBetaCDH<<" mom_n = "<<tmp_mom<<std::endl; //" "<<1/sqrt(1+nMass*nMass)<<std::endl;
      }

      TVector3 P_n = tmp_mom*((Pos_CDH-vtx_react).Unit());
	
      if(Verbosity_) std::cout << tmp_mom<<" ("<<P_n.CosTheta()<<" , "<<P_n.Phi()*360./TwoPi<<")"<<std::endl;
      TLorentzVector LVec_pi; // 4-Momentum(pi-)
      TLorentzVector LVec_n;   // 4-Momentum(n)
      TLorentzVector LVec_pimiss; // 4-Momentum(n_miss)
      int charge_pi = -1;
      if(pip_ID.size()==1)charge_pi=1;
      else if(pim_ID.size()==1) charge_pi=0;
      LVec_pi.SetVectM( P_pi, piMass );
      LVec_n.SetVectM( P_n, nMass );//CDS n

      const double mm_mass   = (LVec_target+LVec_beam-LVec_pi-LVec_n).M();
      const TVector3 P_misspi = (LVec_target+LVec_beam-LVec_pi-LVec_n).Vect();

      LVec_pimiss.SetVectM( P_misspi, piMass );
      if(Verbosity_)std::cout<<"  missing mass = "<<mm_mass<<std::endl;

      TVector3 boost = (LVec_target+LVec_beam).BoostVector();
      TLorentzVector LVec_pimiss_CM = LVec_pimiss;
      TLorentzVector LVec_beam_CM = LVec_beam;
      LVec_pimiss_CM.Boost(-boost);
      LVec_beam_CM.Boost(-boost);
      double cos_pi = LVec_pimiss_CM.Vect().Dot(LVec_beam_CM.Vect())/(LVec_pimiss_CM.Vect().Mag()*LVec_beam_CM.Vect().Mag());
      if(Verbosity_)std::cout<<"  missing mom = "<<LVec_pimiss.P()<<" | cos_CM = "<<cos_pi<<std::endl;


      //** + + + + + + + + + + + + + **//
      //**  fill histograms & tree   **//
      //** + + + + + + + + + + + + + **//
      bool MissNFlag=false;
      bool SigmaPFlag=false;
      bool SigmaMFlag=false;
      bool NBetaOK=false;
      bool NdEOK=false;

      Tools::Fill2D( Form("dE_betainv"), 1./NeutralBetaCDH, ncdhhit->emean() );
      Tools::Fill2D( Form("MMom_MMass"), mm_mass, P_misspi.Mag() );

      Tools::Fill2D(Form("Vtx_ZX_nofid"),vtx_pi_mean.Z(),vtx_pi_mean.X());
      Tools::Fill2D(Form("Vtx_ZY_nofid"),vtx_pi_mean.Z(),vtx_pi_mean.Y());
      Tools::Fill2D(Form("Vtx_XY_nofid"),vtx_pi_mean.X(),vtx_pi_mean.Y());
      //Fiducial cuts OK
      if( (GeomTools::GetID(vtx_react)==CID_Fiducial)  )  {
          for( int i=0; i<cdsMan->nCDH(); i++ ) {
            if((cdsMan->CDH(i)->CheckRange()) && (cdsMan->CDH(i)->ctmean()<cdscuts::tdc_cdh_max+cdscuts::tdc_simoffset)){
              Tools::Fill2D(Form("dE_CDHtime_pippimn"), cdsMan->CDH(i)->ctmean(), cdsMan->CDH(i)->emean());
            }
          }
           
          Tools::Fill2D(Form("Vtx_ZX_fid"),vtx_pi_mean.Z(),vtx_pi_mean.X());
          Tools::Fill2D(Form("Vtx_ZY_fid"),vtx_pi_mean.Z(),vtx_pi_mean.Y());
          Tools::Fill2D(Form("Vtx_XY_fid"),vtx_pi_mean.X(),vtx_pi_mean.Y());
          Tools::Fill2D(Form("NeutraltimeEnergy"),ncdhhit->ctmean()-ctmT0-beamtof,ncdhhit->emean());
          Tools::Fill2D(Form("CDHzNeutraltime"),Pos_CDH.z(),ncdhhit->ctmean()-ctmT0-beamtof);
          Tools::Fill2D( Form("NMomCDHtime%d",ncdhhit->seg()),ncdhhit->ctmean()-ctmT0-beamtof,P_n.Mag()); 
          Tools::Fill2D( Form("dE_betainv_fid"), 1./NeutralBetaCDH, ncdhhit->emean() );
          Tools::Fill2D( Form("MMom_MMass_fid"), mm_mass, P_misspi.Mag() );
         
          if(NeutralBetaCDH<anacuts::beta_MAX) NBetaOK=true;
        
          if(NBetaOK){
            Tools::Fill2D( Form("dE_betainv_fid_beta"), 1./NeutralBetaCDH, ncdhhit->emean() );
            Tools::Fill2D( Form("MMom_MMass_fid_beta"), mm_mass, P_misspi.Mag() );
          }
          if(anacuts::dE_MIN<ncdhhit->emean()) NdEOK=true;

          if( NBetaOK && NdEOK ){
            Tools::Fill2D( Form("dE_betainv_fid_beta_dE"), 1./NeutralBetaCDH, ncdhhit->emean() );
            Tools::Fill2D( Form("MMom_MMass_fid_beta_dE"), mm_mass, P_misspi.Mag() );
            //added Jul.28th, 2019
            //purpose  QA of PID 
            for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ) {
              CDSTrack *track = cdstrackMan->Track( cdstrackMan->GoodTrackID(it) );

              double mom = track->Momentum();//charge X momentum
              double tof = 999.;//TOF of CDH-T0 (slewing corrected)
              double mass2 = -999.;
              double correctedtof=0;//CDH-T0 (corrected by energy loss)
              double beta_calc=0;
              for( int icdh=0; icdh<track->nCDHHit(); icdh++ ) {
                HodoscopeLikeHit *cdhhit = track->CDHHit( cdsMan, icdh );
                double tmptof = cdhhit->ctmean()-ctmT0;
                if( tmptof<tof || tof==999. ) {
                  tof = tmptof;
                }
              }
              if( !TrackTools::FindMass2( track, bpctrack, tof, LVec_beam.Vect().Mag(),
                    Beam_Kaon, beta_calc, mass2, correctedtof ) ) {

              }
              //const int pid = TrackTools::PIDcorr_wide(mom,mass2);
              const int pid = TrackTools::PIDcorr(mom,mass2);
              track->SetPID( pid );
              Tools::Fill2D( "PID_CDS_beta_select2", 1./beta_calc, mom );
              Tools::Fill2D( "PID_CDS_select2", mass2, mom );
              if(pid == CDS_PiMinus){
                Tools::Fill2D("PID_CDS_PIM_beta_select2",1./beta_calc,mom);
                Tools::Fill2D("PID_CDS_PIM_select2",mass2,mom);
              }else if(pid == CDS_PiPlus){
                Tools::Fill2D("PID_CDS_PIP_beta_select2",1./beta_calc,mom);
                Tools::Fill2D("PID_CDS_PIP_select2",mass2,mom);
              }
              else if(pid == CDS_Proton) Tools::Fill2D("PID_CDS_Proton_select2",mass2,mom);
              else if(pid == CDS_Kaon) Tools::Fill2D("PID_CDS_Kaon_select2",mass2,mom);
            }//for it

            // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
            // %%% Kinematical Fit using KinFitter %%% //
            // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
            //--- set TLorentzVector for MC study---//
            // beam_K(K+), pi-/+, Sigma+/-, n, n from Sigma, pi+/- from Sigma 
            //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+ 
            //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma- 
            //int genID[kinh2::npart] = {0,1,2,3,4,5};
            //IsncdsfromSigma = true;
            mcmom_beam = TL_gene[kinh2::kmbeam];
            if( reactionID==gen::reactionID_h2Spmode ){
              mcmom_ncds  = TL_gene[genID[kinh2::ncds]];
              mcmom_pimiss  = TL_gene[genID[kinh2::pim_g1]];
              mcmom_pi  = TL_gene[kinh2::pip_g2];
            } else if ( reactionID==gen::reactionID_h2Smmode ){
              mcmom_ncds  = TL_gene[genID[kinh2::ncds]];
              mcmom_pimiss  = TL_gene[genID[kinh2::pip_g1]];
              mcmom_pi  = TL_gene[kinh2::pim_g2];
            }
            //std::cout << std::endl;
            //std::cout << "react n_miss mom: " << react_nmiss.P()/1000.0 << std::endl;
            //std::cout << "mcData n_miss "     << TL_gene[genID[kinh2::nmiss]].P() << std::endl;
            //std::cout << "mcData ncds "       << TL_gene[genID[kinh2::ncds]].P() << std::endl;
            //std::cout << "mcData IM(npi-)  "  << (TL_gene[genID[kinh2::ncds]]+TL_gene[genID[kinh2::pim_g2]]).M() << std::endl;
            //std::cout << "mcData IM(nmisspi-)  "  << (TL_gene[genID[kinh2::nmiss]]+TL_gene[genID[kinh2::pim_g2]]).M() << std::endl;
            //std::cout << "G4flag " << flagG4Decay << std::endl;
            //std::cout << "initial n" << isInitial << std::endl;
            //TVector3 mcvertex_tmp = mcData->track(kinh2::kmbeam)->vertex();
            //TVector3 mcvertex_nmiss = mcData->track(genID[kinh2::nmiss])->vertex();
            //TVector3 mcvertex_ncds = mcData->track(genID[kinh2::ncds])->vertex();
            //std::cout << "MCvertex beam " << mcvertex_tmp.X()/10.0 << "  " << mcvertex_tmp.Y()/10.0 << "  " << mcvertex_tmp.Z()/10.0 <<  std::endl;
            //std::cout << "MCvertex nmiss " << mcvertex_nmiss.X()/10.0 << "  " << mcvertex_nmiss.Y()/10.0 << "  " << mcvertex_nmiss.Z()/10.0 <<  std::endl;
            //std::cout << "MCvertex ncds " << mcvertex_ncds.X()/10.0 << "  " << mcvertex_ncds.Y()/10.0 << "  " << mcvertex_ncds.Z()/10.0 <<  std::endl;
            //
            //TLorentzVector LVec_n_pim_mc = mcmom_ncds + mcmom_pim;
            //TLorentzVector LVec_n_pip_mc = mcmom_ncds + mcmom_pip;
            //double momdiff_npim = (LVec_n_pim_mc.Vect()-react_Sigma.Vect()*0.001).Mag();
            //double momdiff_npip = (LVec_n_pip_mc.Vect()-react_Sigma.Vect()*0.001).Mag();

            //std::cout << "MC " << LVec_n_pim_mc.P() << std::endl;
            //std::cout << "react " << react_Sigma.P() << std::endl;
            //std::cout << "momdiff" << momdiff_npim << std::endl;


            //if(Verbosity_)std::cout<< "L." << __LINE__ << " val = "<<val1<<" "<<val2<<" -> "<< genID[kinh2::nmiss] <<" "<< genID[kinh2::ncds] << std::endl;

          } // if( NBetaOK && NdEOK )

          // fill tree //
          if(IsncdsfromSigma && IsrecoPassed){
            double ncanvtxr2=999.0;
            double ncanvtxz2=999.0;
            double firstvtxr=999.0;
            double firstvtxz=999.0;
            int ncdsgen2=10;
            int pattern=10;
            int anc=999;
            Util::AnaMcData2(mcData,detData2,ncdhhit->seg(),ncanvtxr2,ncanvtxz2,firstvtxr,firstvtxz,ncdsgen2,pattern,anc);
            mcncanvtxr=ncanvtxr2;
            mcncanvtxz=ncanvtxz2;
            mcncanvtxr=firstvtxr;
            mcncanvtxz=firstvtxz;
            mcncdsgen=ncdsgen2;
            mcpattern=pattern;
            mcnanc=anc;

            dE = ncdhhit->emean();
            neutralseg = ncdhhit->seg();
            nhitOutCDC = nCDCforVeto;
            ForwardCharge = (int)forwardcharge;
            mom_target = LVec_target; // 4-momentum(target)
            mom_pi = LVec_pi;        // 4-momentum(pi+)
            chargepi = charge_pi;
            mom_n = LVec_n;            // 4-momentum(neutron)
            // beta is already filled
            vtx_reaction = vtx_react; // vertex(reaction)
            vtx_pi_beam = vtx_beam_wpi;
            vtx_pi_cdc = vtx_pi;
            CDH_Pos = Pos_CDH;
            if(charge_pi==1) CDH_Pos_pi = pip_cdhprojected;
            else if(charge_pi==0) CDH_Pos_pi = pim_cdhprojected;

            TLorentzVector mcmom_ncdspi = TL_gene[genID[kinh2::ncds]]+TL_gene[kinh2::pip_g2];
            //std::cout << __LINE__ << mcmom_ncdspi.M() << std::endl;
            mc_nparticle = nparticle;
            TVector3 mcvertex = mcData->track(ID[kinh2::kmbeam])->vertex();
            TVector3 mcvertexc(mcvertex.x()/10.,mcvertex.y()/10.,mcvertex.z()/10.); 
            mc_vtx = mcvertexc;
            TVector3 mcdisvertex=mcData->track(ID[kinh2::pip_g2])->vertex();
            TVector3 mcdisvertexc(mcdisvertex.x()/10.,mcdisvertex.y()/10.,mcdisvertex.z()/10.);
            mc_disvtx = mcdisvertexc;
            run_num   = confMan->GetRunNumber(); // run number
            event_num = iev;     // event number
            block_num = 0;      // block number (temp)
            //if(!flagG4Decay){
               //std::cout << pattern << "  " << mcmom_nmiss.P() << std::endl;
            //}
            if(Verbosity_){
              std::cout<<"%%% pippimn event: Event_Number, Block_Event_Number, CDC_Event_Number = "
                <<iev<<" , "<<" ---, "<<ev_cdc<<std::endl;
            }
            mom_beam   = LVec_beam;   // 4-momentum(beam)
            outfile2->cd();
            //if(IsncdsfromSigma && piSigma_detect)
            npiTree->Fill();
            nFill_pippimn++;
            outfile->cd();
          }//IsrecoPassed
        } // if( GeomTools::GetID(vtx_react)==CID_Fiducial )
      //} // if( !nCDCforVeto )
    }else{  //if pi+ pi- X event  
      nAbort_pippim++;
    }

    Tools::H1("BLAnaPassed",IsBLAnaPassed,2,-0.5,1.5);
    nAbort_end++;
    delete detData2;
    
  } // for iev
  
  std::cout<<"===== Sigma pi reconstruction in MC END ====="<<std::endl;
  std::cout<<" nEvent       = "<<exen<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nG4Event_piSigma  = "<<nG4Event_piSigma<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" AllGoodTrack = "<<AllGoodTrack<<std::endl;
  std::cout<<" nTrack       = "<<nTrack<<std::endl;
  std::cout<<" nTrack_PID   = "<<nTrack_PID<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nAbort_nGoodTrack  = "<<nAbort_nGoodTrack<<std::endl;
  std::cout<<" nAbort_nCDH        = "<<nAbort_nCDH<<std::endl;
  std::cout<<" nAbort_nT0         = "<<nAbort_nT0<<std::endl;
  std::cout<<" nAbort_nbpc        = "<<nAbort_nbpc<<std::endl;
  std::cout<<" nAbort_bpctrack    = "<<nAbort_bpctrack<<std::endl;
  std::cout<<" nAbort_nblc2       = "<<nAbort_nblc2<<std::endl;
  std::cout<<" nAbort_fblc2bpc    = "<<nAbort_fblc2bpc<<std::endl;
  std::cout<<" nAbort_flagbmom    = "<<nAbort_flagbmom<<std::endl;
  std::cout<<" nAbort_ftarget     = "<<nAbort_ftarget<<std::endl;
  std::cout<<" nAbort_CDHiso      = "<<nAbort_CDHiso<<std::endl;
  std::cout<<" nAbort_pippim      = "<<nAbort_pippim<<std::endl;
  std::cout<<" nAbort_anothern    = "<<nAbort_anothern<<std::endl;
  std::cout<<" nAbort_end         = "<<nAbort_end<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<std::endl;
  std::cout<<"*** # of pi+ pi- p n n events = "<<nFill_pippimn<<" ***"<<std::endl;
  std::cout<<"==============================================="<<std::endl;

  outfile->Write();
  outfile->Close();

  outfile2->Write();
  outfile2->Close();

  simfile->Close();
  cdcfile->Close();

  delete pdg;

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}

//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
void InitializeHistogram()
//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
{
  
  //** geneneral informantion **//
  Tools::newTH1F( Form("EventCheck"), 20, 0, 20 );

  //defined in IMPiSigmaHist.hh
  bool MCFlag=true;
  InitBasicHist(MCFlag);
  InitIMPiSigmaHist();
  return;
}

void InitTreeVal()
{

  mom_beam.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam)
  mom_target.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.); // 4-momentum(target)
  mom_pi.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi-)
  chargepi=-1;
  mom_n.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron)
  NeutralBetaCDH=-9999.; // veracity of neutral particle on CDH
  tofpi=-9999.;
  tofn=-9999.;
  dE=-9999.;   // energy deposit on CDH
  neutralseg =-1;   // energy deposit on CDH
  nhitOutCDC = -1;
  ForwardCharge = -1;
  vtx_reaction.SetXYZ(-9999., -9999., -9999.); //  vertex(reaction)   
  vtx_pi_beam.SetXYZ(-9999., -9999., -9999.); //  
  vtx_pi_cdc.SetXYZ(-9999., -9999., -9999.);
  CDH_Pos.SetXYZ(-9999., -9999., -9999.);
  CDH_Pos_pi.SetXYZ(-9999., -9999., -9999.);
  run_num=-9999;   // run number
  event_num=-9999; // event number
  block_num=-9999; // block number
  mc_nparticle=-9999;
  mcmom_beam.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // generated 4-momentum(beam)
  mcmom_pi.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // generated 4-momentum(pi+)
  mcchargepi=-1;
  mcmom_ncds.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // generated 4-momentum(neutron)
  mcmom_pimiss.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // generated 4-momentum(neutron)
  mcncanvtxr=999.9;
  mcncanvtxz=999.9;
  mcfirstvtxr=999.9;
  mcfirstvtxz=999.9;
  mcncdsgen=199;
  mcpattern=199;
  mcnanc=199;
  react_pimiss.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  react_Sigma.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  react_pi.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  
  mc_vtx.SetXYZ(-9999., -9999., -9999.);
  mc_disvtx.SetXYZ(-9999., -9999., -9999.);
  //= = = = pippimn final-sample tree = = = =//

}

