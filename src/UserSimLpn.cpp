//----------------------------------------------------------------//
// ===== UserSimLpn.cpp =====
// sample program to reconstruct L p n event
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// reconstruction mathod is based on "EventAnalysis_Lpn_sada(sakuma).cpp"
//----------------------------------------------------------------//
//  exe-file: simLpn [./simLpn $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: when $(OutFile) is "tmp.root", the following 2 files are generated.
//     "tmp.root":      histogram file
//     "tmp_Lpn.root": basic information of Lpn event is listed up in TTree 
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//
//  updated by F.S, 2016 12/28
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"
#include "TrackTools.h"
#include "EventHeader.h"
#include "Tools.h"
#include "ELossTools.h"

#include <TDatabasePDG.h>
#include <KinFitter/TKinFitter.h>
#include <KinFitter/TFitParticlePxPyPz.h>
#include <KinFitter/TFitConstraintM.h>
#include <KinFitter/TFitConstraintEp.h>
#include <Math/ProbFuncMathCore.h>

#define YAMAGA 0 // for reading yamaga's cdc-tracking files = header class in cdc-tracking is EventHeaderMC

#define KFDEBUG 0 // verbose level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices

#define ADCstudy 0 // to obtaine ADC threshold

//-- set run# --//
//const std::string GRUN = "49c";
const std::string GRUN = "65";

Float_t tlogprob1;
Float_t tlogprob2;

Float_t twoimprob1;
Float_t twoimprob2;

TLorentzVector tL_L;
TLorentzVector tL_p;
TLorentzVector tL_n;
TLorentzVector tL_K;

const double MOM_RES = 2.0; // MeV/c
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)

//** cut parameters **//
//@@ only different cut parameters btw Sada & Yamaga are listed @@//
double PARA_blc2bpc_dx_MIN;
double PARA_blc2bpc_dx_MAX;
double PARA_blc2bpc_dy_MIN;
double PARA_blc2bpc_dy_MAX;
double PARA_blc2bpc_dxdz_MIN;
double PARA_blc2bpc_dxdz_MAX;
double PARA_blc2bpc_dydz_MIN;
double PARA_blc2bpc_dydz_MAX;
double PARA_lnL_MAX;
double PARA_MM_LP_MIN;
double PARA_MM_LP_MAX;

const double TDC_CDH_MAX = 20; // ns
const double ADC_CDH_MIN = 1;  // MeV

//= = = = Lpn final-sample tree = = = =//
TLorentzVector mom_beam;   // 4-momentum(beam)
TLorentzVector mom_target; // 4-momentum(target)
TLorentzVector mom_L;      // 4-momentum(Lambda)
TLorentzVector mom_p;      // 4-momentum(proton)
TLorentzVector mom_n;      // 4-momentum(neutron)
TLorentzVector mom_p_L;    // 4-momentum(p from L)
TLorentzVector mom_pi_L;   // 4-momentum(pi- from L)
TVector3 vtx_reaction; // vertex(reaction)
TVector3 vtx_Ldecay;   // vertex(Lambda decay)
int run_num;   // run number
int event_num; // event number
int block_num; // block number
TLorentzVector mcmom_beam; // generated 4-momentum(beam)
TLorentzVector mcmom_L;    // generated 4-momentum(Lambda)
TLorentzVector mcmom_p;    // generated 4-momentum(p)
TLorentzVector mcmom_n;    // generated 4-momentum(n)
TLorentzVector mcmom_p_L;  // generated 4-momentum(p frpm Lambda)
TLorentzVector mcmom_pi_L; // generated 4-momentum(pi from Lambda)
TLorentzVector kfmom_beam;   // 4-momentum(beam) after kinematical refit
TLorentzVector kfmom_L;      // 4-momentum(Lambda) after kinematical refit
TLorentzVector kfmom_p;      // 4-momentum(proton) after kinematical refit
TLorentzVector kfmom_n;      // 4-momentum(neutron) after kinematical refit
TLorentzVector kfmom_p_L;    // 4-momentum(p from L) after kinematical refit
TLorentzVector kfmom_pi_L;   // 4-momentum(pi- from L) after kinematical refit
double kf_chi2;   // chi2 of kinematical refit
double kf_NDF;    // NDF of kinematical refit
double kf_status; // status of kinematical refit -> details can be found in this code
double kf_pvalue; // p-value of kinematical refit
//***//
double lnL;  // log-likelihood function
int mul_CDH;  // CDH multiplicity
int mul_CDHc; // CDH multiplicity with clustering
bool fiducial[3]; // flag of fiducial volume cut, 0:Kp, 1:KL, 2:reaction
//= = = = Lpn final-sample tree = = = =//

using namespace std;

int main( int argc, char** argv )
{
  if( argc!=5 ){
    cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<endl;
    return 0;
  }

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");

  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//
  double covVal[6][16] = {
    // ### obtained from (p_meas[j]-p_gene[j])
    // ###  using G4-data with TH1F(Form("cov_%d_%d_%d", i, j, k), 100, -cov_MAX, cov_MAX);
    // {beam kaon}, {lambda}, {neutron},
    // {proton}, {proton from lambda}, {pi- from lambda}
    { 1.99756e-05, 0, 0, 0,
      0, 2.03238e-05, 0, 0,
      0, 0, 3.98332e-06, 0,
      0, 0, 0, 3.21168e-06 },
    { 0.00019133, 0, 0, 0,
      0, 0.000195769, 0, 0,
      0, 0, 0.000152124, 0,
      0, 0, 0, 0.000198292 },
    { 0.000557651, 0, 0, 0,
      0, 0.000558919, 0, 0,
      0, 0, 0.000364122, 0,
      0, 0, 0, 0.000154495 },
    { 0.000230955, 0, 0, 0,
      0, 0.000232413, 0, 0,
      0, 0, 0.000164732, 0,
      0, 0, 0, 0.000309589 },
    { 0.000183506, 0, 0, 0,
      0, 0.000184892, 0, 0,
      0, 0, 0.00012552, 0,
      0, 0, 0, 0.000189062 },
    { 7.52278e-06, 0, 0, 0,
      0, 7.48424e-06, 0, 0,
      0, 0, 1.19286e-05, 0,
      0, 0, 0, 3.70293e-06 }
  };
  TMatrixD *covZero = new TMatrixD(4, 4);
  covZero->Zero();
  covZero->ResizeTo(3, 3); // resize from 4x4 to 3x3
  TMatrixD *covParticle[6];
  for( int i=0; i<6; i++ ){
    covParticle[i] = new TMatrixD(4, 4);
    int n = 0;
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ ){
	if( j==k ) (*covParticle[i])[j][k] = covVal[i][n]; // only diagonal elements
	else       (*covParticle[i])[j][k] = 0;
	n++;
      }
    }
    covParticle[i]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticle[i]->Print(); // Print all
  }
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//

  //** Conf file open **// 
  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  //** Simulation file open **// 
  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);
  if( tree2->GetEntries()==1 ) cout<<"  !!! tree2 entries==1 !!!"<<endl;
  else tree2->GetEntry(0);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  //** Getting CDSTracking info. from CDCfile **//
  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
#if YAMAGA
  EventHeaderMC    *header = new EventHeaderMC();
  evTree->SetBranchAddress("EventHeaderMC", &header );
#else
  EventHeader      *header = new EventHeader();
  evTree->SetBranchAddress("EventHeader", &header );
#endif
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan  = new BeamLineTrackMan();
  CDSTrackingMan   *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  //** output file 1 : histograms **//
  TFile *outfile = new TFile(argv[2], "recreate");
  outfile->cd();

  //** output file 2 : Lpn final-sample tree **// 
  std::string outfile2_name = string(argv[2]);
  outfile2_name.insert( outfile2_name.size()-5, "_Lpn" );
  std::cout<<"Lpn file "<<outfile2_name<<std::endl;
  TFile *outfile2 = new TFile( outfile2_name.c_str(), "recreate" );
  outfile2->cd();
  TTree *lpnTree = new TTree( "EventTree", "EventTree" );
  lpnTree->Branch( "mom_beam",   &mom_beam );
  lpnTree->Branch( "mom_target", &mom_target );
  lpnTree->Branch( "mom_L", &mom_L );
  lpnTree->Branch( "mom_p", &mom_p );
  lpnTree->Branch( "mom_n", &mom_n );
  lpnTree->Branch( "mom_p_L", &mom_p_L );
  lpnTree->Branch( "mom_pi_L", &mom_pi_L );
  lpnTree->Branch( "vtx_reaction", &vtx_reaction );
  lpnTree->Branch( "vtx_Ldecay", &vtx_Ldecay );
  lpnTree->Branch( "run_num", &run_num );
  lpnTree->Branch( "event_num", &event_num );
  lpnTree->Branch( "block_num", &block_num );
  lpnTree->Branch( "mcmom_beam",   &mcmom_beam );
  lpnTree->Branch( "mcmom_L", &mcmom_L );
  lpnTree->Branch( "mcmom_p", &mcmom_p );
  lpnTree->Branch( "mcmom_n", &mcmom_n );
  lpnTree->Branch( "mcmom_p_L", &mcmom_p_L );
  lpnTree->Branch( "mcmom_pi_L", &mcmom_pi_L );
  lpnTree->Branch( "kfmom_beam",   &kfmom_beam );
  lpnTree->Branch( "kfmom_L", &kfmom_L );
  lpnTree->Branch( "kfmom_p", &kfmom_p );
  lpnTree->Branch( "kfmom_n", &kfmom_n );
  lpnTree->Branch( "kfmom_p_L", &kfmom_p_L );
  lpnTree->Branch( "kfmom_pi_L", &kfmom_pi_L );
  lpnTree->Branch( "kf_chi2", &kf_chi2 );
  lpnTree->Branch( "kf_NDF", &kf_NDF );
  lpnTree->Branch( "kf_status", &kf_status );
  lpnTree->Branch( "kf_pvalue", &kf_pvalue );
  lpnTree->Branch( "lnL", &lnL );
  lpnTree->Branch( "mul_CDH", &mul_CDH );
  lpnTree->Branch( "mul_CDHc", &mul_CDHc );
  lpnTree->Branch( "fiducial", fiducial, "fiducial[3]/O" );
  outfile->cd();


  cerr<<"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"<<endl;
  cerr<<"  (MC)        tree->GetEntries()   = "<<tree->GetEntries()<<endl;
  cerr<<"  (CDC-track) evTree->GetEntries() = "<<evTree->GetEntries()<<endl;
  cerr<<"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"<<endl;

  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    //return 0;
  }


  //=== definitino of histograms ===//
  //** gneneral informantion **//
  Tools::newTH1F( Form("Time"), 3000, -0.5, 2999.5 );
  Tools::newTH1F( Form("EventCheck"), 20, 0, 20 );
  Tools::newTH1F( Form("Scaler"), 41, -0.5, 40.5 );

  //** CDC and CDH information from CDC-trackig file **//
  Tools::newTH1F( Form("nGoodTrack"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_CDH"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_CDHc"), 11, -0.5, 10.5 );

  //** beam line **//
  Tools::newTH1F( Form("mul_BHD"), 12, -0.5, 11.5 );
  Tools::newTH1F( Form("mul_T0"),   6, -0.5, 5.5 );
  Tools::newTH1F( Form("tof_T0BHD"), 2000, 20, 40 );
  Tools::newTH1F( Form("tracktime_BPC"),  1200, -200, 400 );
  Tools::newTH1F( Form("trackchi2_BPC"),  200, 0, 20 );
  Tools::newTH1F( Form("ntrack_BPC"),  6, -0.5, 5.5 );
  Tools::newTH1F( Form("tracktime_BLC1"), 1200, -200, 400 );
  Tools::newTH1F( Form("tracktime_BLC2"), 1200, -200, 400 );
  Tools::newTH1F( Form("trackchi2_BLC1"), 200, 0, 20 );
  Tools::newTH1F( Form("trackchi2_BLC2"), 200, 0, 20 );
  Tools::newTH1F( Form("ntrack_BLC1"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_BLC2"), 6, -0.5, 5.5 );
  Tools::newTH2F( Form("dydx_BLC2BPC"),     130, -1.3, 1.3, 130, -1.3, 1.3 );
  Tools::newTH2F( Form("dydzdxdz_BLC2BPC"), 175, -0.035, 0.035, 175, -0.035, 0.035 );
  Tools::newTH1F( Form("trackchi2_beam"), 400, 0, 40 );
  Tools::newTH1F( Form("momentum_beam"), 180, 0.92, 1.10 );

  //** CDS **//
  Tools::newTH1F( Form("trackchi2_CDC"), 1000, 0, 50 );
  Tools::newTH2F( Form("PID_CDS_beta"), 1000, 0, 5, 1000, -1.2, 1.2 );
  Tools::newTH2F( Form("PID_CDS"), 1000, -0.6, 5, 1000, -1.2, 1.2 );
  Tools::newTH1F( Form("ntrack_CDS"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_pi_plus"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_proton"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_deuteron"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_pi_minus"), 6, -0.5, 5.5 );
  Tools::newTH1F( Form("ntrack_K_minus"), 6, -0.5, 5.5 );

  //** forward counters **//
  Tools::newTH1F( Form("mul_BVC"), 9, -0.5, 8.5 );
  Tools::newTH1F( Form("mul_CVC"), 11, -0.5, 10.5 );
  Tools::newTH1F( Form("mul_PC"), 11, -0.5, 10.5 );

  //** p p pi event **//
  Tools::newTH1F( Form("IM_p_pim"),  280, 1.08, 1.15 );
  Tools::newTH1F( Form("DCA_p_pim"), 200, 0, 2 );
  Tools::newTH1F( Form("DCA_L_Km"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_p_Km"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_L_p"),   200, 0, 2 );
  Tools::newTH1F( Form("lnL"),  400, 0, 40 );
  Tools::newTH1F( Form("lnL_wrong"),  400, 0, 40 );
  Tools::newTH3F( Form("reaction_vertex"), 180, -9, 9, 180, -9, 9, 400, -20, 20 );
  Tools::newTH1F( Form("IM_L_p"), 100, 2, 3 );
  Tools::newTH1F( Form("MM_L_p"), 140, 0.4, 1.8 );

  //** p p pi event in fiducial volume**//
  Tools::newTH1F( Form("IM_p_pim_f"),  280, 1.08, 1.15 );
  Tools::newTH1F( Form("DCA_p_pim_f"), 200, 0, 2 );
  Tools::newTH1F( Form("DCA_L_Km_f"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_p_Km_f"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_L_p_f"),   200, 0, 2 );
  Tools::newTH1F( Form("lnL_f"),  400, 0, 40 );
  Tools::newTH1F( Form("lnL_wrong_f"),  400, 0, 40 );
  Tools::newTH3F( Form("reaction_vertex_f"), 180, -9, 9, 180, -9, 9, 400, -20, 20 );
  Tools::newTH1F( Form("IM_L_p_f"), 100, 2, 3 );
  Tools::newTH1F( Form("MM_L_p_f"), 140, 0.4, 1.8 );

  //** p L selected event **//
  Tools::newTH1F( Form("IM_p_pim_pL"),  280, 1.08, 1.15 );
  Tools::newTH1F( Form("DCA_p_pim_pL"), 200, 0, 2 );
  Tools::newTH1F( Form("DCA_L_Km_pL"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_p_Km_pL"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_L_p_pL"),   200, 0, 2 );
  Tools::newTH1F( Form("lnL_pL"),  400, 0, 40 );
  Tools::newTH1F( Form("lnL_wrong_pL"),  400, 0, 40 );
  Tools::newTH3F( Form("reaction_vertex_pL"), 180, -9, 9, 180, -9, 9, 400, -20, 20 );
  Tools::newTH1F( Form("IM_L_p_pL"), 100, 2, 3 );
  Tools::newTH1F( Form("MM_L_p_pL"), 140, 0.4, 1.8 );

  //** p L selected event in fiducial volume **//
  Tools::newTH1F( Form("IM_p_pim_pLf"),  280, 1.08, 1.15 );
  Tools::newTH1F( Form("DCA_p_pim_pLf"), 200, 0, 2 );
  Tools::newTH1F( Form("DCA_L_Km_pLf"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_p_Km_pLf"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_L_p_pLf"),   200, 0, 2 );
  Tools::newTH1F( Form("lnL_pLf"),  400, 0, 40 );
  Tools::newTH1F( Form("lnL_wrong_pLf"),  400, 0, 40 );
  Tools::newTH3F( Form("reaction_vertex_pLf"), 180, -9, 9, 180, -9, 9, 400, -20, 20 );
  Tools::newTH1F( Form("IM_L_p_pLf"), 100, 2, 3 );
  Tools::newTH1F( Form("MM_L_p_pLf"), 140, 0.4, 1.8 );

  //** L p n final sample **//
  Tools::newTH1F( Form("IM_p_pim_Lpn"),  280, 1.08, 1.15 );
  Tools::newTH1F( Form("DCA_p_pim_Lpn"), 200, 0, 2 );
  Tools::newTH1F( Form("DCA_L_Km_Lpn"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_p_Km_Lpn"),  100, 0, 1 );
  Tools::newTH1F( Form("DCA_L_p_Lpn"),   200, 0, 2 );
  Tools::newTH1F( Form("lnL_Lpn"),  400, 0, 40 );
  Tools::newTH1F( Form("lnL_wrong_Lpn"),  400, 0, 40 );
  Tools::newTH3F( Form("reaction_vertex_Lpn"), 180, -9, 9, 180, -9, 9, 400, -20, 20 );
  Tools::newTH1F( Form("IM_L_p_Lpn"), 100, 2, 3 );
  Tools::newTH1F( Form("MM_L_p_Lpn"), 140, 0.4, 1.8 );

  //** CDH ADC vs. TDC **//
  Tools::newTH2F( Form("CDH_ADC_TDC"),    100, 0.0, 40.0, 100, 0.0, 40.0 );
  Tools::newTH2F( Form("CDH_ADC_TDC_pi"), 100, 0.0, 40.0, 100, 0.0, 40.0 );
  Tools::newTH2F( Form("CDH_ADC_TDC_p"),  100, 0.0, 40.0, 100, 0.0, 40.0 );

#if ADCstudy
  Tools::newTH1F( Form("ADC_T0"), 100, 0.0, 10.0 );
  Tools::newTH1F( Form("ADC_DEF"), 100, 0.0, 10.0 );
  Tools::newTH1F( Form("ADC_CDH"), 100, 0.0, 10.0 );
  Tools::newTH1F( Form("ADC_BVC"), 100, 0.0, 10.0 );
  Tools::newTH1F( Form("ADC_CVC"), 100, 0.0, 10.0 );
  Tools::newTH1F( Form("ADC_NC"), 100, 0.0, 10.0 );
  Tools::newTH1F( Form("ADC_PC"), 100, 0.0, 10.0 );
#endif

#if 1
  //*** for kinematical fit ***//
  //
  // original TH1s, which were used for study of KF described in
  //  http://ag.riken.jp/J-PARC/sakuma/weekly_meeting/KinematicalFit/KinematicalFit.pdf
  // can be found in src/UserSimLpn.cpp.20170822
  //
  // beam_K(K+), L, n, p, p from L, pi- from L
  double cov_MAX;
  for( int i=0; i<6; i++ ){
    for( int j=0; j<4; j++ ){
      for( int k=0; k<4; k++ )
	{if( i==0 || i==5 ) // K-, pi
          cov_MAX = 0.02;
        else // L, n, p, p_L
          cov_MAX = 0.1;
	Tools::newTH1F(Form("cov_%d_%d_%d", i, j, k), 100, -cov_MAX, cov_MAX);
      }
    }
  }
#endif

  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  cout<<"===== Lambda p n reconstruction in MC START ============="<<endl;
  cout<<"     # of All  Event in EventTree:     "<<eventn<<endl;
  cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<endl;
  cout<<"     # of Exe  Event in this program:  "<<exen<<endl;
  cout<<"========================================================="<<endl;

  //** set cut parameters **//
  if( GRUN=="49c" ){
    //** from EventAnalysis_Lpn_sada.cpp **// //!! sada-D p.73 !!//
    PARA_blc2bpc_dx_MIN = -0.795;
    PARA_blc2bpc_dx_MAX = 0.822;
    PARA_blc2bpc_dy_MIN = -0.865;
    PARA_blc2bpc_dy_MAX = 0.871;
    PARA_blc2bpc_dxdz_MIN = -0.0240;
    PARA_blc2bpc_dxdz_MAX = 0.0250;
    PARA_blc2bpc_dydz_MIN = -0.02481;
    PARA_blc2bpc_dydz_MAX = 0.02489;
    PARA_lnL_MAX = 6.0;
  }else if ( GRUN=="65" ){
    //** from Yamaga:MyAnalysisBL.cpp **//
    PARA_blc2bpc_dx_MIN = -0.75;
    PARA_blc2bpc_dx_MAX = 0.75;
    PARA_blc2bpc_dy_MIN = -0.75;
    PARA_blc2bpc_dy_MAX = 0.75;
    PARA_blc2bpc_dxdz_MIN = -0.02;
    PARA_blc2bpc_dxdz_MAX = 0.02;
    PARA_blc2bpc_dydz_MIN = -0.02;
    PARA_blc2bpc_dydz_MAX = 0.02;
    PARA_lnL_MAX = 9.95;
  }else{
    std::cerr<<" !!! pleas set paramter::GRUN in EventAnalysis_Lpn_sakuma.cpp => 49c or 65 !!!"<<std::endl;
    return 0;
  }

  PARA_MM_LP_MIN = 0.85;
  PARA_MM_LP_MAX = 1.03;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;
  int nEvent_Lp    = 0;
  int nEvent_Lpn   = 0;

  int nG4Event_Lp   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_nCDH = 0;
  int nAbort_nT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_ftarget = 0;
  int nAbort_pppi = 0;
  int nAbort_end = 0;

  int nFill_pppi = 0;
  int nFill_Lp = 0;
  int nFill_Lpf = 0;
  int nFill_Lpn = 0;


  int nTrack_CDHshare = 0;

  int ev_cdc = 0;

  //=== event loop ===//
  for( int ev=0; ev<exen; ev++ ){
#if 1
    if( /*ev<100 ||*/ ev%100==0 ) std::cout<<"> Event Number "<<ev<<std::endl;
#else
    std::cout<<"> Event Number "<<ev<<std::endl;
    if( ev == 1000 ) break;
#endif

    Tools::Fill1D( Form("EventCheck"), 1 );

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(ev); // MC
    evTree->GetEntry(ev_cdc); // CDC-tracking
    
    //### event ID matching
#if YAMAGA
    if( evHeaderMC->eventID()!=header->eventID() ){
#else
    if( evHeaderMC->eventID()!=header->ev() ){
#endif
      continue;
    }
    ev_cdc++;


    //### CDH ADC cut ###//
    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ){
      if( !(detData->detectorHit(i)->detectorID()==CID_CDH && detData->detectorHit(i)->adc()<ADC_CDH_MIN) ){
	detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }


    simMan->Convert(detData2, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);
    bltrackMan->DoTracking(blMan, confMan, true, true);

#if ADCstudy
    for( int i=0; i<detData2->detectorHitSize(); i++ ){
      switch( detData2->detectorHit(i)->detectorID() ){
      case CID_T0:
	Tools::Fill1D( Form("ADC_T0"),  detData2->detectorHit(i)->adc() ); break;
      case CID_DEF:
	Tools::Fill1D( Form("ADC_DEF"),  detData2->detectorHit(i)->adc() ); break;
      case CID_CDH:
	Tools::Fill1D( Form("ADC_CDH"),  detData2->detectorHit(i)->adc() ); break;
      case CID_BVC:
	Tools::Fill1D( Form("ADC_BVC"),  detData2->detectorHit(i)->adc() ); break;
      case CID_CVC:
	Tools::Fill1D( Form("ADC_CVC"),  detData2->detectorHit(i)->adc() ); break;
      case CID_NC:
	Tools::Fill1D( Form("ADC_NC"),  detData2->detectorHit(i)->adc() ); break;
      case CID_PC:
	Tools::Fill1D( Form("ADC_PC"),  detData2->detectorHit(i)->adc() ); break;
      default:
	break;
      }
    }
#endif

    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4LppimDecay = false;
    int kpp_track = -1;
    int L_parent  = 0;
    int p_parent  = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      int track   = mcData->track(j)->trackID();
      if( pdgcode==9999 && parent==0 ){ // Kpp
	kpp_track = track;
	L_parent  = track;
	p_parent  = track;
      }
      if( pdgcode==3212 && parent==0 ){ // initial Sigma0
	L_parent = track;
      }
      if( pdgcode==3212 && parent==kpp_track ){ // Sigma0 from Kpp
	L_parent = track;
      }
    }

    int PDG[6] = {321, 3122, 2112, 2212, 2212, -211};
    // beam_K(K+), L, n, p, p from L, pi- from L
    int parentID[6] = {0, L_parent, 0, p_parent, -1, -1};
    int ID[6]       = {-1, -1, -1, -1, -1, -1};
    int trackID[6]  = {-1, -1, -1, -1, -1, -1};
    int nparticle = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      int track   = mcData->track(j)->trackID();
      //cerr<<j<<" | "<<pdgcode<<" "<<parent<<" "<<track<<endl;
      for( int k=0; k<6; k++ ){
	if( pdgcode==PDG[k] && parent==parentID[k] ){
	  ID[k] = j;
	  trackID[k] = track;
	  nparticle++;
	  if( k==1 ){
	    parentID[4] = track;
	    parentID[5] = track;
	  }
	}
      }
    }
    if( nparticle==6 ) flagG4LppimDecay = true;

    int nCDHhit[6] = {0, 0, 0, 0, 0, 0};
    if( flagG4LppimDecay ){ // Lambda -> p pi- decay
      for( int j=0; j<detData2->detectorHitSize(); j++ ){
	int cid   = detData2->detectorHit(j)->detectorID();
	int track = detData2->detectorHit(j)->trackID();
	for( int k=3; k<6; k++ ){
	  if( cid==CID_CDH && track==trackID[k] ) nCDHhit[k]++;
	}
      }
    }
    if( nCDHhit[3] && nCDHhit[4] && nCDHhit[5] ) nG4Event_Lp++;
#if 0
    else{
      continue;
    }
#endif

    // beam_K(K+), L, n, p, p from L, pi- from L
    TLorentzVector TL_gene[6]; // generated
    if( flagG4LppimDecay ){ // Lambda -> p pi- decay
      for( int i=0; i<6; i++ ){
	if( i ) TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*0.001,  pdg->GetParticle(PDG[i])->Mass()); // GeV
	else    TL_gene[i].SetVectM(mcData->track(ID[i])->momentum()*-0.001, pdg->GetParticle(PDG[i])->Mass()); // GeV
      }
      TVector3 boost = TL_gene[1].BoostVector(); // CM @ L
      TLorentzVector TL_gene_CM[6]; // generated at CM
      for( int i=0; i<6; i++ ){
	TL_gene_CM[i] = TL_gene[i];
	TL_gene_CM[i].Boost(-1*boost);
      }

#if 0
      //TVector3 n_cross_K = TL_gene_CM[2].Vect().Cross(TL_gene_CM[0].Vect()); // n x K-
      //double costheta_nK_pL = cos(n_cross_K.Angle(TL_gene_CM[4].Vect())); // angle btw (n x K-) and (p from Lambda)
      TVector3 K_cross_n = TL_gene_CM[0].Vect().Cross(TL_gene_CM[2].Vect()); // K- x n
      double costheta_nK_pL = cos(K_cross_n.Angle(TL_gene_CM[4].Vect())); // angle btw (K- x n) and (p from Lambda)

      TLorentzVector TL_gene_Lp = TL_gene[1]+TL_gene[3]; // L+p
      boost = TL_gene_Lp.BoostVector(); // CM @ L+p
      for( int i=0; i<6; i++ ){
	TL_gene_CM[i] = TL_gene[i];
	TL_gene_CM[i].Boost(-1*boost);
      }
      K_cross_n = TL_gene_CM[0].Vect().Cross(TL_gene_CM[2].Vect()); // K- x n
      double costheta_nK_L = cos(K_cross_n.Angle(TL_gene_CM[1].Vect())); // angle btw (K- x n) and Lambda
#endif
    }
    //##########################//
    //### get G4 information ###//
    //##########################//


    //=======================================//
    //=== from EventAnalysis_Lpn_sada.cpp ===//
    //=======================================//
    int nGoodTrack = cdstrackMan->nGoodTrack();
    int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;
    Tools::Fill1D( Form("nGoodTrack"), nGoodTrack );

    if( nGoodTrack!=3 ){ // dedicated for p p pi- event
      nAbort_nGoodTrack++;
      continue;
    }

    //** # of CDH-hits cut **// 
    int nCDH = 0;
    for( int i=0; i<cdsMan->nCDH(); i++ ){
      //if( cdsMan->CDH(i)->CheckRange() ){
      if( cdsMan->CDH(i)->CheckRange() && cdsMan->CDH(i)->ctmean()<TDC_CDH_MAX ){
	Tools::Fill2D( Form("CDH_ADC_TDC"), cdsMan->CDH(i)->ctmean(), cdsMan->CDH(i)->emean() );
	nCDH++;
      }
    }
    Tools::Fill1D( Form("mul_CDH"), nCDH );
    if( GRUN=="49c" && nCDH<3 ){ //** at least 3 hits **//
      nAbort_nCDH++;
      continue;
      //}else if( GRUN=="65" && nCDH!=3 ){ //** only 3 hits events **//
    }else if( GRUN=="65" && nCDH<3 ){ //** at least 3 hits **//
      nAbort_nCDH++;
      continue;
    }


    //** T0 = 1hit selection **//
    int nT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      HodoscopeLikeHit *hit = blMan->T0(i);
      if( hit->CheckRange() ) nT0++;
    }
    Tools::Fill1D( Form("mul_T0"),  nT0 );
    if( nT0!=1 ){ 
      nAbort_nT0++;
      continue;
    }

    //** Beam PID **//
    double ctmT0 = 0;
    for( int i=0; i<blMan->nT0(); i++ ){
      if( blMan->T0(i)->CheckRange() ){
	ctmT0 = blMan->T0(i)->ctmean();
      }
    }
    int pid_beam = 0; //0:K 1:pi 3:else

    //** BPC track selection **//
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ){
      nbpc++;
      bpcid = i;
    }
    Tools::Fill1D( Form("ntrack_BPC"), nbpc );
    if( nbpc!=1 ){
      nAbort_nbpc++;
      continue;
    }
    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);
    //std::cerr<<"@@@@@@@@ " <<bpctrack->chi2all()<<std::endl;
    if( bpctrack->chi2all()>10 ){
      nAbort_bpctrack++;
      continue;
    }

    //** vertex calculation **//
    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ){
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }


    //** vectors for PID container **//
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    std::vector <int> d_ID;
    
    std::vector <int> vCDHseg;

    bool flagbmom = false;
    TVector3 vtx_react;

    //** BLC2 track **//
    int nblc2 = 0;
    int blc2id = -1;
    for( int i=0; i<bltrackMan->ntrackBLC2(); i++ ){
      nblc2++;
      if( bltrackMan->trackBLC2(i)->chi2all()<10 ) blc2id = i;
    }
    Tools::Fill1D( Form("ntrack_BLC2"), nblc2 );
    if( !(nblc2==1 && blc2id!=-1) ){
      nAbort_nblc2++;
      continue;
    }

    //### BLC2-BPC position matching
    bool fblc2bpc = false;
    for( int ii=0; ii<bltrackMan->ntrackBLC2(); ii++ ){
      if( ii!=blc2id ) continue;
      LocalTrack *blc2 = bltrackMan->trackBLC2(ii);
      double xblc2bpc[2], yblc2bpc[2];
      double xmom[2], ymom[2];

      TVector3 Pos_BPC, Pos_BLC2, tmp;
      confMan->GetBLDCWireMapManager()->GetGParam( CID_BPC, Pos_BPC, tmp );
      confMan->GetBLDCWireMapManager()->GetGParam( CID_BLC2a, Pos_BLC2, tmp );
      double zPos_BPC = Pos_BPC.Z();
      double zPos_BLC2 = Pos_BLC2.Z();
      double zPos_BPC_BLC2 = (Pos_BPC.Z()+Pos_BLC2.Z())/2;

      bpctrack->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[0], yblc2bpc[0] );
      bpctrack->XYPosatZ( zPos_BPC, xmom[0], ymom[0] );
      blc2->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[1], yblc2bpc[1]);
      blc2->XYPosatZ( zPos_BLC2, xmom[1], ymom[1]);
      double dxdz[2], dydz[2];
      dxdz[0] = (xmom[0]-xblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
      dxdz[1] = (xmom[1]-xblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);
      dydz[0] = (ymom[0]-yblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
      dydz[1] = (ymom[1]-yblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);

      if(      (xblc2bpc[1]-xblc2bpc[0])<PARA_blc2bpc_dx_MIN ||
	       (xblc2bpc[1]-xblc2bpc[0])>PARA_blc2bpc_dx_MAX ) fblc2bpc = false;
      else if( (yblc2bpc[1]-yblc2bpc[0])<PARA_blc2bpc_dy_MIN ||
	       (yblc2bpc[1]-yblc2bpc[0])>PARA_blc2bpc_dy_MAX ) fblc2bpc = false;
      else if( (dxdz[1]-dxdz[0])<PARA_blc2bpc_dxdz_MIN ||
	       (dxdz[1]-dxdz[0])>PARA_blc2bpc_dxdz_MAX ) fblc2bpc = false;
      else if( (dydz[1]-dydz[0])<PARA_blc2bpc_dydz_MIN ||
	       (dydz[1]-dydz[0])>PARA_blc2bpc_dydz_MAX ) fblc2bpc = false;
      else fblc2bpc = true;

      Tools::Fill2D( Form("dydx_BLC2BPC"), xblc2bpc[1]-xblc2bpc[0], yblc2bpc[1]-yblc2bpc[0] );
      Tools::Fill2D( Form("dydzdxdz_BLC2BPC"), dxdz[1]-dxdz[0], dydz[1]-dydz[0] );
    }

    if( !fblc2bpc ){
      nAbort_fblc2bpc++;
      continue;
    }

    //** beam momentum calculation **//
    TLorentzVector L3_beambf;  // 4-Momentum(beam) in LAB
    TLorentzVector L3_beam;    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector L3_target;  // 4-Momentum(He3-target) in LAB
    TLorentzVector L3_targetP; // 4-Momentum(p-target) in LAB
    TLorentzVector L3_beambfCM;  // 4-Momentum(beam) in CM
    TLorentzVector L3_beamCM;    // 4-Momentum(beam) in CM with dE correcion
    TLorentzVector L3_targetCM;  // 4-Momentum(He3-target) in CM
    TLorentzVector L3_targetPCM; // 4-Momentum(p-target) in CM

    TVector3 Pos_T0;
    confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
    double zPos_T0 = Pos_T0.Z();

    double beammom = 0;
    for( int j=0; j<mcData->trackSize(); j++ ){
      int pdgcode = mcData->track(j)->pdgID();
      int parent  = mcData->track(j)->parentTrackID();
      if( pdgcode==321 && parent==0 ){
	beammom = (mcData->track(j)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
	break;
      }
    }

    double x1, y1, x2, y2;
    double z1 = 0, z2 = 20;
    bpctrack->XYPosatZ(z1, x1, y1);
    bpctrack->XYPosatZ(z2, x2, y2);
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls; 
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    L3_beambf.SetVectM(Pp_beam , kpMass);
    L3_target.SetVectM(Pp_target, ThreeHeMass);
    L3_targetP.SetVectM(Pp_target, pMass);
    L3_beam = L3_beambf;
    TVector3 boost = (L3_target+L3_beam).BoostVector();
    L3_beambfCM = L3_beam;
    L3_targetCM = L3_target;
    L3_targetPCM = L3_targetP;
    L3_beambfCM.Boost(-1*boost);
    L3_targetCM.Boost(-1*boost);
    L3_targetPCM.Boost(-1*boost);
    flagbmom = true;

    if( !flagbmom ){
      nAbort_flagbmom++;
      continue;
    }
    Tools::Fill1D( Form("momentum_beam"), L3_beambf.P() );

    //** + + + + + + + + + + + + **//
    //**  PID in CDS             **//
    //** + + + + + + + + + + + + **//

    //** PID of CDS tracks **//
    for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){
      CDSTrack *track = cdstrackMan->Track(cdstrackMan->GoodTrackID(it));

      Tools::Fill1D( Form("trackchi2_CDC"), track->Chi() );

      if( track->Chi()>30 ) continue; 
      if( !track->CDHFlag() ) continue;

      double mom = track->Momentum();
      TVector3 vtxb1, vtxb2, vtxb;
      track->GetVertex( bpctrack->GetPosatZ(zPos_T0), bpctrack->GetMomDir(), vtxb1, vtxb2 );
      track->SetPID(-1);
      vtxb = (vtxb1+vtxb2)*0.5;

      double tof = 999.;
      double mass2 = -999.;
      int CDHseg = -1;
      for( int icdh=0; icdh<track->nCDHHit(); icdh++ ){
	HodoscopeLikeHit *cdhhit=track->CDHHit(cdsMan,icdh);
	double tmptof = cdhhit->ctmean() - ctmT0;      
	//cerr<<icdh<<": "<<cdhhit->ctmean()<<" - "<<ctmT0<<" = "<<tmptof<<endl;
	if( tmptof<tof || tof==999. ){ //*** apply minimum TOF hit ***//
	  tof = tmptof;
	  CDHseg = cdhhit->seg();
	}
      }
      //*************************************
      // In a CDH hit-shared event, only some one track is adopted and the others are discarded
      //*************************************

      bool CDHflag = true;
      for( int m=0; m<(int)vCDHseg.size(); m++ ){
	if( CDHseg==vCDHseg[m] ) CDHflag = false;
      }
      if( !CDHflag ){
	nTrack_CDHshare++;
	continue;
      }
      vCDHseg.push_back(CDHseg);

      //** calculation of beta and squared-mass **//
      double tmptof, beta_calc;
      if( !TrackTools::FindMass2( track, bpctrack, tof, L3_beam.Vect().Mag(),
				  pid_beam, beta_calc, mass2, tmptof ) ){
	std::cerr<<" !!! failure in PID_CDS [FindMass2()] !!! "<<std::endl;
	continue;
      }
      int pid = TrackTools::PIDcorr(mom,mass2);      
      track->SetPID(pid);
      Tools::Fill2D( "PID_CDS_beta", 1/beta_calc, mom );
      Tools::Fill2D( "PID_CDS", mass2, mom );

      //** energy loss calculation **//
      double tmpl;
      TVector3 vtx_beam, vtx_cds;
      if( !track->CalcVertexTimeLength(bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), track->Mass(),
				       vtx_beam, vtx_cds, tmptof, tmpl, true) ){
	std::cerr<<" !!! failure in energy loss calculation [CalcVertexTimeLength()] !!! "<<std::endl;
	continue;
      }

      if( pid==CDS_PiMinus )
	pim_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_PiPlus )
	pip_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_Proton )
	p_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_Deuteron )
	d_ID.push_back(cdstrackMan->GoodTrackID(it));
      else if( pid==CDS_Kaon )
	km_ID.push_back(cdstrackMan->GoodTrackID(it));
      
      if( pid<7 ) nTrack_PID++;

      //** CDH ADC vs. TDC **//
      for( int icdh=0; icdh<track->nCDHHit(); icdh++ ){
	HodoscopeLikeHit *cdhhit=track->CDHHit(cdsMan,icdh);
	if( CDHseg == cdhhit->seg() && (pid==CDS_PiMinus || pid==CDS_PiPlus) )
	  Tools::Fill2D( Form("CDH_ADC_TDC_pi"), cdhhit->ctmean(), cdhhit->emean() );
	if( CDHseg == cdhhit->seg() && pid==CDS_Proton )
	  Tools::Fill2D( Form("CDH_ADC_TDC_p"), cdhhit->ctmean(), cdhhit->emean() );
      }

      //cerr<<"    pid = "<<pid<<", tof = "<<tmptof<<", beta = "<<beta_calc
      //<<", mom = "<<mom<<", mass = "<<sqrt(fabs(mass2))<<endl;

    }// for( int it=0; it<cdstrackMan->nGoodTrack(); it++ ){
    //** end of PID **//

    Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+d_ID.size()+pim_ID.size()+km_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_plus"),  pip_ID.size() );
    Tools::Fill1D( Form("ntrack_proton"),   p_ID.size() );
    Tools::Fill1D( Form("ntrack_deuteron"), d_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_minus"), pim_ID.size() );
    Tools::Fill1D( Form("ntrack_K_minus"),  km_ID.size() );



    //** charge veto with BVC, CVC (TOF=CVC), & PC **//
    int nBVC = 0;
    int nCVC = 0;
    int nPC  = 0;
    for( int i=0; i<blMan->nBVC(); i++ ){
      if( blMan->BVC(i)->CheckRange() ) nBVC++;
    }
    for( int i=0; i<blMan->nTOF(); i++ ){
      if( blMan->TOF(i)->CheckRange() ) nCVC++;
    }
    for( int i=0; i<blMan->nPC(); i++ ){
      if( blMan->PC(i)->CheckRange() ) nPC++;
    }
    Tools::Fill1D( Form("mul_BVC"), nBVC );
    Tools::Fill1D( Form("mul_CVC"), nCVC );
    Tools::Fill1D( Form("mul_PC"),  nPC );
    bool chargedhit = false;
    if( GRUN=="49c" ){
      if( nBVC ) chargedhit = true;
    }else if( GRUN=="65" ){
      if( nBVC || nCVC || nPC ) chargedhit = true;
    }


    //** find neighboring hits on CDH **//
    std::vector <int> nCDHseg;     // neutral hit candidates
    std::vector <int> CDHhit_list; // CDH hit container
    for( int n=0; n<cdsMan->nCDH(); n++ ){
      if( cdsMan->CDH(n)->CheckRange() && cdsMan->CDH(n)->ctmean()<TDC_CDH_MAX ){
        CDHhit_list.push_back( cdsMan->CDH(n)->seg() );
      }
    }
    std::sort(vCDHseg.begin(), vCDHseg.end());
    std::sort(CDHhit_list.begin(), CDHhit_list.end());
    std::set_difference( CDHhit_list.begin(), CDHhit_list.end(),
                         vCDHseg.begin(), vCDHseg.end(),
                         std::back_inserter(nCDHseg) );

    int nCDH_neighb = 0;
    for( int l=0; l<(int)nCDHseg.size(); l++ ){   // neutral hit candidates
      int flag_neighb = 0;
      for( int m=0; m<(int)vCDHseg.size(); m++ ){ // track associated hits
	if( abs(nCDHseg[l]-vCDHseg[m])==1 || abs(nCDHseg[l]-vCDHseg[m])==35 ) flag_neighb++;
      }
      if( flag_neighb ) nCDH_neighb++;
    }
    std::cerr<<"all   hits : ";
    for( int n=0; n<(int)CDHhit_list.size(); n++ ){
      std::cerr<<CDHhit_list[n]<<" ";
    } std::cerr<<std::endl;
    std::cerr<<"track hits : ";
    for( int n=0; n<(int)vCDHseg.size(); n++ ){
      std::cerr<<vCDHseg[n]<<" ";
    } std::cerr<<std::endl;
    std::cerr<<"diff  hits : ";
    for( int n=0; n<(int)nCDHseg.size(); n++ ){
      std::cerr<<nCDHseg[n]<<" ";
    } std::cerr<<std::endl;
    std::cerr<<" nCDH = "<<nCDH<<", nCDH_neighb = "<<nCDH_neighb<<std::endl;

    //** re-count CDH multiplicity **//
    int nCDHc = nCDH-nCDH_neighb;




    //** + + + + + + + + + + + **//
    //**  p p pi n_miss event  **//
    //** + + + + + + + + + + + **//

    //### Lp n_miss event study         
    if( flagbmom && p_ID.size()==2 && pim_ID.size()==1 &&
	cdstrackMan->nGoodTrack()==3 && !chargedhit ){

      nFill_pppi++;

      int npL = -1;
      double dca_ppi[2]  = {999,999}; // DCA(p1-pi)
      double dca_p[2]    = {999,999}; // DCA(baem-p2)
      double dca_Lp[2]   = {999,999}; // Distance of v(baem-p2)_on_p2 & v(beam-(p1+pi))_on_(p1+pi)
      double dca_L[2]    = {999,999}; // DCA(beam-(p1+pi))
      double dca_reac[2] = {999,999}; // Distance of v(beam-p2)_on_beam & v(beam-(p1+pi))_on_beam)
      double dis_Lct[2]  = {0,0};     // Distance of v(beam-(p1+pi))_on_(p1+pi) & v(p1-pi)_center
      bool RinFid[2]     = {false};
      bool Fid[2][3];
      TVector3 vtx_piL[2]; // Vertex(p1-pi)_on_pi
      TVector3 vtx_pL[2];  // Vertex(p1-pi)_on_p1
      TVector3 vtx_L[2];   // Vertex(beam-(p1+pi))_on_(p1+pi)
      TVector3 vtx_p[2];   // Vertex(baem-p2)_on_p2
      TVector3 vtxreac[2]; // Vertex(v(beam-p2)_on_beam-v(beam-(p1+pi))_on_beam))_center
      TLorentzVector L_pL;  // 4-Momentum(p_from_Lambda)
      TLorentzVector L_piL; // 4-Momentum(pi_from_Lambda)
      TLorentzVector L_p;   // 4-Momentum(p)
      TLorentzVector L_n;   // 4-Momentum(n)
      TLorentzVector L_L;   // 4-Momentum(Lambda)
      double pt_pL[2];   // pT(p1)
      double pt_piL[2];  // pT(pi)
      double pt_p[2];    // pT(p2)
      double im_ppi[2];  // IM(p+pi)
  
      //** DCA(p,pi) & vertex calculation **//
      for( int p1=0; p1<(int)p_ID.size(); p1++ ){
	for( int npi=0; npi<(int)pim_ID.size(); npi++ ){
	  int p2 = (p1==0)? 1 : 0;
	  CDSTrack *track_p1  = cdstrackMan->Track(p_ID[p1]);
	  CDSTrack *track_p2  = cdstrackMan->Track(p_ID[p2]);
	  CDSTrack *track_pim = cdstrackMan->Track(pim_ID[npi]);

	  TVector3 vtx_pi; // Vertex(p1-pi)_on_p1
	  TVector3 vtx_pd; // Vertex(p1-pi)_on_pi
	  TVector3 vtx;    // Vertex(p1-pi)_center

	  if( !TrackTools::Calc2HelixVertex( track_p1, track_pim, vtx_pd, vtx_pi ) ){
	    std::cerr<<" !!! failure in vertex calculation [Calc2HelixVertex()] !!! "<<std::endl;
	    continue;
	  }

	  vtx = (vtx_pd+vtx_pi)*0.5;
	  vtx_piL[p1] = vtx_pi;
	  vtx_pL[p1]  = vtx_pd;
	  dca_ppi[p1] = (vtx_pd-vtx_pi).Mag();

	  pt_pL[p1]  = track_p1->Pt();
	  pt_piL[p1] = track_pim->Pt();
	  pt_p[p1]   = track_p2->Pt();

	  TVector3 Pp_p1;  // Momentum(p1)
	  TVector3 Pp_pim; // Momentum(pi)
	  TVector3 Pp_ppi; // Momentum(p1+pi)
	  if( !track_p1->GetMomentum( vtx_pL[p1], Pp_p1, true, true ) ){
	    std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
	    continue;
	  }
	  if( !track_pim->GetMomentum( vtx_piL[p1], Pp_pim, true, true ) ){
	    std::cerr<<" !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
	    continue;
	  }
	  Pp_ppi = Pp_p1+Pp_pim;

	  TLorentzVector tL_p1; // 4-Momentum(p1)
	  TLorentzVector tL_pi; // 4-Momentum(pi)
	  tL_p1.SetVectM( Pp_p1, pMass );
	  tL_pi.SetVectM( Pp_pim, piMass );
	  im_ppi[p1] = (tL_p1+tL_pi).M();

	  TVector3 lp; // beam positon @ z=0
	  TVector3 ls; // beam direction
	  double x1, y1, x2, y2;
	  double z1 = 0, z2 = 20;
	  bpctrack->XYPosatZ( z1, x1, y1 );		  
	  bpctrack->XYPosatZ( z2, x2, y2 );
	  lp.SetXYZ( x1, y1, z1 );
	  ls.SetXYZ( x2-x1, y2-y1, z2-z1 );
	  ls = ls.Unit();
	      
	  double dist_L, dltmp = 0;
	  TVector3 vtx_Lt; // Vertex(beam-(p1+pi))_on_(p1+pi)
	  TVector3 nest;   // Vertex(beam-(p1+pi))_on_beam
	  MathTools::LineToLine( vtx, Pp_ppi.Unit(), lp, ls, dltmp, dist_L, vtx_Lt, nest );
	  dca_L[p1] = dist_L;
	  vtx_L[p1] = vtx_Lt;
	  dis_Lct[p1] = (vtx_Lt-vtx).Mag();
	      
	  TVector3 vtxb1; // Vertex(baem-p2)_on_beam
	  track_p2->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtxb1, vtx_p[p1] );
	  dca_p[p1]  = (vtx_p[p1]-vtxb1).Mag();
	  dca_Lp[p1] = (vtx_p[p1]-vtx_L[p1]).Mag();

	  vtxreac[p1]  = 0.5*((vtxb1)+(nest)); // reaction vertex on beam
	  dca_reac[p1] = (vtxb1-nest).Mag();

#if 0
	  if( GRUN=="49c" ){
	    if( GeomTools::GetID(vtxreac[p1])==CID_Fiducial ) RinFid[p1] = true;
	  }else if( GRUN=="65" ){
	    if( GeomTools::GetID(vtxb1)==CID_Fiducial && GeomTools::GetID(nest)==CID_Fiducial ) RinFid[p1] = true;
	  }
#else
	  Fid[p1][0] = GeomTools::GetID(vtxb1)==CID_Fiducial        ? true : false;
	  Fid[p1][1] = GeomTools::GetID(nest)==CID_Fiducial         ? true : false;
	  Fid[p1][2] = GeomTools::GetID(vtxreac[p1])==CID_Fiducial  ? true : false;
	  RinFid[p1] = Fid[p1][0]+Fid[p1][1]+Fid[p1][2];
#endif

	} // for( int npi=0; npi<(int)pim_ID.size(); npi++ ){
      } // for( int p1=0; p1<(int)p_ID.size(); p1++ ){


      //** likelihood calculation **//
      double probsum_sin[2]   = {99,99}; // integration of prob_L
      double probsum_imsin[2] = {99,99}; // (integration of prob_L)*prob_ML
      double woimlogprob[2]; // ln(probsum_sin)
      double logprob[2];     // ln(probsum_imsin)

      if( GRUN=="49c" ){
	double dca_sum[2]  = {999,999}; // dca_ppi[ip]+dca_L[ip]+dca_p[ip]+dca_reac[ip]
	double prob_L[2][5] = {}; // probabirity of topological vertex reconstruction
	double prob_ML[2]   = {}; // probabirity of IM(p,pi-)
	
	TF1 *f_imL = new TF1( "f_imL", "gaus(0)" );
	TF1 *f_dca = new TF1( "f_dca", "[0]*exp([1]*x)+[2]*exp([3]*(x-[4])**[5])" );
	double dcaparam_L_49c[5][6] = { //** parameters obtained with MC **// //!! sada-D p.106 !!//
	  //** from EventAnalysis_Lpn_sada.cpp **//
	  //#hx mcdca_ppi_Lpn (p_pi-)
	  {0.0111829,  -0.386551,  1.86103,  -1.65383,  -0.488821,  1.50069},
	  //#hx mcdca_qL_Lpn (Lambda_K-)
	  {1.38649,  -6.8509,  -31683.6,  -25.5,  -3.52,  21.9},
	  //#hx mcdca_p_Lpn (p_K-)
	  {1.43316,  -8.27214,  -31500.1,  -25.5,  -5.1463,  21.9},
	  //#hx mcdca_Lp_LpnLpn (Lambda_p)
	  {2.79166,  -2.44547,  -7.82249,  -6.82579,  -0.225766,  1.29841},
	  //#hx mcdca_sum_Lpn
	  {5.82406,  -1.5735,  -8.50142,  -0.542443,  -0.89754,  2.91009},
	};
	f_imL->SetParameters( 1, 1.1158, 0.0019 ); //** from EventAnalysis_Lpn_sada.cpp **//
	
	for(int ip=0;ip<2;ip++){
	  //** probabirity of IM(p,pi-) **//
	  prob_ML[ip] = f_imL->Eval(im_ppi[ip]);
	  
	  //** probabirity of topological vertex reconstruction **//
	  //dca_sum[ip] = dca_ppi[ip]+dca_L[ip]+dca_p[ip]+dca_Lp[ip];
	  dca_sum[ip] = dca_ppi[ip]+dca_L[ip]+dca_p[ip]+dca_reac[ip];
	  for( int id=0; id<5; id++ ){
	    f_dca->SetParameters( dcaparam_L_49c[id][0], dcaparam_L_49c[id][1], dcaparam_L_49c[id][2],
				  dcaparam_L_49c[id][3], dcaparam_L_49c[id][4], dcaparam_L_49c[id][5] );
	    double dcatmp = 0;
	    if( id==0 )      dcatmp = dca_ppi[ip];
	    else if( id==1 ) dcatmp = dca_L[ip];
	    else if( id==2 ) dcatmp = dca_p[ip];
	    //else if( id==3 ) dcatmp = dca_Lp[ip];
	    else if( id==3 ) dcatmp = dca_reac[ip];
	    else if( id==4 ) dcatmp = dca_sum[ip];
	    prob_L[ip][id] = f_dca->Eval(dcatmp);
	  }
	  
	  probsum_sin[ip] = 1;
	  int n_int = 4; 
	  for( int id=0; id<n_int; id++ ) probsum_sin[ip] *= prob_L[ip][id];
	  probsum_imsin[ip] = probsum_sin[ip]*prob_ML[ip];
	  
	  if( isnan( probsum_sin[ip] ) )   probsum_sin[ip]   = 0;
	  if( isnan( probsum_imsin[ip] ) ) probsum_imsin[ip] = 0;
	  
	  woimlogprob[ip] = (probsum_sin[ip]<1e-50)?   50-1 : -1*log10(probsum_sin[ip]);
	  logprob[ip]     = (probsum_imsin[ip]<1e-50)? 50-1 : -1*log10(probsum_imsin[ip]);
	} // for(int ip=0;ip<2;ip++){
      }else if( GRUN=="65" ){
	for(int ip=0;ip<2;ip++){
	  /* Input  : mass, dca_pip, dca_Lk, dca_pk, dcaLp */
	  /* Output : mass, dca_pip, dca_Lk, dca_pk, dcaLp */
	  double tmpper[5] = { im_ppi[ip], dca_ppi[ip], dca_L[ip], dca_p[ip], dca_reac[ip] };
	  double tmppdf[5] = {0,0,0,0,0};
	  TrackTools::PDFLambda(tmpper,tmppdf);
	  probsum_sin[ip] = 1;
	  int n_int = 3;  // Sada = 4, Yamaga = 3
	  for( int id=1; id<n_int+1; id++ ) probsum_sin[ip] *= tmppdf[id];
	  probsum_imsin[ip] = probsum_sin[ip]*tmppdf[0];
	  
	  if( isnan( probsum_sin[ip] ) )   probsum_sin[ip]   = 0;
	  if( isnan( probsum_imsin[ip] ) ) probsum_imsin[ip] = 0;
	  
	  // ln(x) = ln(10)*log10(x) ~ 2.303*log10(x)
	  woimlogprob[ip] = (probsum_sin[ip]<1e-50)?   50-1 : -1*log(probsum_sin[ip]);
	  logprob[ip]     = (probsum_imsin[ip]<1e-50)? 50-1 : -1*log(probsum_imsin[ip]);
	} // for(int ip=0;ip<2;ip++){
      }

      //** Lambda event selection **//
      npL = (probsum_imsin[0]>probsum_imsin[1])? 0 : 1;
      vtx_react = vtxreac[npL]; // reaction vertex on beam 
      
      //** fiducial volume selection **//
      bool flagfiducial = false;
      if( RinFid[npL] ){
	tlogprob1 = logprob[npL];
	tlogprob2 = logprob[1-npL];
	twoimprob1 = woimlogprob[npL];
	twoimprob2 = woimlogprob[1-npL];
	flagfiducial = true;
      }
      
      //** likelihood selection **//
      bool flagbprob = true;
      if( logprob[npL]>PARA_lnL_MAX ) flagbprob = false;
      


      //** L p n_missing reconstruction **//
      CDSTrack *track_pL  = cdstrackMan->Track(p_ID[npL]);   // p from Lambda
      CDSTrack *track_p   = cdstrackMan->Track(p_ID[1-npL]); // p
      CDSTrack *track_piL = cdstrackMan->Track(pim_ID[0]);   // pi- from Lambda

      TVector3 P_pL, P_piL, P_p;
      if( !track_pL->GetMomentum( vtx_pL[npL], P_pL, true, true ) ){
	std::cerr<<" !!! failure in momentum calculation of proton from L [GetMomentum()] !!! "<<std::endl;
      }
      if( !track_piL->GetMomentum( vtx_piL[npL], P_piL, true, true ) ){
	std::cerr<<" !!! failure in momentum calculation of pi- from L [GetMomentum()] !!! "<<std::endl;
      }
      if( !track_p->GetMomentum( vtx_p[npL], P_p, true, true ) ){
	std::cerr<<" !!! failure in momentum calculation of proton [GetMomentum()] !!! "<<std::endl;
      }
    
      L_pL.SetVectM(  P_pL,  pMass );
      L_piL.SetVectM( P_piL, piMass );
      L_p.SetVectM(   P_p,   pMass );
      L_L = L_pL+L_piL;

      //** energy loss correction of beam & reconstructoin of missing neutorn **//
      double beamtof, momout;
      double z_pos = -120;
      ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), vtx_react,
				     L3_beambf.Vect().Mag() , kpMass, momout, beamtof );
      //L3_beam.SetVectM( momout*L3_beambf.Vect().Unit(), kpMass ); // not need energy-loss correction [20180329]
      double mm_lp = (L3_target+L3_beam-L_pL-L_piL-L_p).M();
      TVector3 P_missn = (L3_target+L3_beam-L_pL-L_piL-L_p).Vect();
      L_n.SetVectM( P_missn, nMass );
      

      //** + + + + + + + + + + + + + **//
      //**  fill histograms & tree   **//
      //** + + + + + + + + + + + + + **//

      //** fill p p pi events **//
      Tools::Fill1D( Form("IM_p_pim"),  im_ppi[npL] );
      Tools::Fill1D( Form("DCA_p_pim"), dca_ppi[npL] );
      Tools::Fill1D( Form("DCA_L_Km"),  dca_L[npL] );
      Tools::Fill1D( Form("DCA_p_Km"),  dca_p[npL] );
      //Tools::Fill1D( Form("DCA_L_p"),   dca_Lp[npL] );
      Tools::Fill1D( Form("DCA_L_p"),   dca_reac[npL] );
      Tools::Fill1D( Form("lnL"),       logprob[npL] );
      Tools::Fill1D( Form("lnL_wrong"), logprob[1-npL] );
      Tools::Fill3D( Form("reaction_vertex"), vtx_react.X(), vtx_react.Y(), vtx_react.Z() );
      Tools::Fill1D( Form("IM_L_p"), (L_L+L_p).M() );
      Tools::Fill1D( Form("MM_L_p"), mm_lp );
      
      //** fill p p pi events in fiducial volume **//
      if( flagfiducial ){
	Tools::Fill1D( Form("IM_p_pim_f"),  im_ppi[npL] );
	Tools::Fill1D( Form("DCA_p_pim_f"), dca_ppi[npL] );
	Tools::Fill1D( Form("DCA_L_Km_f"),  dca_L[npL] );
	Tools::Fill1D( Form("DCA_p_Km_f"),  dca_p[npL] );
	//Tools::Fill1D( Form("DCA_L_p_f"),   dca_Lp[npL] );
	Tools::Fill1D( Form("DCA_L_p_f"),   dca_reac[npL] );
	Tools::Fill1D( Form("lnL_f"),       logprob[npL] );
	Tools::Fill1D( Form("lnL_wrong_f"), logprob[1-npL] );
	Tools::Fill3D( Form("reaction_vertex_f"), vtx_react.X(), vtx_react.Y(), vtx_react.Z() );
	Tools::Fill1D( Form("IM_L_p_f"), (L_L+L_p).M() );
	Tools::Fill1D( Form("MM_L_p_f"), mm_lp );
      }
      
      //** fill p L selected events **//
      if( flagbprob ){
	Tools::Fill1D( Form("IM_p_pim_pL"),  im_ppi[npL] );
	Tools::Fill1D( Form("DCA_p_pim_pL"), dca_ppi[npL] );
	Tools::Fill1D( Form("DCA_L_Km_pL"),  dca_L[npL] );
	Tools::Fill1D( Form("DCA_p_Km_pL"),  dca_p[npL] );
	//Tools::Fill1D( Form("DCA_L_p_pL"),   dca_Lp[npL] );
	Tools::Fill1D( Form("DCA_L_p_pL"),   dca_reac[npL] );
	Tools::Fill1D( Form("lnL_pL"),       logprob[npL] );
	Tools::Fill1D( Form("lnL_wrong_pL"), logprob[1-npL] );
	Tools::Fill3D( Form("reaction_vertex_pL"), vtx_react.X(), vtx_react.Y(), vtx_react.Z() );
	Tools::Fill1D( Form("IM_L_p_pL"), (L_L+L_p).M() );
	Tools::Fill1D( Form("MM_L_p_pL"), mm_lp );
	nFill_Lp++;
      }
      
      //** fill p L selected events in fiducial volume **//
      if( flagfiducial && flagbprob ){
	Tools::Fill1D( Form("IM_p_pim_pLf"),  im_ppi[npL] );
	Tools::Fill1D( Form("DCA_p_pim_pLf"), dca_ppi[npL] );
	Tools::Fill1D( Form("DCA_L_Km_pLf"),  dca_L[npL] );
	Tools::Fill1D( Form("DCA_p_Km_pLf"),  dca_p[npL] );
	//Tools::Fill1D( Form("DCA_L_p_pLf"),   dca_Lp[npL] );
	Tools::Fill1D( Form("DCA_L_p_pLf"),   dca_reac[npL] );
	Tools::Fill1D( Form("lnL_pLf"),       logprob[npL] );
	Tools::Fill1D( Form("lnL_wrong_pLf"), logprob[1-npL] );
	Tools::Fill3D( Form("reaction_vertex_pLf"), vtx_react.X(), vtx_react.Y(), vtx_react.Z() );
	Tools::Fill1D( Form("IM_L_p_pLf"), (L_L+L_p).M() );
	Tools::Fill1D( Form("MM_L_p_pLf"), mm_lp );
	nFill_Lpf++;
      }
      
      
      //** fill final sample **//
      if( flagfiducial && flagbprob && PARA_MM_LP_MIN<mm_lp && mm_lp<PARA_MM_LP_MAX ){
	//** fill L p n final sample **//
	Tools::Fill1D( Form("IM_p_pim_Lpn"),  im_ppi[npL] );
	Tools::Fill1D( Form("DCA_p_pim_Lpn"), dca_ppi[npL] );
	Tools::Fill1D( Form("DCA_L_Km_Lpn"),  dca_L[npL] );
	Tools::Fill1D( Form("DCA_p_Km_Lpn"),  dca_p[npL] );
	//Tools::Fill1D( Form("DCA_L_p_Lpn"),   dca_Lp[npL] );
	Tools::Fill1D( Form("DCA_L_p_Lpn"),   dca_reac[npL] );
	Tools::Fill1D( Form("lnL_Lpn"),       logprob[npL] );
	Tools::Fill1D( Form("lnL_wrong_Lpn"), logprob[1-npL] );
	Tools::Fill3D( Form("reaction_vertex_Lpn"), vtx_react.X(), vtx_react.Y(), vtx_react.Z() );
	Tools::Fill1D( Form("IM_L_p_Lpn"), (L_L+L_p).M() );
	Tools::Fill1D( Form("MM_L_p_Lpn"), mm_lp );
	
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	// %%% Kinematical Fit using KinFitter %%% //
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	//--- set TLorentzVector ---//
	// beam_K(K+), L, n, p, p from L, pi- from L
	//  = TLorentzVector L3_beam, L_Llab, L_nlab, L_plab, L_pL, L_piL
	TLorentzVector TL_meas[6]; // measured
	TLorentzVector TL_kfit[6]; // kinematical fitted
	TL_meas[0] = L3_beam;
	TL_meas[1] = L_L; //L_Llab;
	TL_meas[2] = L_n; //L_nlab;
	TL_meas[3] = L_p;  // * which p?
	TL_meas[4] = L_pL; // * which p?
	TL_meas[5] = L_piL;
	// L3_target is defined as (0, 0, 0, M_3He)
	TVector3 TV_target = L3_target.Vect();
	TVector3 TV_meas[6];
	for( int i=0; i<6; i++ ){
	  TV_meas[i] = TL_meas[i].Vect();
	}

#if 1
	//--- for the covariance matrix evaluation ---//
	for( int i=0; i<6; i++ ){
	  for( int j=0; j<4; j++ ){
	    double val = (TL_meas[i][j] - TL_gene[i][j]);
	    Tools::Fill1D(Form("cov_%d_%d_%d", i, j, j), val);
	  }
	} // for( int i=0; i<6; i++ ){
#endif
	
	//--- KinFitter :: initialization ---//
	//*** definition of fit particles in cartesian coordinates ***//
	TString str_particle[6] = {"L_beam", "L_Lam", "L_n", "L_p", "L_pL", "L_piL"};
	TFitParticlePxPyPz ParticleTgt = TFitParticlePxPyPz("target", "target", &TV_target,
							    pdg->GetParticle("He3")->Mass(), covZero);
	TFitParticlePxPyPz Particle[6];
	for( int i=0; i<6; i++ ){
	  Particle[i] = TFitParticlePxPyPz(str_particle[i], str_particle[i], &TV_meas[i],
					   pdg->GetParticle(PDG[i])->Mass(), covParticle[i]);
	}
	//*** definition of constraints ***//
	// constraint :: mass of Lambda
	TFitConstraintM ConstML = TFitConstraintM("M_L", "M_L", 0, 0, pdg->GetParticle(PDG[1])->Mass());
	ConstML.addParticles1(&Particle[4], &Particle[5]);
	// constraint :: 4-momentum conservation
	TFitConstraintEp ConstEp[4];
	TString str_constEp[4]  = {"Px", "Py", "Pz", "E"};
	for( int i=0; i<4; i++ ){
	  ConstEp[i] = TFitConstraintEp(str_constEp[i], str_constEp[i], 0, TFitConstraintEp::component(i), 0);
	  ConstEp[i].addParticles1(&ParticleTgt, &Particle[0]);
	  ConstEp[i].addParticles2(&Particle[2], &Particle[3], &Particle[4], &Particle[5]);
	}
	
	//--- KinFitter :: execution ---//
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// Naively,
	//  measured values are momenta (3-vectors) of K-, p, p, pi- -> 3*4=12 
	//  constraints for kinematical fit are masses of lambda and missing-neutron -> 1*2=2
	//    where energy and momentum of missing-neutron is obtained from 4-momentum conservation of K- 3He -> L p n
	//   => number of parameters is 12-2=10
	//   => DOF is 12-10=2
	//
	// In the kinematical fit routine, KinFitter,
	//  fitting values are momenta (3-vectors) of K-, p, p, pi-, n -> 3*5=15
	//    where mass of neutron is fixed to the PDG value
	//  constraints for kinematical fit are mass of lambda and 4-momentum conservation -> 1+4=5
	//   => number of parameters is 15-5=10
	//  measured values are momenta (3-vectors) of K-, p, p, pi- -> 3*4=12 
	//   => DOF is 12-10=2
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	//*** definition of the fitter ***//
	TKinFitter kinfitter;
	// add measured particles
	kinfitter.addMeasParticles(&Particle[0], &Particle[3], &Particle[4], &Particle[5]); // K, p, p, pi-
	kinfitter.addUnmeasParticles(&Particle[2]); // n
	// add constraints
	kinfitter.addConstraint(&ConstML); // mass of Lambda
	for( int i=0; i<4; i++ ){
	  kinfitter.addConstraint(&ConstEp[i]); // 4-momentum conservation
	}
	//*** perform the fit ***//
	kinfitter.setMaxNbIter(50);       // max number of iterations
	kinfitter.setMaxDeltaS(5e-5);     // max delta chi2
	kinfitter.setMaxF(1e-4);          // max sum of constraints
	kinfitter.setVerbosity(KFDEBUG);  // verbosity level
	kinfitter.fit();
	//*** copy fit results ***//
	for( int i=0; i<6; i++ ){
	  TL_kfit[i] = (*Particle[i].getCurr4Vec());
	}
	TL_kfit[1] = TL_kfit[4]+TL_kfit[5];
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	// %%% Kinematical Fit using KinFitter %%% //
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
	// beam_K(K+), L, n, p, p from L, pi- from L 
	//  = TLorentzVector L3_beam, L_Llab, L_nlab, L_plab, L_pL, L_piL 

	//** fill tree **//
	mom_beam   = L3_beam;   // 4-momentum(beam)
	mom_target = L3_target; // 4-momentum(target)
	mom_L = L_L;            // 4-momentum(Lambda)
	mom_p = L_p;            // 4-momentum(proton)
	mom_n = L_n;            // 4-momentum(neutron)
	mom_p_L  = L_pL;        // 4-momentum(p from L)
	mom_pi_L = L_piL;       // 4-momentum(pi- from L)
	vtx_reaction = vtx_react; // vertex(reaction)
	vtx_Ldecay   = (vtx_pL[npL]+vtx_piL[npL])*0.5; // vertex(Lambda decay)
	run_num   = confMan->GetRunNumber(); // run number (temp)
	event_num = ev;                      // event number
	block_num = 0;                       // block number (temp)
	kfmom_beam = TL_kfit[0];  // 4-momentum(beam) after kinematical refit
	kfmom_L = TL_kfit[1];     // 4-momentum(Lambda) after kinematical refit
	kfmom_p = TL_kfit[3];     // 4-momentum(proton) after kinematical refit
	kfmom_n = TL_kfit[2];     // 4-momentum(neutron) after kinematical refit
	kfmom_p_L  = TL_kfit[4];  // 4-momentum(p from L) after kinematical refit
	kfmom_pi_L = TL_kfit[5];  // 4-momentum(pi- from L) after kinematical refit
	kf_chi2   = kinfitter.getS();
	kf_NDF    = kinfitter.getNDF();
	kf_status = kinfitter.getStatus();
	kf_pvalue = ROOT::Math::chisquared_cdf_c(kinfitter.getS(), kinfitter.getNDF());
	lnL = logprob[npL];
	mul_CDH  = nCDH;
	mul_CDHc = nCDHc;
	for(int n=0; n<3; n++) fiducial[n] = Fid[npL][n];

	mcmom_beam = TL_gene[0];
	mcmom_L    = TL_gene[1];
	mcmom_p    = TL_gene[3];
	mcmom_n    = TL_gene[2];
	mcmom_p_L  = TL_gene[4];
	mcmom_pi_L = TL_gene[5];

	std::cout<<"%%% Lpn event: Event_Number, Block_Event_Number, CDC_Event_Number = "
		 <<ev<<" , "<<" -- , "<<ev_cdc
		 <<"| lnL = "<<logprob[npL]<<std::endl;

	std::cerr<<" MOM = " <<mom_pi_L.P()<<" , "<<mom_p_L.P()<<" , "<<mom_p.P()<<std::endl;
	std::cerr<<" PDF = " <<logprob[npL]<<" , "<<logprob[1-npL]<<std::endl;

	outfile2->cd();
	lpnTree->Fill();
	outfile->cd();
	nFill_Lpn++;

      } // if( flagfiducial && flagbprob && PARA_MM_LP_MIN<mm_lp && mm_lp<PARA_MM_LP_MAX ){
    } // if( flagbmom && p_ID.size()==2 && pim_ID.size()==1 && trackMan->nGoodTrack()==3 && !chargedhit ){
    else{
      nAbort_pppi++;
    }

    nAbort_end++;
    delete detData2;
    
  } // for( int ev=0; ev<exen; ev++ ){
  
  cout<<"===== Lambda p n reconstruction in MC END ====="<<endl;
  cout<<" nEvent       = "<<exen<<endl;
  cout<<" nEvent_Lp    = "<<nEvent_Lp<<endl;
  cout<<" nEvent_Lpn   = "<<nEvent_Lpn<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nG4Event_Lp  = "<<nG4Event_Lp<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" AllGoodTrack = "<<AllGoodTrack<<endl;
  cout<<" nTrack       = "<<nTrack<<endl;
  cout<<" nTrack_PID   = "<<nTrack_PID<<endl;
  cout<<"***********************************************"<<endl;
  cout<<" nAbort_nGoodTrack  = "<<nAbort_nGoodTrack<<endl;
  cout<<" nAbort_nCDH        = "<<nAbort_nCDH<<endl;
  cout<<" nAbort_nT0         = "<<nAbort_nT0<<endl;
  cout<<" nAbort_nbpc        = "<<nAbort_nbpc<<endl;
  cout<<" nAbort_bpctrack    = "<<nAbort_bpctrack<<endl;
  cout<<" nAbort_nblc2       = "<<nAbort_nblc2<<endl;
  cout<<" nAbort_fblc2bpc    = "<<nAbort_fblc2bpc<<endl;
  cout<<" nAbort_flagbmom    = "<<nAbort_flagbmom<<endl;
  cout<<" nAbort_ftarget     = "<<nAbort_ftarget<<endl;
  cout<<" nAbort_nAbort_pppi = "<<nAbort_pppi<<std::endl;
  cout<<" nAbort_end         = "<<nAbort_end<<std::endl;
  cout<<"***********************************************"<<endl;
  cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<endl;
  cout<<"*** # of p p pi / L p / L p (fiducial) / L p n events = "
      <<nFill_pppi<<" / "<<nFill_Lp<<" / "<<nFill_Lpf<<" / "<<nFill_Lpn<<" ***"<<std::endl;
  cout<<"==============================================="<<endl;

  outfile->Write();
  outfile->Close();

  outfile2->Write();
  outfile2->Close();

  simfile->Close();
  cdcfile->Close();

  delete pdg;
  delete covZero;
  for( int i=0; i<6; i++ ) delete covParticle[i];

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}
