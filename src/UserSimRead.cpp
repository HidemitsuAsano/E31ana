//----------------------------------------------------------------//
// ===== UserSimRead.cpp =====
// sample program to reconstruct pi+ pi- event
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
//----------------------------------------------------------------//
//  exe-file: simread [./simread $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file & G4(knucl4.10)-file &
//          CDC-tracking-file
//           <- including class EventHeader and CDSTrackingMan
//  output: root-file
//           <- including TH1F "CDS_IM_pipi"
//                        TH2F "CDS_PID", "CDS_PID_pi"
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//
//  updated by F.S, 2016 12/28
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"
#include "TrackTools.h"
#include "EventHeader.h"

using namespace std;

static const double CDC_MAX_CHI=30;

int main( int argc, char** argv )
{
  if( argc!=5 ){
    cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<endl;
    return 0;
  }

  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();

  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);
  if( tree2->GetEntries()==1 ) cout<<"  !!! tree2 entries==1 !!!"<<endl;
  else tree2->GetEntry(0);

  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
  EventHeader      *header = new EventHeader();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineTrackMan *bltrackMan   = new BeamLineTrackMan();
  CDSTrackingMan    *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("EventHeader", &header);
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  if( evTree->GetEntries()!=tree->GetEntries() ){
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    return 0;
  }

  TFile *outfile = new TFile(argv[2], "recreate");
  outfile->cd();
  new TH1F("CDS_IM_pipi", "CDS IM #pi^{+} #pi^{-}", 200, 0.4, 0.6);
  new TH2F("CDS_PID",     "CDS PID",     100, -0.5, 2.0, 100, -1.5, 1.5);
  new TH2F("CDS_PID_pi",  "CDS PID #pi", 100, -0.5, 2.0, 100, -1.5, 1.5);

  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  cout<<"===== pi+ pi- reconstruction in MC START ======================"<<endl;
  cout<<"     # of All  Event in EventTree:     "<<eventn<<endl;
  cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<endl;
  cout<<"     # of Exe  Event in this program:  "<<exen<<endl;
  cout<<"========================================================="<<endl;

  for( int ev=0; ev<exen; ev++ ){
    if( ev%100==0 ) std::cout<<"> Event Number "<<ev<<std::endl;

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree-> GetEntry(ev);
    evTree-> GetEntry(ev);
    simMan-> Convert(detData, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);  
    bltrackMan-> DoTracking(blMan, confMan, true, true);

    int nT0=0;
    HodoscopeLikeHit *T0hit=0;
    for( int i=0; i<blMan->nT0(); i++ ){
      if( blMan->T0(i)->CheckRange() ){
	T0hit=blMan->T0(i);
	nT0++;
      }
    }

    //cout<<"===== Event Number : "<<ev<<endl;
    //cout<<"> nT0       : "<<nT0<<endl;
    //cout<<"> ntrackBPC : "<<bltrackMan->ntrackBPC()<<endl;
    //cout<<"> nGoodTrack: "<<cdstrackMan->nGoodTrack()<<endl;

    if( cdstrackMan->nGoodTrack()<1 || nT0!=1 || bltrackMan->ntrackBPC()!=1 ) continue;
    
    LocalTrack *trackBPC=bltrackMan->trackBPC(0);
    int n_pim = 0;
    int n_pip = 0;
    CDSTrack *pimTrack = 0;
    CDSTrack *pipTrack = 0;

    for( int i=0; i<cdstrackMan->nGoodTrack(); i++ ){
      CDSTrack *track = cdstrackMan->GoodTrack(i);
      if( track->Chi()>CDC_MAX_CHI ) continue;
      if( !track->CDHFlag() ) continue;
      int CDHseg;
      double CDHtime;
      track->GetCDHHit(cdsMan, CDHseg, CDHtime);

      TVector3 vtxBeam, vtxCDS;
      if( !track->GetVertex(trackBPC->GetPosatZ(110+0.5), trackBPC->GetMomDir(),
			    vtxBeam, vtxCDS) ) continue;
      double beam_out, beam_tof;
      // Please change 1.0-> Kaon Beam momentum,
      ELossTools::CalcElossBeamTGeo(trackBPC->GetPosatZ(110+0.5), vtxBeam, 1.0,
				    kpMass, beam_out, beam_tof);

      double mom = track->Momentum();
      TVector3 vtxCDH = track->CDHVertex();
      double par[5];
      track-> GetParameters(par);
      double tof = CDHtime-T0hit->ctmean();
      double cdc_dis = MathTools::CalcHelixArc(par, vtxCDH, vtxCDS);
      double beta = cdc_dis/(tof-beam_tof)/(100.*Const);
      double mass2 = mom*mom*(1./(beta*beta)-1);
      double tofvtxcdc;

      //input : CDSTrack* LocalTrack* tof beam_mom Beam_PID  return beta mass2 vtx-cdc_tof
      if( !TrackTools::FindMass2(track, trackBPC, tof, 1.0, Beam_Kaon,
				 beta, mass2, tofvtxcdc) ) continue;

      // CDC Fine tuning these mothod adopt only data analysis
      //      track->Retiming(cdsMan, confMan, calc_beta, true);
      //      track->Calc(confMan);
      //      if( !TrackTools::FindMass2(track, beam->BOBPC(bltrackMan), tof, beam->D5mom(), beam->pid(), calc_beta, mass2, tofvtxcdc) ) continue;

      int pid=confMan->GetCDSFittingParamManager()->PID(mom, mass2);
      //cout<<"mom = "<<mom<<", mass2 ="<<mass2<<" , PID = "<<pid<<endl;

      TH2F *h21 = (TH2F*)outfile->Get("CDS_PID");
      TH2F *h22 = (TH2F*)outfile->Get("CDS_PID_pi");
      h21->Fill(mass2, mom);
      if( pid==CDS_PiMinus || pid==CDS_PiPlus ) h22->Fill(mass2, mom);

      double tmpfl;
      // Add Eloss parameters
      track-> CalcVertexTimeLength(trackBPC->GetPosatZ(110+0.5), trackBPC->GetMomDir(),
				   cdsMass[pid], vtxBeam, vtxCDS, tof, tmpfl, true);

      if( pid==CDS_PiMinus ){
	n_pim++;
	pimTrack = track;
      }
      if( pid==CDS_PiPlus ){
	n_pip++;
	pipTrack = track;
      }
    } // for( int i=0; i<cdstrackMan->nGoodTrack(); i++ ){

    // cout<<"===== Event Number : "<<ev<<" ====="<<endl;
    // cout<<"> n pi- : "<<n_pim<<endl;
    // cout<<"> n pi+ : "<<n_pip<<endl;

    if(  n_pim==1 && n_pip==1 ){
      TVector3 vtx_pim, vtx_pip;
      if( !TrackTools::Calc2HelixVertex(pimTrack, pipTrack, vtx_pim, vtx_pip) ) continue;
      TVector3 p_pim, p_pip;
      if( !pimTrack->GetMomentum(vtx_pim, p_pim, true, true) ) continue;
      if( !pipTrack->GetMomentum(vtx_pip, p_pip, true, true) ) continue;

      TLorentzVector pim_lmom, pip_lmom;
      pim_lmom.SetVectM(p_pim, piMass);
      pip_lmom.SetVectM(p_pip, piMass);

      //cout<<"CDS pi+ pi- IM : "<<ev<<" , "<<(pim_lmom+pip_lmom).M()<<" [GeV/c2]"<<endl;
      TH1F *h1 = (TH1F*)outfile->Get("CDS_IM_pipi");
      h1-> Fill((pim_lmom+pip_lmom).M());
    }

  } // for( int ev=0; ev<exen; ev++ ){
  
  cout<<"===== pi+ pi- reconstruction in MC END ====="<<endl;
  cout<<"   TH1F: CDS_IM_pipi"<<endl;
  cout<<"   TH2F: CDS_PID, CDS_PID_pi"<<endl;
  cout<<" are created"<<endl;
  cout<<"======================================"<<endl;

  outfile->Write();
  outfile->Close();

  simfile->Close();
  cdcfile->Close();

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;

}
