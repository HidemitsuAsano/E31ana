//----------------------------------------------------------------//
// H.Asano Aug.8th, 2018
// UserSimIMLPim.cpp
// originated from UserSimpipipnn.cpp
//
// the purpose is to reconstruct pi S n event in d(K^-,n) reaction
// from simulation data and CDC-tracking file generated by "UserSimDatG4.cpp (exe-file = sim)"
// *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// reconstruction method is based on "EventAnalysis_pipipnn_sakuma.cpp"
//----------------------------------------------------------------//
//  exe-file: simIMpisigma [./simIMpisigma $(ConfFile) $(OutFile) $(InFile) $(CDCtrackingFile)]
//  input : conf-file, G4(knucl4.10)-file, CDC-tracking-file
//  output: when $(OutFile) is "tmp.root", the following 2 files are generated.
//     "tmp.root":      histogram file
//     "tmp_pipipnn.root": basic information of pippimn event is listed up in TTree
//  *NOTE*: the same conf-file used to generate G4-file is needed
//----------------------------------------------------------------//

#include "KnuclRootData.h"
#include "ConfMan.h"
#include "SimDataMan.h"
#include "BeamLineTrackMan.h"
#include "CDSTrackingMan.h"

#include <TLorentzVector.h>
#include "TrackTools.h"
#include "EventHeader.h"
#include "Tools.h"
#include "ELossTools.h"

#include "IMPiSigmaAnaPar.h"
#include "IMPiSigmaHist.h"
#include "IMPiSigmaUtil.h"

#include <TDatabasePDG.h>
#include <KinFitter/TKinFitter.h>
#include <KinFitter/TFitParticlePxPyPz.h>
#include <KinFitter/TFitConstraintM.h>
#include <KinFitter/TFitConstraintEp.h>
#include <Math/ProbFuncMathCore.h>



#define KFDEBUG 0 // verbose level of the KinFitter
// 0: quiet, 1: print result, 2: print iterations, 3: print also matrices
int Verbosity_ = 0;
const bool DoCDCRetiming = false;
// momentum resolution of the beam-line spectrometer
// was evaluated to be 2.0 +/- 0.5 MeV/c (Hashimoto-D p.58)
const double MOM_RES = 2.0; // (MeV/c)
const bool IsVtxDoubleCheck = false;
const bool UseDecayVtx = true;
const bool UseRealBeamMom = true;

//** cut parameters **//
double PARA_blc2bpc_dx_MIN;
double PARA_blc2bpc_dx_MAX;
double PARA_blc2bpc_dy_MIN;
double PARA_blc2bpc_dy_MAX;
double PARA_blc2bpc_dxdz_MIN;
double PARA_blc2bpc_dxdz_MAX;
double PARA_blc2bpc_dydz_MIN;
double PARA_blc2bpc_dydz_MAX;
double PARA_lnL_MAX;
double PARA_MM_LP_MIN;
double PARA_MM_LP_MAX;

const double ADC_CDH_MIN = 1;  // MeV

//= = = = pippimn final-sample tree = = = =//
TLorentzVector mom_beam;   // 4-momentum(beam)
TLorentzVector mom_target; // 4-momentum(target)
TLorentzVector mom_pim1;    // 4-momentum(pi-)
TLorentzVector mom_pim2;    // 4-momentum(pi-)
TLorentzVector mom_p;      // 4-momentum(proton)
TLorentzVector mom_p2;     // 4-momentum(proton),if detected
TLorentzVector react_pmiss; //mc info.
TLorentzVector react_Lambda;//mc info.
TLorentzVector react_pim; //mc info.
TVector3 vtx_reaction; //  vertex(reaction)
TVector3 vtx_displaced;
TVector3 vtx_pim1_beam; //
TVector3 vtx_pim2_beam; //
TVector3 vtx_p_beam; //
TVector3 vtx_p2_beam; //
TVector3 vtx_pim1_cdc;
TVector3 vtx_pim2_cdc;
TVector3 vtx_p_cdc;
TVector3 vtx_p2_cdc;
TVector3 CA_pim1_pim1p;
TVector3 CA_p_pim1p;
TVector3 CA_p2_pim1p2;
TVector3 CA_pim1_pim1p2;
TVector3 CA_pim2_pim2p;
TVector3 CA_p_pim2p;
TVector3 CA_p2_pim2p2;
TVector3 CA_pim2_pim2p2;
TVector3 CA_pim1_pim1pim2;
TVector3 CA_pim2_pim1pim2;
int ForwardCharge;
int run_num;   // run number
int event_num; // event number
int block_num; // block number
int mc_nparticle;
TLorentzVector mcmom_beam;   // generated 4-momentum(beam)
TLorentzVector mcmom_pim1;    // generated 4-momentum(pi+)
TLorentzVector mcmom_pim2;    // generated 4-momentum(pi-)
TLorentzVector mcmom_p;      // generated 4-momentum(neutron)
TLorentzVector mcmom_pmiss;      // generated 4-momentum(neutron)
TVector3 mc_vtx;
TVector3 mc_disvtx;
TLorentzVector kfMomBeamSpmode;   // 4-momentum(beam) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_pip_Spmode;    // 4-momentum(pi+) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_pim_Spmode;    // 4-momentum(pi-) after kinematical refit for pi- Sigma+
TLorentzVector kfMom_n_Spmode;      // 4-momentum(neutron) after kinematical refit for pi- Sigma+
double kf_chi2_Spmode;   // chi2 of kinematical refit
double kf_NDF_Spmode;    // NDF of kinematical refit
double kf_status_Spmode; // status of kinematical refit -> details can be found in this code
double kf_pvalue_Spmode; // p-value of kinematical refit
int kf_flag; // flag of correct pair reconstruction, etc
//= = = = pimpimn final-sample tree = = = =//


void InitializeHistogram();
void InitTreeVal();

int main( int argc, char** argv )
{
  if( argc!=5 ) {
    std::cout<<argv[0]<<" $(ConfFile) $(OutFile) $(KnuclFile) $(CDCtrackingFile)"<<std::endl;
    return 0;
  }


  std::cout <<"L." << __LINE__ << " MOM_RES beam line: " << MOM_RES << std::endl;
  std::cout <<"L." << __LINE__ << " TDC_CDH_MAX: " << cdscuts_lpim::tdc_cdh_max+cdscuts_lpim::tdc_simoffset << std::endl;
  std::cout << " Double Check VTX fid cut ? " ;
  if(IsVtxDoubleCheck) std::cout << " Yes" << std::endl;
  else         std::cout << " No"  << std::endl;

  std::cout << "Isolation cut range ? " ;

  TDatabasePDG *pdg = new TDatabasePDG();
  pdg->ReadPDGTable("pdg_table.txt");
  //pdg->Print();
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//
  // ### obtained from (p_meas[j]-p_gene[j])
  // ###  using G4-data with TH1F(Form("cov_%d_%d_%d", i, j, j), 100, -cov_MAX, cov_MAX);
  // ###  and evaluated using "Air" Dora MC
  // 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+

  std::cout << "L." << __LINE__ << " cov. matrix for S+ mode" << std::endl;
  for(int ip=0; ip<kinpLpim::npart; ip++) {
    for(int im=0; im<16; im++) {
      std::cout << kinpLpim::covValpLpim[ip][im] << " ";
      if(im==3 || im==7 || im==11 || im==15) {
        std::cout << std::endl;
      }
    }
    std::cout << std::endl;
  }

  TMatrixD *covZero = new TMatrixD(4, 4);
  covZero->Zero();
  covZero->ResizeTo(3, 3); // resize from 4x4 to 3x3
  TMatrixD *covParticlepLpim[kinpLpim::npart];
  for( int ip=0; ip<kinpLpim::npart; ip++ ) {
    covParticlepLpim[ip] = new TMatrixD(4, 4);
    int n = 0;
    for( int j=0; j<4; j++ ) {
      for( int k=0; k<4; k++ ) {
        if( j==k ) {
          (*covParticlepLpim[ip])[j][k] = kinpLpim::covValpLpim[ip][n]; // only diagonal elements
        } else {
          (*covParticlepLpim[ip])[j][k] = 0;
        }
        n++;
      }//k
    }//j
    covParticlepLpim[ip]->ResizeTo(3, 3); // resize from 4x4 to 3x3
    covParticlepLpim[ip]->Print(); // Print all
  }
  //-----------------------------------------//
  //--- covariance matrices for KinFitter ---//
  //-----------------------------------------//


  //** Conf file open **//
  ConfMan *confMan = new ConfMan(argv[1]);
  confMan->Initialize();
  
  //realistic beam momentum file
  TFile *bMomfile = new TFile("/gpfs/home/had/hiasano/ana/k18ana/post/fbeam_lpim.root","READ");
  TH1D* realBeamMom = NULL ;
  if(UseRealBeamMom && bMomfile->IsOpen()){
    realBeamMom = (TH1D*)bMomfile->Get("BeamMom");    
  }else if(UseRealBeamMom && !bMomfile->IsOpen()){
    std::cout << "L." << __LINE__ << " FILE not opened: " << bMomfile->GetName() << std::endl;
    return false;
  }

  //** Simulation file open **//
  SimDataMan *simMan = new SimDataMan();
  TFile *simfile = new TFile(argv[3]);
  TTree *tree2 = (TTree*)simfile->Get("tree2");
  RunHeaderMC *runHeader=0;
  tree2->SetBranchAddress("RunHeaderMC", &runHeader);
   
  TTree *tree=(TTree*)simfile->Get("tree");
  EventHeaderMC *evHeaderMC = new EventHeaderMC();
  DetectorData  *detData  = new DetectorData();
  ReactionData  *reacData = new ReactionData();
  MCData        *mcData   = new MCData();
  tree->SetBranchAddress("EventHeaderMC", &evHeaderMC);
  tree->SetBranchAddress("DetectorData", &detData);
  tree->SetBranchAddress("ReactionData", &reacData);
  tree->SetBranchAddress("MCData", &mcData);

  //** Getting CDSTracking info. from CDCfile **//
  TFile *cdcfile = new TFile(argv[4]);
  TTree *evTree  = (TTree*)cdcfile->Get("EventTree");
  EventHeader      *header = new EventHeader();
  evTree->SetBranchAddress("EventHeader", &header );
  CDSHitMan        *cdsMan = new CDSHitMan();
  BeamLineHitMan   *blMan  = new BeamLineHitMan();
  BeamLineTrackMan *bltrackMan  = new BeamLineTrackMan();
  CDSTrackingMan   *cdstrackMan = new CDSTrackingMan();
  evTree->SetBranchAddress("CDSTrackingMan", &cdstrackMan);

  //** output file 1 : histograms **//
  TFile *outfile = new TFile(argv[2], "recreate");
  //outfile->cd();
  //check seed distribution
  if( tree2->GetEntries()==1 ) {
    std::cout<<"  !!! tree2 entries==1 !!!"<<std::endl;
    tree2->GetEntry(0);
    std::cout << runHeader->seed() << std::endl;
    Tools::H1("Seed",runHeader->seed(),10000,0,10000);
  }

  //** output file 2 : ppimpim final-sample tree **//
  std::string outfile2_name = string(argv[2]);
  outfile2_name.insert( outfile2_name.size()-5, "_ppimpim" );
  std::cout<<"ppimpim file "<<outfile2_name<<std::endl;
  TFile *outfile2 = new TFile( outfile2_name.c_str(), "recreate" );
  outfile2->cd();
  TTree *ppimpimTree = new TTree( "EventTree", "EventTree" );
  ppimpimTree->Branch( "mom_beam",   &mom_beam );//
  ppimpimTree->Branch( "mom_target", &mom_target );
  ppimpimTree->Branch( "mom_pim1", &mom_pim1 );
  ppimpimTree->Branch( "mom_pim2", &mom_pim2 );
  ppimpimTree->Branch( "mom_p", &mom_p );
  ppimpimTree->Branch( "mom_p2", &mom_p2 );
  ppimpimTree->Branch( "vtx_reaction", &vtx_reaction );
  ppimpimTree->Branch( "vtx_displaced", &vtx_displaced );
  ppimpimTree->Branch( "vtx_pim1_beam", &vtx_pim1_beam );
  ppimpimTree->Branch( "vtx_pim2_beam", &vtx_pim2_beam );
  ppimpimTree->Branch( "vtx_p_beam", &vtx_p_beam );
  ppimpimTree->Branch( "vtx_p2_beam", &vtx_p2_beam );
  ppimpimTree->Branch( "vtx_pim1_cdc", &vtx_pim1_cdc );
  ppimpimTree->Branch( "vtx_pim2_cdc", &vtx_pim2_cdc );
  ppimpimTree->Branch( "vtx_p_cdc", &vtx_p_cdc );
  ppimpimTree->Branch( "vtx_p2_cdc", &vtx_p2_cdc );
  ppimpimTree->Branch( "CA_pim1_pim1p",&CA_pim1_pim1p);
  ppimpimTree->Branch( "CA_p_pim1p",&CA_p_pim1p);
  ppimpimTree->Branch( "CA_pim1_pim1p2",&CA_pim1_pim1p2);
  ppimpimTree->Branch( "CA_p2_pim1p2",&CA_p2_pim1p2);
  ppimpimTree->Branch( "CA_pim2_pim2p",&CA_pim2_pim2p);
  ppimpimTree->Branch( "CA_p_pim2p",&CA_p_pim2p);
  ppimpimTree->Branch( "CA_pim2_pim2p2",&CA_pim2_pim2p2);
  ppimpimTree->Branch( "CA_p2_pim2p2",&CA_p2_pim2p2);
  ppimpimTree->Branch( "CA_pim1_pim1pim2",&CA_pim1_pim1pim2);
  ppimpimTree->Branch( "CA_pim2_pim1pim2",&CA_pim2_pim1pim2);
  ppimpimTree->Branch( "ForwardCharge", &ForwardCharge);  
  //ppimpimTree->Branch( "run_num", &run_num );
  //ppimpimTree->Branch( "event_num", &event_num );
  //ppimpimTree->Branch( "block_num", &block_num );
  ppimpimTree->Branch( "mc_nparticle",   &mc_nparticle );
  ppimpimTree->Branch( "mcmom_beam",   &mcmom_beam );
  ppimpimTree->Branch( "mcmom_pim1", &mcmom_pim1 );
  ppimpimTree->Branch( "mcmom_pim2", &mcmom_pim2 );
  ppimpimTree->Branch( "mcmom_p", &mcmom_p );
  ppimpimTree->Branch( "mcmom_pmiss", &mcmom_pmiss );
  ppimpimTree->Branch( "react_pmiss",&react_pmiss);
  ppimpimTree->Branch( "react_Lambda",&react_Lambda);
  ppimpimTree->Branch( "react_pim",&react_pim);
  ppimpimTree->Branch( "mc_vtx", &mc_vtx );
  ppimpimTree->Branch( "mc_disvtx", &mc_disvtx );
  //ppimpimTree->Branch( "kfSpmode_mom_beam",   &kfMomBeamSpmode );
  //ppimpimTree->Branch( "kfSpmode_mom_pip", &kfMom_pip_Spmode );
  //ppimpimTree->Branch( "kfSpmode_mom_pim", &kfMom_pim_Spmode );
  //ppimpimTree->Branch( "kfSpmode_mom_n", &kfMom_n_Spmode );
  //ppimpimTree->Branch( "kfSpmode_chi2", &kf_chi2_Spmode );
  //ppimpimTree->Branch( "kfSpmode_NDF", &kf_NDF_Spmode );
  //ppimpimTree->Branch( "kfSpmode_status", &kf_status_Spmode );
  //ppimpimTree->Branch( "kfSpmode_pvalue", &kf_pvalue_Spmode );
  //ppimpimTree->Branch( "kf_flag", &kf_flag );
  outfile->cd();



  if( evTree->GetEntries()!=tree->GetEntries() ) {
    std::cout<<"  !!! TTree entries don't match !!!"<<std::endl;
    //return 0;
  }

  InitializeHistogram();


  //*** for kinematical fit ***//
  // beam_K(K+), pi-, Lambda, forward p, p from Lambda, pi- from Lambda
  // !!! only diagonal components !!!
  const int BIN = 4000;
  double cov_MAX;
  for( int ip=0; ip<kinpLpim::npart+1; ip++ ) {
    for( int ii=0; ii <4; ii++ ) {
      for( int jj=0; jj<4; jj++ ) {
        cov_MAX = 0.4;
        Tools::newTH1F(Form("cov_%d_%d_%d", ip, ii, jj), BIN, -cov_MAX, cov_MAX);
        Tools::newTH2F(Form("cov_mom_%d_%d_%d", ip, ii, jj), 500., -cov_MAX, cov_MAX,200,0,2.0);
      }
    }
  }//for ip


  int eventn = tree->GetEntries();
  int stopn  = confMan->GetStopEvNum();
  int exen   = ( 0<stopn && stopn<eventn ) ? stopn : eventn;

  std::cout<<"=====Sigma pi reconstruction in MC START ============="<<std::endl;
  std::cout<<"     # of All  Event in EventTree:     "<<eventn<<std::endl;
  std::cout<<"     # of Stop Event in analyzer.conf: "<<stopn<<std::endl;
  std::cout<<"     # of Exe  Event in this program:  "<<exen<<std::endl;
  std::cout<<"========================================================="<<std::endl;

  //** set cut parameters **//
  PARA_blc2bpc_dx_MIN = -0.75;
  PARA_blc2bpc_dx_MAX = 0.75;
  PARA_blc2bpc_dy_MIN = -0.75;
  PARA_blc2bpc_dy_MAX = 0.75;
  PARA_blc2bpc_dxdz_MIN = -0.02;
  PARA_blc2bpc_dxdz_MAX = 0.02;
  PARA_blc2bpc_dydz_MIN = -0.02;
  PARA_blc2bpc_dydz_MAX = 0.02;
  PARA_lnL_MAX = 9.95;

  PARA_MM_LP_MIN = 0.85;
  PARA_MM_LP_MAX = 1.03;

  //=== counter ===//
  int AllGoodTrack = 0;
  int nTrack       = 0;
  int nTrack_PID   = 0;

  int nG4Event_Lpim   = 0;

  int nAbort_nGoodTrack = 0;
  int nAbort_CDSPID = 0;
  int nAbort_nCDH = 0;
  int nAbort_nT0 = 0;
  int nAbort_nbpc = 0;
  int nAbort_bpctrack = 0;
  int nAbort_nblc2 = 0;
  int nAbort_fblc2bpc = 0;
  int nAbort_flagbmom = 0;
  int nAbort_ftarget = 0;
  int nAbort_pimpim = 0;
  int nAbort_anothern = 0;
  int nAbort_end = 0;
  bool IsGoodEvent = true;

  int nFill_pimpim = 0;
  int nFill_ppimpim = 0;

  int nTrack_CDHshare = 0;

  int ev_cdc = 0;

  //=== event loop ===//
  for( int iev=0; iev<exen; iev++ ) {

    InitTreeVal();
    bool IsrecoPassed=true;
    if(Verbosity_) {
      std::cout<<"> Event Number "<<iev<<std::endl;
    } else if( /*iev<100 ||*/ iev%1000==0 ) {
      std::cout<<"> Event Number "<< iev <<std::endl;
    }
    Tools::Fill1D( Form("EventCheck"), 1 );

    cdsMan->Clear();
    blMan->Clear();
    bltrackMan->Clear();

    tree->GetEntry(iev); // MC
    evTree->GetEntry(ev_cdc); // CDC-tracking

    //### event ID matching
    if( evHeaderMC->eventID()!=header->ev() ) {
      continue;
    }
    ev_cdc++;

    //### CDH ADC cut ###//
    DetectorData *detData2  = new DetectorData();
    for( int i=0; i<detData->detectorHitSize(); i++ ) {
      if( !((detData->detectorHit(i)->detectorID()==CID_CDH) && (detData->detectorHit(i)->adc()<ADC_CDH_MIN)) ) {
        detData2->setDetectorHit(*detData->detectorHit(i));
      }
    }

    simMan->Convert(detData2, confMan, blMan, cdsMan);
    cdstrackMan->Calc(cdsMan, confMan, true);
    bltrackMan->DoTracking(blMan, confMan, true, true);


    //##########################//
    //### get G4 information ###//
    //##########################//
    bool flagG4Decay = false;
    bool Lpim_detect = false;
    //int pi_parent  = 0;
    //int Y_parent  = 0;
    //int N_parent  = 0;
    if(Verbosity_) {
      std::cout<<"======================"<<std::endl;
      std::cout<<std::endl;
      std::cout<<"particle size :" <<   reacData->ParticleSize() << std::endl;
      for( int ip=0; ip<reacData->ParticleSize(); ip++ ) {
        std::cout<< "L." << __LINE__ << " "
                 << ip<<" pdg code:"<<reacData->PDG(ip)<<" mom:"<<reacData->GetParticle(ip).P()
                 <<std::endl;
      }
    }
    //reaction data
    Util::AnaReactionData(reacData);

    react_Lambda = reacData->GetParticle(0);
    react_pim = reacData->GetParticle(1);
    react_pmiss = reacData->GetParticle(2);

    const int reactionID = reacData->ReactionID();
    //These partcile IDs are defined in pythia6
    //see http://home.fnal.gov/~mrenna/lutp0613man2/node44.html
    //
    //Here, K+ is used as beam particle because every particle is emitted from the target volume in GEANT simulation
    //                                       K+    pi-    L   pmiss  pcds   pi-  //
    const int PDG_pLpim[kinpLpim::npart] = {321, -211, 3122, 2212, 2212,  -211}; // K-d->S(1385)p->Lpi-p->ppi-pi-p
    int PDG[kinpLpim::npart] = {0, 0, 0, 0, 0, 0};
    for( int i=0; i<kinpLpim::npart; i++ ) {
      if( reactionID==gen::reactionID_pLpim ) {
        PDG[i] = PDG_pLpim[i];
        if(Verbosity_)std::cout << "L." << __LINE__ << " This is Sigma+ mode sim. " << std::endl;
        //std::cout << "L." << __LINE__ << " This is p L pi-  sim. " << std::endl;
      } else {
        std::cout << "L." << __LINE__ << " reaction ID is wrong !! " << reactionID << std::endl;
      }
    }

    //  beam_K(K-), pi-, pmiss, p from Lambda, pi- from Lambda
    //  0: init. val. for prompt particles , -1:init. val. for decay particles
    int parentID[kinpLpim::npart] = {0, 0, 0, 0, -1, -1};
    // IDs defined by imctrk which is the serial number in mcData class
    int ID[kinpLpim::npart]       = {-1, -1, -1, -1, -1, -1};
    // track ID assigned in mcData class
    int trackID[kinpLpim::npart]  = {-1, -1, -1, -1, -1, -1};
    int nparticle = 0;

    if(Verbosity_) {
      std::cout<< std::endl;
      std::cout<< "L." << __LINE__ << "loop over track Size:" << mcData->trackSize()
               << std::endl;
      std::cout<< std::endl;
    }

    for( int imctrk=0; imctrk<mcData->trackSize(); imctrk++ ) {
      //pdg ID
      const int pdgcode = mcData->track(imctrk)->pdgID();
      //parent track ID, if it is primary particle, 0
      const int parent  = mcData->track(imctrk)->parentTrackID();
      //track ID
      const int track   = mcData->track(imctrk)->trackID();
      const double mom  = mcData->track(imctrk)->momentum().Mag();
      const TVector3 vec_vertex = mcData->track(imctrk)->vertex();
      //This is flight length which is calcuted only when the track reaches to the CDH
      double flightlength = mcData->track(imctrk)->FlightLength();
      if(Verbosity_) {
        std::cout<<"imctrk:" << imctrk<<" | "<< "pdgcode:" << pdgcode<< std::endl;
        std::cout<<"parent_trkID:"<<  parent << std::endl;
        std::cout<<"trackID:"<<track<< std::endl;
        std::cout<<"mom:" << mom << std::endl;
        std::cout<<"vertex R: " << vec_vertex.Perp() << std::endl;
        std::cout<<"vertex Z: " << vec_vertex.Z() << std::endl;
        std::cout<<"flight length:" << flightlength << std::endl;
      }
      for( int ip=0; ip<kinpLpim::npart; ip++ ) {
        //   pick up necessary particles stored in PDG[] array.
        //   if it is primary particle ,parentID is 0, decay particles are rejected by the parentID selection
        if( pdgcode==PDG[ip] && parent==parentID[ip] && ID[ip]==-1 ) {
          ID[ip] = imctrk;
          trackID[ip] = track;
          nparticle++;
          if(Verbosity_) {
            std::cout<<"ip:" << ip<<" | "<<pdgcode<<" "<<parent<<" "<<track<<" "<<mcData->track(imctrk)->momentum().Mag()
                     <<" ("<<mcData->track(imctrk)->momentum().CosTheta()<<" , "<<mcData->track(imctrk)->momentum().Phi()*360./TwoPi<<")"<<std::endl;
          }

          //assign parent IDs for the proton and the pi- from the Lambda
          if( ip==kinpLpim::L ) { //Sp and Sm are same.
            parentID[kinpLpim::pcds] = track;//proton from Lambda
            parentID[kinpLpim::pim_g2] = track;//pim from Lambda
            if(Verbosity_) {
              std::cout << "parentID n  from Sigma:" << parentID[kinpLpim::pcds] << std::endl;
              std::cout << "parentID pi from Sigma:" << parentID[kinpLpim::pim_g2] << std::endl;
            }
          }
          break;
        }//if
      }//for ip
    }//for imctrk

    if( nparticle==kinpLpim::npart ) {
      flagG4Decay = true;
      if(Verbosity_) std::cout << "L." << __LINE__ << " flagG4Decay OK " << std::endl;
    } else {
      if(Verbosity_) std::cout << "L." <<  __LINE__ << " nparticle " << nparticle << std::endl;
    }



    //actually not used ?
    int nCDHhit[kinpLpim::npart] = {0, 0, 0, 0, 0, 0};
    if( flagG4Decay ) { // L -> p pim decay
      for( int ihit=0; ihit<detData2->detectorHitSize(); ihit++ ) {
        int cid    = detData2->detectorHit(ihit)->detectorID();
        int track  = detData2->detectorHit(ihit)->trackID();
        int parent = mcData->track(ihit)->parentTrackID();
        for( int ip=1; ip<kinpLpim::npart; ip++ ) { // ip=0: beam (K-) is not included
          //std::cout << "L." << __LINE__ << " sim IP:" <<  ip << std::endl;
          //std::cout << "L." << __LINE__ << " CID:" << cid << std::endl;
          //std::cout << "L." << __LINE__ << " track:" << track << std::endl;
          //std::cout << "L." << __LINE__ << " trackID[ip]:" << trackID[ip] << std::endl;
          //std::cout << "L." << __LINE__ << " parent:" << parent << std::endl;
          if( cid==CID_CDH && track==trackID[ip] ) {
            //std::cout << "match " << std::endl;
            nCDHhit[ip]++;
          }
        }
        //*** neutron hit search ***//
        //scan ncds and pip/pim from Sigma
        for( int ip=4; ip<kinpLpim::npart; ip++ ) {
          //std::cout << "L." << __LINE__ << " sim IP:" <<  ip << std::endl;
          //std::cout << "L." << __LINE__ << " parent:" << parent << std::endl;
          //std::cout << "L." << __LINE__ << " trackID[ip]:" << trackID[ip] << std::endl;
          if( cid==CID_CDH && parent==trackID[ip] ) {
            //std::cout << "match " << std::endl;
            nCDHhit[ip]++;
          }
        }
        //*** neutron hit search ***//
      }//ihit
    }//flagG4Decay

    //determine whether pi-Sigma is detected in the CDS
    //actually, not used so far (Jan.22,2019 asano)
    //pim_g1 = pip_g1 pip_g2 = pim_g2
    //not working right now.
    if( nCDHhit[kinpLpim::pim_g1] && nCDHhit[kinpLpim::pcds] && nCDHhit[kinpLpim::pim_g2] ) {
      //std::cout << "allmatch " << std::endl;
      Lpim_detect = true;
      nG4Event_Lpim++;
    }


    //*** for kinematical fit ***//
    // beam_K(K+), pi, Y, N, N from Sigma, pi from Sigma
    // beam particle is emitted from the target
    TLorentzVector TL_gene[kinpLpim::npart]; // generated
    for( int ip=0; ip<kinpLpim::npart; ip++ ) {
      if( ip ) TL_gene[ip].SetVectM(mcData->track(ID[ip])->momentum()*0.001,  pdg->GetParticle(PDG[ip])->Mass()); // GeV
      else    TL_gene[ip].SetVectM(mcData->track(ID[ip])->momentum()*-0.001, pdg->GetParticle(PDG[ip])->Mass()); // GeV
    }

    if(flagG4Decay) {
      double q = (TL_gene[kinpLpim::kmbeam].Vect()-TL_gene[kinpLpim::pmiss].Vect()).Mag();
      TLorentzVector TL_Lambda_cor;// define to evaluate energy loss effect of Sigma
      TLorentzVector TL_LambdaPim;//
      TLorentzVector TL_LambdaPim_cor;//
      if(reactionID == gen::reactionID_pLpim) {
        TL_Lambda_cor = TL_gene[kinpLpim::pcds]+TL_gene[kinpLpim::pim_g2];
        TL_LambdaPim = TL_gene[kinpLpim::L]+TL_gene[kinpLpim::pim_g1];
        TL_LambdaPim_cor = TL_Lambda_cor + TL_gene[kinpLpim::pim_g1];
        Tools::H2("q_IMppim_gen",TL_Lambda_cor.M(), q,100,1,2,300,0,1.5);
        Tools::H1("IMLambdaPim_gen",TL_LambdaPim.M(), 1000,1,2);
        Tools::H2("q_IMLambdaPim_cor_gen",TL_LambdaPim_cor.M(), q,100,1,2,300,0,1.5);
      } else {
        std::cout << "L." << __LINE__ << " input file must be wrong ! " << std::endl;
        std::cout << "reactionID " <<  reactionID << std::endl;
      }
    }

    //##########################//
    //### get G4 information ###//
    //##########################//


    const int nGoodTrack = cdstrackMan->nGoodTrack();
    const int nallTrack  = cdstrackMan->nTrack();
    AllGoodTrack += nGoodTrack;
    nTrack += nallTrack;
    Tools::Fill1D( Form("nGoodTrack"), nGoodTrack );


    //if( Util::GetCDHMul(cdsMan,nGoodTrack,true,true)!=cdscuts_lpim::cdhmulti ){
    if( Util::GetCDHMul(cdsMan,nGoodTrack,true,true)<cdscuts_lpim::cdhmulti ) {
      if(IsrecoPassed)nAbort_nCDH++;
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nCDH" << std::endl;
      //continue;
      IsrecoPassed = false;
    }

    //if( nGoodTrack!=cdscuts_lpim::cds_ngoodtrack ){ // dedicated for pi+ pi- event
    if( nGoodTrack<cdscuts_lpim::cds_ngoodtrack ) { // dedicated for pi+ pi- event
      if(IsrecoPassed)nAbort_nGoodTrack++;
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nGoodTrack" << std::endl;
      //continue;
      IsrecoPassed = false;
    }

    //beam line analysis and event selection

    //** T0 = 1hit selection **//
    int t0seg=-1;
    const double ctmT0 = Util::AnalyzeT0(blMan,confMan,t0seg);
    if(ctmT0<-9000) {
      if(IsrecoPassed) nAbort_nT0++;
      Tools::Fill1D( Form("EventCheck"), 15 );
      //continue;
      IsrecoPassed = false;
    }

    //** BPC track selection **//
    int nbpc = 0;
    int bpcid = -1;
    for( int i=0; i<bltrackMan->ntrackBPC(); i++ ) {
      nbpc++;
      bpcid = i;
    }
    Tools::Fill1D( Form("ntrack_BPC"), nbpc );
    if( nbpc!=1 ) {
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nbpc" << std::endl;
      if(IsrecoPassed)nAbort_nbpc++;
      //continue;
      IsrecoPassed = false;
    }
    LocalTrack *bpctrack = bltrackMan->trackBPC(bpcid);
    if( bpctrack->chi2all()>10 ) {
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_bpctrack" << std::endl;
      if(IsrecoPassed)nAbort_bpctrack++;
      //continue;
      IsrecoPassed = false;
    }

    // vertex calculation //
    for( int it1=0; it1<cdstrackMan->nGoodTrack(); it1++ ) {
      cdstrackMan->CalcVertex_beam(cdstrackMan->GoodTrackID(it1), bltrackMan, confMan);
    }

    //** vectors for PID container **//
    std::vector <int> pip_ID;
    std::vector <int> pim_ID;
    std::vector <int> km_ID;
    std::vector <int> p_ID;
    //std::vector <int> d_ID;


    bool flagbmom = false;

    //** BLC2 track **//
    int nblc2 = 0;
    int blc2id = -1;
    for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ) {
      nblc2++;
      if( bltrackMan->trackBLC2(iblc2trk)->chi2all()<blcuts::blc2_chi2_max) blc2id = iblc2trk;
    }
    Tools::Fill1D( Form("ntrack_BLC2"), nblc2 );
    if( !(nblc2==1 && blc2id!=-1) ) {
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_nblc2" << std::endl;
      if(IsrecoPassed)nAbort_nblc2++;
      //continue;
      IsrecoPassed=false;
    }

    //### BLC2-BPC position matching
    //TODO : take into account beam loss by these cut
    bool fblc2bpc = true;//always true because this is simulation
    if(IsrecoPassed) {
      for( int iblc2trk=0; iblc2trk<bltrackMan->ntrackBLC2(); iblc2trk++ ) {
        if( iblc2trk!=blc2id ) continue;
        LocalTrack *blc2 = bltrackMan->trackBLC2(iblc2trk);
        double xblc2bpc[2], yblc2bpc[2];
        double xmom[2], ymom[2];

        TVector3 Pos_BPC, Pos_BLC2, tmp;
        confMan->GetBLDCWireMapManager()->GetGParam( CID_BPC, Pos_BPC, tmp );
        confMan->GetBLDCWireMapManager()->GetGParam( CID_BLC2a, Pos_BLC2, tmp );
        const double zPos_BPC = Pos_BPC.Z();
        const double zPos_BLC2 = Pos_BLC2.Z();
        const double zPos_BPC_BLC2 = (Pos_BPC.Z()+Pos_BLC2.Z())/2;

        bpctrack->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[0], yblc2bpc[0] );
        bpctrack->XYPosatZ( zPos_BPC, xmom[0], ymom[0] );
        blc2->XYPosatZ( zPos_BPC_BLC2, xblc2bpc[1], yblc2bpc[1]);
        blc2->XYPosatZ( zPos_BLC2, xmom[1], ymom[1]);
        double dxdz[2], dydz[2];
        dxdz[0] = (xmom[0]-xblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
        dxdz[1] = (xmom[1]-xblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);
        dydz[0] = (ymom[0]-yblc2bpc[0]) / (zPos_BPC-zPos_BPC_BLC2);
        dydz[1] = (ymom[1]-yblc2bpc[1]) / (zPos_BLC2-zPos_BPC_BLC2);

        if( (xblc2bpc[1]-xblc2bpc[0])<PARA_blc2bpc_dx_MIN ||
            (xblc2bpc[1]-xblc2bpc[0])>PARA_blc2bpc_dx_MAX ) fblc2bpc = false;
        else if( (yblc2bpc[1]-yblc2bpc[0])<PARA_blc2bpc_dy_MIN ||
                 (yblc2bpc[1]-yblc2bpc[0])>PARA_blc2bpc_dy_MAX ) fblc2bpc = false;
        else if( (dxdz[1]-dxdz[0])<PARA_blc2bpc_dxdz_MIN ||
                 (dxdz[1]-dxdz[0])>PARA_blc2bpc_dxdz_MAX ) fblc2bpc = false;
        else if( (dydz[1]-dydz[0])<PARA_blc2bpc_dydz_MIN ||
                 (dydz[1]-dydz[0])>PARA_blc2bpc_dydz_MAX ) fblc2bpc = false;
        else fblc2bpc = true;

        Tools::Fill2D( Form("dydx_BLC2BPC"), xblc2bpc[1]-xblc2bpc[0], yblc2bpc[1]-yblc2bpc[0] );
        Tools::Fill2D( Form("dydzdxdz_BLC2BPC"), dxdz[1]-dxdz[0], dydz[1]-dydz[0] );
      }//iblc2trk
    }

    if( !fblc2bpc ) {
      if(Verbosity_)std::cout << "L." << __LINE__ << " Abort_fblc2bpc" << std::endl;
      if(IsrecoPassed)nAbort_fblc2bpc++;
      //continue;
      IsrecoPassed=false;
    }

    //** beam momentum calculation **//
    TLorentzVector LVec_beambf;  // 4-Momentum(beam) in LAB
    TLorentzVector LVec_beam;    // 4-Momentum(beam) in LAB with dE correcion
    TLorentzVector LVec_target;  // 4-Momentum(He3-target) in LAB
    TLorentzVector LVec_targetP; // 4-Momentum(p-target) in LAB
    TLorentzVector LVec_beambfCM;  // 4-Momentum(beam) in CM
    TLorentzVector LVec_beamCM;    // 4-Momentum(beam) in CM with dE correcion
    TLorentzVector LVec_targetCM;  // 4-Momentum(He3-target) in CM
    TLorentzVector LVec_targetPCM; // 4-Momentum(p-target) in CM


    //std::cout << "test" << std::endl;
    //std::cout << "bpctrack->GetPosatZ(0)" << std::endl;
    //std::cout << bpctrack->GetPosatZ(0).X() << "  " <<  bpctrack->GetPosatZ(0).Y()  << "  " << bpctrack->GetPosatZ(0).Z()  << std::endl;
    //std::cout << zPos_T0 << std::endl;
    //std::cout << bpctrack->GetPosatZ(zPos_T0 ).X() << "  " <<  bpctrack->GetPosatZ(zPos_T0).Y()  << "  " << bpctrack->GetPosatZ(zPos_T0).Z()  << std::endl;
    double beammom = 0;
    for( int imctrk=0; imctrk<mcData->trackSize(); imctrk++ ) {
      const int pdgcode = mcData->track(imctrk)->pdgID();
      const int parent  = mcData->track(imctrk)->parentTrackID();
      //beam K (K+) to -Z direction
      //beam momentum is fixed in GEANT simulation. It is smeared here by gaussian.
      if( pdgcode==321 && parent==0 ) {
        if(!UseRealBeamMom){
          beammom = (mcData->track(imctrk)->momentum().Mag()+gRandom->Gaus(0,MOM_RES))/1000.0;
        }else{
          beammom = realBeamMom->GetRandom();
        }
        
        if(Verbosity_>100) {
          std::cout << "L." << __LINE__ << " beam mom:" << beammom << std::endl;
        }
        break;
      }
    }

    double x1, y1, x2, y2;
    const double z1 = 0, z2 = 20;//TODO: what is this 20 ?
    if(IsrecoPassed) {
      bpctrack->XYPosatZ(z1, x1, y1);
      bpctrack->XYPosatZ(z2, x2, y2);
    }
    TVector3 ls;
    ls.SetXYZ(x2-x1, y2-y1, z2-z1);
    ls = ls.Unit();
    TVector3 Pp_beam = beammom*ls;
    TVector3 Pp_target;
    Pp_target.SetXYZ(0, 0, 0);

    LVec_beambf.SetVectM(Pp_beam, kpMass);
    LVec_target.SetVectM(Pp_target, dMass);
    LVec_target.SetVectM(Pp_target, dMass);
    LVec_targetP.SetVectM(Pp_target, pMass);
    LVec_beam = LVec_beambf;
    //Lorentz boost Vector
    const TVector3 boost = (LVec_target+LVec_beam).BoostVector();
    LVec_beambfCM = LVec_beam;
    LVec_targetCM = LVec_target;
    LVec_targetPCM = LVec_targetP;
    LVec_beambfCM.Boost(-1.*boost);
    LVec_targetCM.Boost(-1.*boost);
    LVec_targetPCM.Boost(-1.*boost);
    flagbmom = true;

    double px = (LVec_beam).Px();
    double py = (LVec_beam).Py();
    double pz = (LVec_beam).Pz();
    double E = (LVec_beam).E();
    TLorentzVector LVec_beam_unit;
    LVec_beam_unit.SetPx(px*1000.0);
    LVec_beam_unit.SetPy(py*1000.0);
    LVec_beam_unit.SetPz(pz*1000.0);
    LVec_beam_unit.SetE(E*1000.0);
    double q = (LVec_beam_unit.Vect()-react_pmiss.Vect()).Mag()/1000.;
    TLorentzVector TL_piLambda = react_Lambda + react_pim;
    double mass = TL_piLambda.M()/1000.;
    Tools::H2("q_IMLPim_gen",mass,q,800,1.2,2,300,0,1.5);

    //always OK, because this is simulation
    if( !flagbmom ) {
      if(IsrecoPassed)nAbort_flagbmom++;
      //continue;
      IsrecoPassed = false;
    }
    Tools::Fill1D( Form("momentum_beam"), LVec_beambf.P() );

    //** + + + + + + + + + + + + **//
    //**  PID in CDS             **//
    //** + + + + + + + + + + + + **//

    std::vector <int> vCDHseg;
    TVector3 pim_cdhprojected;
    TVector3 pip_cdhprojected;
    int nIDedTrack =0;
    if(IsrecoPassed) {
      nIDedTrack = Util::CDSChargedAna(
                     DoCDCRetiming,
                     bpctrack, cdsMan, cdstrackMan, confMan, blMan,
                     LVec_beam, ctmT0,vCDHseg,pim_ID,pip_ID,km_ID,p_ID,
                     pim_cdhprojected,pip_cdhprojected,true);
      if(nIDedTrack==-7) Tools::Fill1D( Form("EventCheck"), 7 );
      if(nIDedTrack==-8) Tools::Fill1D( Form("EventCheck"), 8 );
      if(nIDedTrack==-9) {
        nTrack_CDHshare++;
        Tools::Fill1D( Form("EventCheck"), 9 );
      }
      if(nIDedTrack==-10) Tools::Fill1D( Form("EventCheck"), 10 );
      if(nIDedTrack==-11) Tools::Fill1D( Form("EventCheck"), 11 );
      if(nIDedTrack==-12) Tools::Fill1D( Form("EventCheck"), 12 );
    }
    if(nIDedTrack<0) {
      if(IsrecoPassed)nAbort_CDSPID++;
      //continue;
      IsrecoPassed = false;
    }

    if(nIDedTrack>0) nTrack_PID =+ nIDedTrack;
    Tools::Fill1D( Form("ntrack_CDS"), pip_ID.size()+p_ID.size()+pim_ID.size()+km_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_plus"),  pip_ID.size() );
    Tools::Fill1D( Form("ntrack_proton"),   p_ID.size() );
    //Tools::Fill1D( Form("ntrack_deuteron"), d_ID.size() );
    Tools::Fill1D( Form("ntrack_pi_minus"), pim_ID.size() );
    Tools::Fill1D( Form("ntrack_K_minus"),  km_ID.size() );

    bool forwardcharge= false; //Util::IsForwardCharge(blMan);

    int nPC =0 ;
    for( int i=0; i<blMan->nPC(); i++ ) {
      if( blMan->PC(i)->CheckRange() ) nPC++;
    }
    if(nPC) forwardcharge=true;
    // + + + + + + + + + + + //
    //  pi+ pi- X event  //
    // + + + + + + + + + + + //
    if( IsrecoPassed &&
        flagbmom &&
        (pim_ID.size()==2) &&
        (
          ((p_ID.size()==1) && (3<=cdstrackMan->nGoodTrack() && cdstrackMan->nGoodTrack()<=4))
          ||((p_ID.size()==2) && (cdstrackMan->nGoodTrack()==4))
        )
      ) {

      nFill_pimpim++;

      CDSTrack *track_pim1 = cdstrackMan->Track( pim_ID[0] ); // only 1 track
      CDSTrack *track_pim2 = cdstrackMan->Track( pim_ID[1] ); // only 1 track
      CDSTrack *track_p    = cdstrackMan->Track( p_ID[0] ); // only 1 track
      CDSTrack *track_p2;
      if(p_ID.size()==2) {
        track_p2 = cdstrackMan->Track( p_ID[1] ); // only 1 track
      }

      TVector3 vtx_react;//reaction vertex
      TVector3 vtx_dis;//displaced vertex


      TVector3 vtx_beam_wpim1;//vertex(beam-pip) on beam
      TVector3 vtx_pim1;//vertex(beam-pip) on particle
      TVector3 vtx_beam;
      track_pim1->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_beam_wpim1, vtx_pim1 );
      TVector3 vtx_beam_wpim2;//vertex(beam-pim) on beam
      TVector3 vtx_pim2;//vertex(beam-pim) on particle
      track_pim2->GetVertex( bpctrack->GetPosatZ(0), bpctrack->GetMomDir(), vtx_beam_wpim2, vtx_pim2 );


      TVector3 vtx_beam_wp;//vertex(beam-proton) on beam
      TVector3 vtx_p;//vertex(beam-proton) on cdc track
      track_p->GetVertex(bpctrack->GetPosatZ(0),bpctrack->GetMomDir(),vtx_beam_wp,vtx_p);
      TVector3 vtx_beam_wp2(-9999.,-9999.,-9999.);
      TVector3 vtx_p2(-9999.,-9999.,-9999.);//vertex(beam-proton) on cdc track
      if(p_ID.size()==2) {
        track_p2->GetVertex(bpctrack->GetPosatZ(0),bpctrack->GetMomDir(),vtx_beam_wp2,vtx_p2);
      }
      double dcapim1vtx =  (vtx_pim1-vtx_beam_wpim1).Mag();
      double dcapim2vtx =  (vtx_pim2-vtx_beam_wpim2).Mag();
      const TVector3 vtx_pim1_mean = 0.5*(vtx_pim1+vtx_beam_wpim1);
      const TVector3 vtx_pim2_mean = 0.5*(vtx_pim2+vtx_beam_wpim2);
      Tools::Fill1D( Form("DCA_pim1"), dcapim1vtx );
      Tools::Fill1D( Form("DCA_pim2"), dcapim2vtx );

      TVector3 CroA_pim1_pim1pim2,CroA_pim2_pim1pim2;
      bool vtx_flag=TrackTools::Calc2HelixVertex(track_pim1, track_pim2, CroA_pim1_pim1pim2, CroA_pim2_pim1pim2);
      double dcapim1pim2=-9999.;
      if(vtx_flag) dcapim1pim2 = (CA_pim1_pim1pim2-CA_pim2_pim1pim2).Mag();

      TVector3 CroA_pim1_pim1p,CroA_p_pim1p;
      TrackTools::Calc2HelixVertex(track_pim1, track_p, CroA_pim1_pim1p, CroA_p_pim1p);

      TVector3 CroA_pim2_pim2p,CroA_p_pim2p;
      TrackTools::Calc2HelixVertex(track_pim2, track_p, CroA_pim2_pim2p, CroA_p_pim2p);

      TVector3 CroA_pim1_pim1p2,CroA_p2_pim1p2;
      if(p_ID.size()==2){
        TrackTools::Calc2HelixVertex(track_pim1, track_p2, CroA_pim1_pim1p2, CroA_p2_pim1p2);
      }

      TVector3 CroA_pim2_pim2p2,CroA_p2_pim2p2;
      if(p_ID.size()==2){
        TrackTools::Calc2HelixVertex(track_pim2, track_p2, CroA_pim2_pim2p2, CroA_p2_pim2p2);
      }

      //reaction vertex is determined from beam and nearest vtx
      if(dcapim1vtx <= dcapim2vtx) {
        //follows sakuma/sada's way , avg. of scattered particle ana beam particle [20180829]
        vtx_react = 0.5*(vtx_pim1+vtx_beam_wpim1);
        //if(cdscuts_lpimuseclosestpi) vtx_dis  = vtx_pip;
        //else              vtx_dis  = vtx_pim;
        //vtx_dis  = vtx_pim;
        //vtx_dis  = CA_pim2_pim1pim2;
        vtx_dis  = vtx_p;
        vtx_beam = vtx_beam_wpim1;
      } else {
        vtx_react = 0.5*(vtx_pim2+vtx_beam_wpim2);
        //if(cdscuts_lpimuseclosestpi) vtx_dis = vtx_pim;
        //else             vtx_dis = vtx_pip;
        //vtx_dis = vtx_pip;
        //vtx_dis = CA_pim1_pim1pim2;
        vtx_dis = vtx_p;
        vtx_beam = vtx_beam_wpim2;
      }

      if(p_ID.size()==2) {
        double dcap1 = (vtx_p-vtx_beam_wp).Mag();
        double dcap2 = (vtx_p2-vtx_beam_wp2).Mag();
        if(dcap2>dcap1) {
          vtx_dis = vtx_p2;
        }
      }





      // beam kaon tof
      TVector3 Pos_T0;
      confMan->GetGeomMapManager()->GetPos( CID_T0, 0, Pos_T0 );
      double beamtof=0;
      double momout=0;
      double z_pos = Pos_T0.Z();;
      ELossTools::CalcElossBeamTGeo( bpctrack->GetPosatZ(z_pos), vtx_react,
                                     LVec_beambf.Vect().Mag(), kpMass, momout, beamtof );

      //** reconstructoin of missing proton **//
      TVector3 P_pim1; // Momentum(pi-1)
      TVector3 P_pim2; // Momentum(pi-2)
      TVector3 P_p; // Momentum(proton detected by cds)
      TVector3 P_p2; // Momentum(proton detected by cds)

      TLorentzVector LVec_pim1; // 4-Momentum(pi-)
      TLorentzVector LVec_pim2; // 4-Momentum(pi+)
      TLorentzVector LVec_p;   // 4-Momentum(proton)
      TLorentzVector LVec_p2;   // 4-Momentum(proton)
      TLorentzVector LVec_pmiss; // 4-Momentum(missing proton)

      if( !track_pim1->GetMomentum( vtx_pim1, P_pim1, true, true ) ) {
        std::cout<<"L." << __LINE__ << " !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
      }
      if( !track_pim2->GetMomentum( vtx_pim2, P_pim2, true, true ) ) {
        std::cout<<"L." << __LINE__ << " !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
      }
      if( !track_p->GetMomentum( vtx_p, P_p, true, true ) ) {
        std::cerr<<"L." << __LINE__ << " !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
      }
      if(p_ID.size()==2) {
        if( !track_p2->GetMomentum( vtx_p2, P_p2, true, true ) ) {
          std::cerr<<"L." << __LINE__ << " !!! failure in momentum calculation [GetMomentum()] !!! "<<std::endl;
        }
      }

      LVec_pim1.SetVectM( P_pim1, piMass );
      LVec_pim2.SetVectM( P_pim2, piMass );
      LVec_p.SetVectM(   P_p,   pMass );//CDS p
      LVec_p2.SetVectM( P_p2, pMass);
      
      const double mm_mass   = (LVec_target+LVec_beam-LVec_pim1-LVec_pim2-LVec_p).M();
      double mm_mass2= 0.0;
      if(p_ID.size()==2){
        mm_mass2   = (LVec_target+LVec_beam-LVec_pim1-LVec_pim2-LVec_p2).M();
      }
      const TVector3 P_missp = (LVec_target+LVec_beam-LVec_pim1-LVec_pim2-LVec_p).Vect();
      LVec_pmiss.SetVectM( P_missp, pMass );
      //TVector3 boost = (LVec_target+LVec_beam).BoostVector();
      TLorentzVector LVec_pmiss_CM = LVec_pmiss;
      TLorentzVector LVec_beam_CM = LVec_beam;
      LVec_pmiss_CM.Boost(-boost);
      LVec_beam_CM.Boost(-boost);
      double cos_p = LVec_pmiss_CM.Vect().Dot(LVec_beam_CM.Vect())/(LVec_pmiss_CM.Vect().Mag()*LVec_beam_CM.Vect().Mag());
      if(Verbosity_)std::cout<<"  missing mom = "<<LVec_pmiss.P()<<" | cos_CM = "<<cos_p<<std::endl;


      //** + + + + + + + + + + + + + **//
      //**  fill histograms & tree   **//
      //** + + + + + + + + + + + + + **//
      kf_flag = -1;
      bool MissPFlag=false;
      bool LambdaFlag=false;
      bool MissP2Flag=false;
      bool Lambda2Flag=false;
      
      //missing mass neutron ID
      if( anacuts_lpim::proton_MIN<mm_mass && mm_mass<anacuts_lpim::proton_MAX ) MissPFlag=true;

      //Lambda production in CDS
      if( (anacuts_lpim::ppi_MIN<(LVec_p+LVec_pim1).M() && (LVec_p+LVec_pim1).M()<anacuts_lpim::ppi_MAX)) LambdaFlag=true;
      if( (anacuts_lpim::ppi_MIN<(LVec_p+LVec_pim2).M() && (LVec_p+LVec_pim2).M()<anacuts_lpim::ppi_MAX)) LambdaFlag=true;
      
      if(p_ID.size()==2) {
        if( anacuts_lpim::proton_MIN<mm_mass2 && mm_mass2 <anacuts_lpim::proton_MAX ) MissP2Flag=true;
        if( (anacuts_lpim::ppi_MIN<(LVec_p2+LVec_pim1).M() && (LVec_p2+LVec_pim1).M()<anacuts_lpim::ppi_MAX)) Lambda2Flag=true;
        if( (anacuts_lpim::ppi_MIN<(LVec_p2+LVec_pim2).M() && (LVec_p2+LVec_pim2).M()<anacuts_lpim::ppi_MAX)) Lambda2Flag=true;
      }

      Tools::Fill2D( Form("MMom_MMass"), mm_mass, P_missp.Mag() );

      Tools::Fill2D(Form("Vtx_ZX_nofid"),vtx_pim1_mean.Z(),vtx_pim1_mean.X());
      Tools::Fill2D(Form("Vtx_ZY_nofid"),vtx_pim1_mean.Z(),vtx_pim1_mean.Y());
      Tools::Fill2D(Form("Vtx_XY_nofid"),vtx_pim1_mean.X(),vtx_pim1_mean.Y());
      Tools::Fill2D(Form("Vtx_ZX_nofid"),vtx_pim2_mean.Z(),vtx_pim2_mean.X());
      Tools::Fill2D(Form("Vtx_ZY_nofid"),vtx_pim2_mean.Z(),vtx_pim2_mean.Y());
      Tools::Fill2D(Form("Vtx_XY_nofid"),vtx_pim2_mean.X(),vtx_pim2_mean.Y());
      //Fiducial cuts OK
      if( (!IsVtxDoubleCheck && (GeomTools::GetID(vtx_react)==CID_Fiducial)) ||
          ( IsVtxDoubleCheck &&
            (GeomTools::GetID(vtx_pim1_mean)==CID_Fiducial) &&
            (GeomTools::GetID(vtx_pim2_mean)==CID_Fiducial)))  {

        Tools::Fill2D(Form("Vtx_ZX_primfid"),vtx_react.Z(),vtx_react.X());
        Tools::Fill2D(Form("Vtx_ZY_primfid"),vtx_react.Z(),vtx_react.Y());
        Tools::Fill2D(Form("Vtx_XY_primfid"),vtx_react.X(),vtx_react.Y());
        Tools::Fill2D(Form("Vtx_ZX_fid"),vtx_pim1_mean.Z(),vtx_pim1_mean.X());
        Tools::Fill2D(Form("Vtx_ZY_fid"),vtx_pim1_mean.Z(),vtx_pim1_mean.Y());
        Tools::Fill2D(Form("Vtx_XY_fid"),vtx_pim1_mean.X(),vtx_pim1_mean.Y());
        Tools::Fill2D(Form("Vtx_ZX_fid"),vtx_pim2_mean.Z(),vtx_pim2_mean.X());
        Tools::Fill2D(Form("Vtx_ZY_fid"),vtx_pim2_mean.Z(),vtx_pim2_mean.Y());
        Tools::Fill2D(Form("Vtx_XY_fid"),vtx_pim2_mean.X(),vtx_pim2_mean.Y());
        Tools::Fill2D( Form("MMom_MMass_fid"), mm_mass, P_missp.Mag() );
        Tools::Fill2D( Form("MMom_PMom_fid"), P_p.Mag(), P_missp.Mag() );
        Tools::Fill2D( Form("IMppim1_IMppim2"), (LVec_p+LVec_pim1).M(), (LVec_p+LVec_pim2).M() );
        Tools::Fill2D( Form("q_IMppipi"), (LVec_p+LVec_pim1+LVec_pim2).M(), (LVec_beam.Vect()-LVec_pmiss.Vect()).Mag());



        if(MissPFlag) {
          Tools::Fill2D( Form("MMom_MMass_fid_p"), mm_mass, P_missp.Mag() );
          Tools::Fill2D( Form("MMom_PMom_fid_p"), P_p.Mag(), P_missp.Mag() );
          Tools::Fill2D( Form("IMppim1_IMppim2_p"), (LVec_p+LVec_pim1).M(), (LVec_p+LVec_pim2).M() );
          Tools::Fill2D( Form("q_IMppipi_p"), (LVec_p+LVec_pim1+LVec_pim2).M(), (LVec_beam.Vect()-LVec_pmiss.Vect()).Mag());
        }

        if(MissPFlag && LambdaFlag) {
          Tools::Fill2D( Form("q_IMppipi_wL_p"), (LVec_p+LVec_pim1+LVec_pim2).M(), (LVec_beam.Vect()-LVec_pmiss.Vect()).Mag());
        }

        /*
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
        // %%% Kinematical Fit using KinFitter %%% //
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
        //--- set TLorentzVector for MC study---//
        // beam_K(K+), pi-/+, Sigma+/-, n, n from Sigma, pi+/- from Sigma
        //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
        //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
        TLorentzVector TL_meas[kinpLpim::npart]; // measured
        //TL_meas[kinpLpim::kmbeam] = LVec_beam;
        //TL_meas[kinpLpim::nmiss] = LVec_nmiss; // * which n?
        //TL_meas[kinpLpim::ncds] = LVec_n;     // * which n?
          if( reactionID == gen::reactionID_Spmode ){
            TL_meas[kinpLpim::kmbeam] = LVec_beam_vtx[0];
            TL_meas[kinpLpim::nmiss] = LVec_nmiss_vtx[0]; // * which n?
            TL_meas[kinpLpim::ncds] = LVec_n_vtx[0];     // * which n?
            TL_meas[kinpLpim::pim_g1] = LVec_pim;
            //TL_meas[kinpLpim::Sp] = (LVec_n+LVec_pip);
            TL_meas[kinpLpim::Sp] = (LVec_n_vtx[0]+LVec_pip);
            TL_meas[kinpLpim::pip_g2] = LVec_pip;
          } else if ( reactionID == gen::reactionID_Smmode ){
            TL_meas[kinpLpim::kmbeam] = LVec_beam_vtx[1];
            TL_meas[kinpLpim::nmiss] = LVec_nmiss_vtx[1]; // * which n?
            TL_meas[kinpLpim::ncds] = LVec_n_vtx[1];     // * which n?
            TL_meas[kinpLpim::pip_g1] = LVec_pip;
            //TL_meas[kinpLpim::Sm] = (LVec_n+LVec_pim);
            TL_meas[kinpLpim::Sm] = (LVec_n_vtx[1]+LVec_pim);
            TL_meas[kinpLpim::pim_g2] = LVec_pim;
          }
          double val1 = (TL_meas[kinpLpim::ncds]-TL_gene[kinpLpim::nmiss]).P(); // n_measured - n_initial
          double val2 = (TL_meas[kinpLpim::ncds]-TL_gene[kinpLpim::ncds]).P(); // n_measured - n_Sigma
          int genID[kinpLpim::npart] = {0,1,2,3,4,5};
          IsGoodEvent = true;
          if( val1<val2 ){ // is there more good selection way?
            genID[kinpLpim::nmiss] = kinpLpim::ncds;
            genID[kinpLpim::ncds] = kinpLpim::nmiss;

            //ncds(gen.) is not detected, initial n is detected in CDS instead.
            //abort this event !
            nAbort_anothern++;
            IsGoodEvent = false;
          }
          */
        //if(Verbosity_)std::cout<< "L." << __LINE__ << " val = "<<val1<<" "<<val2<<" -> "<< genID[kinpLpim::nmiss] <<" "<< genID[kinpLpim::ncds] << std::endl;
        const int genID[kinpLpim::npart] = {0,1,2,3,4,5};
        mcmom_beam = TL_gene[genID[kinpLpim::kmbeam]];
        mcmom_p = TL_gene[genID[kinpLpim::pcds]];
        mcmom_pmiss = TL_gene[genID[kinpLpim::pmiss]];
        mcmom_pim1  = TL_gene[genID[kinpLpim::pim_g1]];
        mcmom_pim2  = TL_gene[genID[kinpLpim::pim_g2]];
        /*
        //--- set TLorentzVector ---//
        // beam_K(K+), pi-/+, Sigma+/-, p, n, n from S, pi+/- from S
        //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip), LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
        TLorentzVector TL_measSpmode[kinpLpim::npart]; // measured
        //TL_measSpmode[kinpLpim::kmbeam] = LVec_beam;
        TL_measSpmode[kinpLpim::kmbeam] = LVec_beam_vtx[0];
        TL_measSpmode[kinpLpim::pim_g1] = LVec_pim;
        //TL_measSpmode[kinpLpim::Sp] = (LVec_n+LVec_pip);
        TL_measSpmode[kinpLpim::Sp] = (LVec_n_vtx[0]+LVec_pip);
        //TL_measSpmode[kinpLpim::nmiss] = LVec_nmiss;
        TL_measSpmode[kinpLpim::nmiss] = LVec_nmiss_vtx[0];
        //TL_measSpmode[kinpLpim::ncds] = LVec_n;
        TL_measSpmode[kinpLpim::ncds] = LVec_n_vtx[0];
        TL_measSpmode[kinpLpim::pip_g2] = LVec_pip;
        //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim), LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
        TLorentzVector TL_measSmmode[kinpLpim::npart]; // measured
        //TL_measSmmode[kinpLpim::kmbeam] = LVec_beam;
        TL_measSmmode[kinpLpim::kmbeam] = LVec_beam_vtx[1];
        TL_measSmmode[kinpLpim::pip_g1] = LVec_pip;
        //TL_measSmmode[kinpLpim::Sm] = (LVec_n+LVec_pim);
        TL_measSmmode[kinpLpim::Sm] = (LVec_n_vtx[1]+LVec_pim);
        //TL_measSmmode[kinpLpim::nmiss] = LVec_nmiss;
        TL_measSmmode[kinpLpim::nmiss] = LVec_nmiss_vtx[1];
        //TL_measSmmode[kinpLpim::ncds] = LVec_n;
        TL_measSmmode[kinpLpim::ncds] = LVec_n_vtx[1];
        TL_measSmmode[kinpLpim::pim_g2] = LVec_pim;
        TLorentzVector TL_kfitSpmode[kinpLpim::npart]; // kinematical fitted
        TLorentzVector TL_kfitSmmode[kinpLpim::npart]; // kinematical fitted
        // LVec_target is defined as (0, 0, 0, M_D2)
        TVector3 TV_target = LVec_target.Vect();
        TVector3 TV_measSpmode[kinpLpim::npart];
        TVector3 TV_measSmmode[kinpLpim::npart];
        for( int ip=0; ip<kinpLpim::npart; ip++ ){
          TV_measSpmode[ip] = TL_measSpmode[ip].Vect();
          TV_measSmmode[ip] = TL_measSmmode[ip].Vect();
        }//for npart

        //--- KinFitter :: initialization ---//
        //  = 1) TLorentzVector LVec_beam, LVec_pim, (LVec_n+LVec_pip),  LVec_nmiss, LVec_n, LVec_pip = for pi- Sigma+
        //  = 2) TLorentzVector LVec_beam, LVec_pip, (LVec_n+LVec_pim),  LVec_nmiss, LVec_n, LVec_pim = for pi+ Sigma-
        //--- definition of fit particles in cartesian coordinates ---//
        TString str_particleSpmode[kinpLpim::npart] = {"LVec_beam", "LVec_pim", "LVec_Sp",  "LVec_mn", "LVec_n", "LVec_pip"};
        TString str_particleSmmode[kinpLpim::npart] = {"LVec_beam", "LVec_pip", "LVec_Sm",  "LVec_mn", "LVec_n", "LVec_pim"};
        TFitParticlePxPyPz ParticleTgt = TFitParticlePxPyPz("target", "target", &TV_target,
            pdg->GetParticle("deuteron")->Mass(), covZero);
        TFitParticlePxPyPz ParticleSpmode[kinpLpim::npart];
        TFitParticlePxPyPz ParticleSmmode[kinpLpim::npart];
        for( int ip=0; ip<kinpLpim::npart; ip++ ){
          ParticleSpmode[ip] = TFitParticlePxPyPz(str_particleSpmode[ip], str_particleSpmode[ip], &TV_measSpmode[ip],
              pdg->GetParticle(PDG_pLpim[ip])->Mass(), covParticlepLpim[ip]);
          ParticleSmmode[ip] = TFitParticlePxPyPz(str_particleSmmode[ip], str_particleSmmode[ip], &TV_measSmmode[ip],
              pdg->GetParticle(PDG_Smmode[ip])->Mass(), covParticleSmmode[ip]);
        }
        //--- definition of constraints ---//
        // constraint :: mass of Sigma
        TFitConstraintM ConstMSSpmode = TFitConstraintM("M_Sp", "M_Sp", 0, 0, pdg->GetParticle(PDG_pLpim[kinpLpim::Sp])->Mass());
        TFitConstraintM ConstMSSmmode = TFitConstraintM("M_Sm", "M_Sm", 0, 0, pdg->GetParticle(PDG_Smmode[kinpLpim::Sm])->Mass());
        ConstMSSpmode.addParticles1(&ParticleSpmode[kinpLpim::ncds], &ParticleSpmode[kinpLpim::pip_g2]);
        ConstMSSmmode.addParticles1(&ParticleSmmode[kinpLpim::ncds], &ParticleSmmode[kinpLpim::pim_g2]);
        // constraint :: 4-momentum conservation
        TFitConstraintEp ConstEpSpmode[4];
        TFitConstraintEp ConstEpSmmode[4];
        TString str_constEpSpmode[4]  = {"Px", "Py", "Pz", "E"};
        TString str_constEpSmmode[4]  = {"Px", "Py", "Pz", "E"};
        for( int i=0; i<4; i++ ){
          ConstEpSpmode[i] = TFitConstraintEp(str_constEpSpmode[i], str_constEpSpmode[i], 0, TFitConstraintEp::component(i), 0);
          ConstEpSmmode[i] = TFitConstraintEp(str_constEpSmmode[i], str_constEpSmmode[i], 0, TFitConstraintEp::component(i), 0);
          ConstEpSpmode[i].addParticles1(&ParticleTgt, &ParticleSpmode[kinpLpim::kmbeam]);
          ConstEpSmmode[i].addParticles1(&ParticleTgt, &ParticleSmmode[kinpLpim::kmbeam]);
          ConstEpSpmode[i].addParticles2(&ParticleSpmode[kinpLpim::pim_g1],&ParticleSpmode[kinpLpim::nmiss], &ParticleSpmode[kinpLpim::ncds], &ParticleSpmode[kinpLpim::pip_g2]);
          ConstEpSmmode[i].addParticles2(&ParticleSmmode[kinpLpim::pip_g1],&ParticleSmmode[kinpLpim::nmiss], &ParticleSmmode[kinpLpim::ncds], &ParticleSmmode[kinpLpim::pim_g2]);
        }//for i

        //--- KinFitter :: execution ---//
        //--- definition of the fitter ---//
        TKinFitter kinfitter_Spmode;
        TKinFitter kinfitter_Smmode;
        // add measured particles
        // K-, pi-, ncds, pi+
        kinfitter_Spmode.addMeasParticles(&ParticleSpmode[kinpLpim::kmbeam], &ParticleSpmode[kinpLpim::pim_g1], &ParticleSpmode[kinpLpim::ncds], &ParticleSpmode[kinpLpim::pip_g2]);
        // K, pi+,  n, pi-
        kinfitter_Smmode.addMeasParticles(&ParticleSmmode[kinpLpim::kmbeam], &ParticleSmmode[kinpLpim::pip_g1], &ParticleSmmode[kinpLpim::ncds], &ParticleSmmode[kinpLpim::pim_g2]);
        // unmeasured particle forward missing neutron
        kinfitter_Spmode.addUnmeasParticles(&ParticleSpmode[kinpLpim::nmiss]); // missing-n
        kinfitter_Smmode.addUnmeasParticles(&ParticleSmmode[kinpLpim::nmiss]); // missing-n
        // add constraints
        kinfitter_Spmode.addConstraint(&ConstMSSpmode); // mass of Sigma+
        kinfitter_Smmode.addConstraint(&ConstMSSmmode); // mass of Sigma-
        for( int i=0; i<4; i++ ){
          kinfitter_Spmode.addConstraint(&ConstEpSpmode[i]); // 4-momentum conservation
          kinfitter_Smmode.addConstraint(&ConstEpSmmode[i]); // 4-momentum conservation
        }

        //--- perform the fit ---//
        kinfitter_Spmode.setMaxNbIter(kinpLpim::maxitr);       // max number of iterations
        kinfitter_Smmode.setMaxNbIter(kinpLpim::maxitr);       // max number of iterations
        kinfitter_Spmode.setMaxDeltaS(kinpLpim::maxdchi2);     // max delta chi2
        kinfitter_Smmode.setMaxDeltaS(kinpLpim::maxdchi2);     // max delta chi2
        kinfitter_Spmode.setMaxF(kinpLpim::maxsumconst);          // max sum of constraints
        kinfitter_Smmode.setMaxF(kinpLpim::maxsumconst);          // max sum of constraints
        kinfitter_Spmode.setVerbosity(KFDEBUG);  // verbosity level
        kinfitter_Smmode.setVerbosity(KFDEBUG);  // verbosity level
        kinfitter_Spmode.fit();
        kinfitter_Smmode.fit();
        //--- copy fit results ---//
        for( int ip=0; ip<kinpLpim::npart; ip++ ){
          TL_kfitSpmode[ip] = (*ParticleSpmode[ip].getCurr4Vec());
          TL_kfitSmmode[ip] = (*ParticleSmmode[ip].getCurr4Vec());
        }
        //reconstruct Lorentz vector of Sigma+/-
        TL_kfitSpmode[kinpLpim::Sp] = TL_kfitSpmode[kinpLpim::ncds]+TL_kfitSpmode[kinpLpim::pip_g2];
        TL_kfitSmmode[kinpLpim::Sm] = TL_kfitSmmode[kinpLpim::ncds]+TL_kfitSmmode[kinpLpim::pim_g2];

        int correct_flag = 0;
        if( kinfitter_Spmode.getStatus()==0 &&  //0 means that kinfit is converged
            kinfitter_Spmode.getS()<kinfitter_Smmode.getS() &&
            reactionID==gen::reactionID_Spmode ){
          correct_flag = 1;//Spmode
        }else if( kinfitter_Smmode.getStatus()==0 &&
            kinfitter_Smmode.getS()<kinfitter_Spmode.getS() &&
            reactionID==gen::reactionID_Smmode ){
          correct_flag = 1;//Smmode
        }

        double chi2 = kinfitter_Spmode.getS()<kinfitter_Smmode.getS() ? kinfitter_Spmode.getS():kinfitter_Smmode.getS();
        Tools::Fill2D( Form("KFchi2_vs"), kinfitter_Spmode.getS()/kinfitter_Spmode.getNDF(),
            kinfitter_Smmode.getS()/kinfitter_Smmode.getNDF() );
        if( chi2 < kinpLpim::chi2cut ) Tools::Fill1D( Form("KF_decision"), correct_flag );

        if(Verbosity_){
          std::cout<<"pi- S+ : status = "<<kinfitter_Spmode.getStatus()<<", chi2/NDF = "<<kinfitter_Spmode.getS()<<"/"<<kinfitter_Spmode.getNDF()<<std::endl;
          std::cout<<"pi+ S- : status = "<<kinfitter_Smmode.getStatus()<<", chi2/NDF = "<<kinfitter_Smmode.getS()<<"/"<<kinfitter_Smmode.getNDF()<<std::endl;
          if      ( reactionID==gen::reactionID_Spmode ) std::cout<<"*** pi- S+ ==> "<<correct_flag<<" ***"<<std::endl;
          else if ( reactionID==gen::reactionID_Smmode ) std::cout<<"*** pi+ S- ==> "<<correct_flag<<" ***"<<std::endl;
        }
        //--- fill tree ---//
        kfMomBeamSpmode   = TL_kfitSpmode[kinpLpim::kmbeam];
        kfMom_pip_Spmode    = TL_kfitSpmode[kinpLpim::pip_g2];
        kfMom_pim_Spmode    = TL_kfitSpmode[kinpLpim::pim_g1];
        kfMom_n_Spmode      = TL_kfitSpmode[kinpLpim::ncds];
        kf_chi2_Spmode      = kinfitter_Spmode.getS();//chi2
        kf_NDF_Spmode       = kinfitter_Spmode.getNDF();
        kf_status_Spmode    = kinfitter_Spmode.getStatus();
        kf_pvalue_Spmode    = ROOT::Math::chisquared_cdf_c(kinfitter_Spmode.getS(), kinfitter_Spmode.getNDF());
        kfMomBeamSmmode   = TL_kfitSmmode[kinpLpim::kmbeam];
        kfMom_pim_Smmode    = TL_kfitSmmode[kinpLpim::pim_g1];
        kfMom_pip_Smmode    = TL_kfitSmmode[kinpLpim::pip_g2];
        kfMom_n_Smmode      = TL_kfitSmmode[kinpLpim::ncds];
        kf_chi2_Smmode      = kinfitter_Smmode.getS();
        kf_NDF_Smmode       = kinfitter_Smmode.getNDF();
        kf_status_Smmode    = kinfitter_Smmode.getStatus();
        kf_pvalue_Smmode    = ROOT::Math::chisquared_cdf_c(kinfitter_Smmode.getS(), kinfitter_Smmode.getNDF());
        kf_flag       = reactionID; //correct_flag;

        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
        // %%% Kinematical Fit using KinFitter %%% //
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //


        //--- for the covariance matrix evaluation ---//
        if( flagG4Decay && IsGoodEvent && MissNFlag && K0rejectFlag ){
          if( ((reactionID==gen::reactionID_Spmode)&&SigmaPFlag)
              ||  ((reactionID==gen::reactionID_Smmode)&&SigmaMFlag)){
            TVector3 primvtx;
            bool IsncdsMatchOK=true;
            //16.041, 16.0446, 7.08828 [MeV]
            //double valpx = TL_meas[kinpLpim::ncds][0] - TL_gene[genID[kinpLpim::ncds]][0];
            //double valpy = TL_meas[kinpLpim::ncds][1] - TL_gene[genID[kinpLpim::ncds]][1];
            //double valpz = TL_meas[kinpLpim::ncds][2] - TL_gene[genID[kinpLpim::ncds]][2];
            //if(  !( -3.* 16.041/1000.  < valpx && valpx < 3.* 16.041/1000.)
            //  || !( -3.* 16.045/1000.  < valpy && valpy < 3.* 16.045/1000.)
            //  || !( -3.* 7.0883/1000.  < valpz && valpz < 3.* 7.0883/1000.) ){
            //  IsncdsMatchOK=false;
            //}

            //evaluate
            for( int ip=0; ip<kinpLpim::npart+1; ip++ ){
              for( int ii=0; ii<4; ii++ ){
                for( int jj=0; jj<4; jj++ ){
                  if(ip!=kinpLpim::npart){
                    double val  = (TL_meas[ip][ii] - TL_gene[genID[ip]][jj]);
                    //Sigma should be suffered energy loss in the target (?)
                    //Use Lorentz vector ncds + decay pion
                    if(IsncdsMatchOK) Tools::Fill1D(Form("cov_%d_%d_%d", ip, ii, jj), val);
                    if(ip==kinpLpim::kmbeam) primvtx = mcData->track(ID[ip])->vertex();
                    TVector3 vertex = mcData->track(ID[ip])->vertex();
                    double mcDCA = (vertex.Mag()-primvtx.Mag())/10.0;
                    //double mcDCA = vertex.Mag()-vtx_react.Mag();
                    TVector3 vertexc(vertex.x()/10.,vertex.y()/10.,vertex.z()/10.);

                    double momX  = fabs(mcData->track(ID[ip])->momentum().x());
                    double momY  = fabs(mcData->track(ID[ip])->momentum().y());
                    double momZ  = fabs(mcData->track(ID[ip])->momentum().z());
                    double mom  = mcData->track(ID[ip])->momentum().Mag();

                    //double mcDCAc = vertexc.Mag()-vtx_react.Mag();
                    //Tools::Fill2D(Form("cov_zvtx_%d_%d_%d", ip, ii,jj), val, vertexc.z());
                    if(IsncdsMatchOK ){
                      if(ii==0) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momX*0.001);
                      if(ii==1) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momY*0.001);
                      if(ii==2) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momZ*0.001);
                      if(ii==3) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, mom*0.001);
                    }
                    if( ii==3 &&  ii==jj && ip==4 ){
                      Tools::H1(Form("vtxdiffx"),vertexc.x()-vtx_react.x() ,1000,-2,2);
                      Tools::H1(Form("vtxdiffy"),vertexc.y()-vtx_react.y() ,1000,-2,2);
                      Tools::H1(Form("vtxdiffz"),vertexc.z()-vtx_react.z() ,1000,-10,10);
                      if(Verbosity_){
                        TLorentzVector TL_S = TL_gene[kinpLpim::ncds]+TL_gene[kinpLpim::pip_g2];
                        TLorentzVector TL_Sreco = TL_meas[kinpLpim::ncds]+TL_meas[kinpLpim::pip_g2];
                        std::cout << __LINE__ << std::endl;
                        std::cout << "Mass gen n+pi " << TL_S.M() << std::endl;
                        std::cout << "Mass reco n+pi " << TL_Sreco.M() << std::endl;
                        std::cout << "IP " << ip << std::endl;
                        std::cout << "mom (gen.) " << mom*0.001 << std::endl;
                        std::cout << "LVec_n " << LVec_n.P() << std::endl;
                        std::cout << "TL_meas[ip] " << TL_meas[ip].P() << std::endl;
                        std::cout << "TL_gen[genID[ip]] " << TL_gene[genID[ip]].P() << std::endl;
                        std::cout << "val " << val << std::endl;
                        //  std::cout<< iev << std::endl;
                        //  std::cout<< "ip:" << ip << std::endl;
                        //std::cout<<" cov "<<ii<<" , "<<jj<<" = "<<TL_meas[ii][jj]<<" - "<<TL_gene[ii][jj]
                        //<<" = "<< (TL_meas[ii][jj] - TL_gene[ii][jj])<<std::endl;
                        std::cout << "mcDCA: " << mcDCA << std::endl;
                        std::cout << "vertex X: " <<  vertex.x() << std::endl;
                        std::cout << "vertex Y: " <<  vertex.y() << std::endl;
                        std::cout << "vertex Z: " <<  vertex.z() << std::endl;
                        std::cout << "reaVTX X: " <<  vtx_react.x() << std::endl;
                        std::cout << "reaVTX Y: " <<  vtx_react.y() << std::endl;
                        std::cout << "reaVTX Z: " <<  vtx_react.z() << std::endl;
                        std::cout << "flight l: " << mcData->track(ID[ip])->FlightLength() << std::endl;
                      }
                    }
                  }else if(ip==kinpLpim::npart){
                    TLorentzVector TL_S = TL_gene[kinpLpim::ncds]+TL_gene[kinpLpim::pip_g2];
                    double val = TL_meas[kinpLpim::Sp][ii] - TL_S[jj];
                    if(IsncdsMatchOK) Tools::Fill1D(Form("cov_%d_%d_%d", ip, ii, jj), val);
                    double momX  = fabs(mcData->track(ID[kinpLpim::Sp])->momentum().x());
                    double momY  = fabs(mcData->track(ID[kinpLpim::Sp])->momentum().y());
                    double momZ  = fabs(mcData->track(ID[kinpLpim::Sp])->momentum().z());
                    double mom  = mcData->track(ID[kinpLpim::Sp])->momentum().Mag();
                    if(IsncdsMatchOK ){
                      if(ii==0) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momX*0.001);
                      if(ii==1) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momY*0.001);
                      if(ii==2) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, momZ*0.001);
                      if(ii==3) Tools::Fill2D(Form("cov_mom_%d_%d_%d", ip, ii,jj), val, mom*0.001);
                    }
                  }
                }//for jj
              }//for ii
            }//for ip
          }//if ((SigmaPFlag || SigmaMFlag))
        }//if flagG4Decay MissNFlag && K0rejectFlag

        kf_flag = reactionID; //correct_flag;
        */
        //--- fill tree ---//
        mc_nparticle = nparticle;
        mom_beam   = LVec_beam;   // 4-momentum(beam)
        mom_target = LVec_target; // 4-momentum(target)
        mom_pim1 = LVec_pim1;        // 4-momentum(pi-)
        mom_pim2 = LVec_pim2;        // 4-momentum(pi-)
        mom_p = LVec_p;            // 4-momentum(neutron)
        mom_p2 = LVec_p2;            // 4-momentum(neutron)
        TVector3 mcvertex = mcData->track(ID[kinpLpim::kmbeam])->vertex();
        TVector3 mcvertexc(mcvertex.x()/10.,mcvertex.y()/10.,mcvertex.z()/10.);
        mc_vtx = mcvertexc;
        TVector3 mcdisvertex = mcData->track(ID[kinpLpim::pcds])->vertex();
        TVector3 mcdisvertexc(mcdisvertex.x()/10.,mcdisvertex.y()/10.,mcdisvertex.z()/10.);
        mc_disvtx = mcdisvertexc;
        vtx_reaction = vtx_react; // vertex(reaction)
        vtx_displaced = vtx_dis; // vertex(reaction)
        vtx_pim1_beam = vtx_beam_wpim1;
        vtx_pim2_beam = vtx_beam_wpim2;
        vtx_p_beam = vtx_beam_wp;
        vtx_p2_beam = vtx_beam_wp2;
        vtx_pim1_cdc = vtx_pim1;
        vtx_pim2_cdc = vtx_pim2;
        vtx_p_cdc = vtx_p;
        vtx_p2_cdc = vtx_p2;
        CA_pim1_pim1p = CroA_pim1_pim1p;
        CA_p_pim1p = CroA_p_pim1p;
        CA_pim1_pim1p2 = CroA_pim1_pim1p2;
        CA_p2_pim1p2 = CroA_p2_pim1p2;
        CA_pim2_pim2p = CroA_pim2_pim2p;
        CA_p_pim2p = CroA_p_pim2p;
        CA_pim2_pim2p2 = CroA_pim2_pim2p2;
        CA_p2_pim2p2 = CroA_p2_pim2p2;
        CA_pim1_pim1pim2 = CroA_pim1_pim1pim2;
        CA_pim2_pim1pim2 = CroA_pim2_pim1pim2;
        ForwardCharge = forwardcharge;
        //run_num   = confMan->GetRunNumber(); // run number
        //event_num = iev;     // event number
        //block_num = 0;      // block number (temp)

        if(Verbosity_) {
          std::cout<<"%%% pippimn event: Event_Number, Block_Event_Number, CDC_Event_Number = "
                   <<iev<<" , "<<" ---, "<<ev_cdc<<std::endl;
        }
        outfile2->cd();
        //if(IsGoodEvent && Lpim_detect)
        if(IsGoodEvent ) {
          ppimpimTree->Fill();
          nFill_ppimpim++;
        }
        outfile->cd();
        //** fill tree **//
      } //Fiducial cuts
    } else { //if pi+ pi- X event
      nAbort_pimpim++;
    }

    nAbort_end++;
    delete detData2;

  } // for iev

  std::cout<<"===== Sigma pi reconstruction in MC END ====="<<std::endl;
  std::cout<<" nEvent       = "<<exen<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nG4Event_Lpim  = "<<nG4Event_Lpim<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" AllGoodTrack = "<<AllGoodTrack<<std::endl;
  std::cout<<" nTrack       = "<<nTrack<<std::endl;
  std::cout<<" nTrack_PID   = "<<nTrack_PID<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nAbort_nGoodTrack  = "<<nAbort_nGoodTrack<<std::endl;
  std::cout<<" nAbort_nCDH        = "<<nAbort_nCDH<<std::endl;
  std::cout<<" nAbort_nT0         = "<<nAbort_nT0<<std::endl;
  std::cout<<" nAbort_nbpc        = "<<nAbort_nbpc<<std::endl;
  std::cout<<" nAbort_bpctrack    = "<<nAbort_bpctrack<<std::endl;
  std::cout<<" nAbort_nblc2       = "<<nAbort_nblc2<<std::endl;
  std::cout<<" nAbort_fblc2bpc    = "<<nAbort_fblc2bpc<<std::endl;
  std::cout<<" nAbort_flagbmom    = "<<nAbort_flagbmom<<std::endl;
  std::cout<<" nAbort_ftarget     = "<<nAbort_ftarget<<std::endl;
  std::cout<<" nAbort_pimpim      = "<<nAbort_pimpim<<std::endl;
  std::cout<<" nAbort_anothern    = "<<nAbort_anothern<<std::endl;
  std::cout<<" nAbort_end         = "<<nAbort_end<<std::endl;
  std::cout<<"***********************************************"<<std::endl;
  std::cout<<" nTrack_CDHshare = "<<nTrack_CDHshare<<std::endl;
  std::cout<<"*** # of pi+ pi- p n n events = "<<nFill_ppimpim<<" ***"<<std::endl;
  std::cout<<"==============================================="<<std::endl;

  outfile->Write();
  outfile->Close();

  outfile2->Write();
  outfile2->Close();

  simfile->Close();
  cdcfile->Close();

  delete pdg;

  delete confMan;
  delete simMan;

  delete evHeaderMC;
  delete detData;
  delete reacData;
  delete mcData;

  delete header;
  delete cdsMan;
  delete blMan;
  delete bltrackMan;
  delete cdstrackMan;

  delete simfile;
  delete cdcfile;
  delete outfile;

  return 0;
}

//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
void InitializeHistogram()
//**--**--**--**--**--**--**--**--**--**--**--**--**--**//
{

  //** geneneral informantion **//
  Tools::newTH1F( Form("EventCheck"), 20, 0, 20 );

  //defined in IMPiSigmaHist.hh
  InitBasicHist(true);
  InitIMLambdaPimHist();
  return;
}

void InitTreeVal()
{

  mom_beam.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam)
  mom_target.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.); // 4-momentum(target)
  mom_pim1.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(pi+)
  mom_pim2.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi-)
  mom_p.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron)
  mom_p2.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron)
  vtx_reaction.SetXYZ(-9999., -9999., -9999.); //  vertex(reaction)
  vtx_displaced.SetXYZ(-9999., -9999., -9999.); //  vertex(reaction)
  vtx_pim1_beam.SetXYZ(-9999., -9999., -9999.); //
  vtx_pim2_beam.SetXYZ(-9999., -9999., -9999.); //
  vtx_p_beam.SetXYZ(-9999., -9999., -9999.); //
  vtx_p2_beam.SetXYZ(-9999., -9999., -9999.); //
  vtx_pim1_cdc.SetXYZ(-9999., -9999., -9999.);
  vtx_pim2_cdc.SetXYZ(-9999., -9999., -9999.);
  vtx_p_cdc.SetXYZ(-9999., -9999., -9999.);
  vtx_p2_cdc.SetXYZ(-9999., -9999., -9999.);
  CA_pim1_pim1p.SetXYZ(-9999., -9999., -9999.);
  CA_p_pim1p.SetXYZ(-9999., -9999., -9999.);
  CA_p2_pim1p2.SetXYZ(-9999., -9999., -9999.);
  CA_pim2_pim2p.SetXYZ(-9999., -9999., -9999.);
  CA_p_pim2p.SetXYZ(-9999., -9999., -9999.);
  CA_p2_pim2p2.SetXYZ(-9999., -9999., -9999.);
  CA_pim1_pim1pim2.SetXYZ(-9999., -9999., -9999.);
  CA_pim2_pim1pim2.SetXYZ(-9999., -9999., -9999.);
  ForwardCharge = 0;
  run_num=-9999;   // run number
  event_num=-9999; // event number
  block_num=-9999; // block number
  mc_nparticle=-9999;
  mcmom_beam.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // generated 4-momentum(beam)
  mcmom_pim1.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // generated 4-momentum(pi+)
  mcmom_pim2.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // generated 4-momentum(pi-)
  mcmom_p.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // generated 4-momentum(neutron)
  mcmom_pmiss.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // generated 4-momentum(neutron)
  react_pmiss.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  react_Lambda.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  react_pim.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);
  
  mc_vtx.SetXYZ(-9999., -9999., -9999.);
  kfMomBeamSpmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);   // 4-momentum(beam) after kinematical refit for pi- Sigma+
  kfMom_pip_Spmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi+) after kinematical refit for pi- Sigma+
  kfMom_pim_Spmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);    // 4-momentum(pi-) after kinematical refit for pi- Sigma+
  kfMom_n_Spmode.SetPxPyPzE(-9999.,-9999.,-9999.,-9999.);      // 4-momentum(neutron) after kinematical refit for pi- Sigma+
  kf_chi2_Spmode=-9999.;   // chi2 of kinematical refit
  kf_NDF_Spmode=-9999.;    // NDF of kinematical refit
  kf_status_Spmode=-9999; // status of kinematical refit -> details can be found in this code
  kf_pvalue_Spmode=-9999; // p-value of kinematical refit
  kf_flag=-9999; // flag of correct pair reconstruction, etc
//= = = = pippimn final-sample tree = = = =//

}

